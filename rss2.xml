<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>无糖拿铁，谢谢</title>
    <link>https://blog.gaoyuexiang.cn/</link>
    
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>Challenge makes me happy.</description>
    <pubDate>Fri, 02 Oct 2020 21:38:48 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>使用 Jackson 处理抽象类的序列化和反序列化</title>
      <link>https://blog.gaoyuexiang.cn/2020/10/02/jackson-inheritance/</link>
      <guid>https://blog.gaoyuexiang.cn/2020/10/02/jackson-inheritance/</guid>
      <pubDate>Fri, 02 Oct 2020 21:38:48 GMT</pubDate>
      <description>
      
        &lt;p&gt;Json 的序列化和反序列化是我们常见的操作，很多库都提供了这样的能力帮助我们完成这样的操作。&lt;br&gt;但业务有时可能变得稍微有些复杂，需要将一个抽象类的子类实例序列化成一个 Json，也需要将一个 Json 反序列化成一个抽象类。而在反序列化的时候，就需要找到真正的子类。&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>Json 的序列化和反序列化是我们常见的操作，很多库都提供了这样的能力帮助我们完成这样的操作。<br>但业务有时可能变得稍微有些复杂，需要将一个抽象类的子类实例序列化成一个 Json，也需要将一个 Json 反序列化成一个抽象类。而在反序列化的时候，就需要找到真正的子类。</p><p><code>Jackson</code> 是 Java 中常用的一种进行 Json 序列化和反序列化的库，它能否面对这样的业务呢？</p><h1 id="业务假设"><a href="#业务假设" class="headerlink" title="业务假设"></a>业务假设</h1><p>假设我们有这样的类结构关系：</p><p><img src="ticket.png" alt=""></p><p>代码写出来长这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.gaoyuexiang.practice.jackson.inheritance;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> TicketType type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@EqualsAndHashCode</span>(callSuper=<span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BugReportingTicket</span> <span class="keyword">extends</span> <span class="title">Ticket</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String productName;</span><br><span class="line">  <span class="keyword">private</span> String stepToReproduce;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@EqualsAndHashCode</span>(callSuper=<span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuestionTicket</span> <span class="keyword">extends</span> <span class="title">Ticket</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String description;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以在 <a href="https://github.com/kbyyd24/jackson-inheritance-practice" target="_blank" rel="noopener">https://github.com/kbyyd24/jackson-inheritance-practice</a> 看到完整代码</p></blockquote><p>接下来所有的序列化和反序列化操作，都是针对类型为 <code>Ticket</code> 的变量来执行的，而不考虑真实的类型。</p><h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><p>序列化不会遇到任何挑战。因为不管变量的真实类型是什么，Jackson 总是会通过所有的 <code>getter</code> 方法来找到所有的属性和值，并序列化到 Json 中。</p><h1 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h1><p>反序列化就不同了，因为程序不知道 Json 应该对应到哪一个子类，所以我们会写出这样的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ticket ticket = <span class="keyword">new</span> ObjectMapper().readValue(json, Ticket<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure><p>而抽象类又不能创建出实例，所以这一行代码就会因为这个限制而出错。</p><p>为了让这一行代码成功执行，为 <code>ticket</code> 变量找到真正的类型，我们就需要使用 <code>@JsonTypeInfo</code> 注解。</p><p>这个注解可以用到属性上，也可以用到类上，影响的只是作用范围，对效果没什么影响。本文只有使用到类上的例子。</p><h2 id="指定-Json-中标识类型的值"><a href="#指定-Json-中标识类型的值" class="headerlink" title="指定 Json 中标识类型的值"></a>指定 Json 中标识类型的值</h2><p>使用这个注解时，需要使用到 use 属性，表示使用哪种信息来作为 Json 对应的实际子类的标识符。我们来看其中的几种。</p><h3 id="CLASS-标识"><a href="#CLASS-标识" class="headerlink" title="CLASS 标识"></a>CLASS 标识</h3><p>使用它时，我们的抽象类得写成这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonTypeInfo</span>(</span><br><span class="line">  use = JsonTypeInfo.Id.CLASS</span><br><span class="line">)</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> TicketType type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>CLASS</code> 表示使用全限定类名来表示 Json 对应的类型，并且会在序列化的 Json 中插入一个 key 为 <code>@class</code> 的信息，值为类的全限定名。</p><p>比如下面的代码，就会得到这样的 Json：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> ticket = <span class="keyword">new</span> QuestionTicket()</span><br><span class="line">ticket.type = TicketType.QUESTION</span><br><span class="line">ticket.description = <span class="string">"some description"</span></span><br><span class="line"><span class="keyword">def</span> json = <span class="keyword">new</span> ObjectMapper.writeValueAsString(ticket)</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"@class"</span>:<span class="string">"cn.gaoyuexiang.practice.jackson.inheritance.QuestionTicket"</span>,<span class="attr">"type"</span>:<span class="string">"QUESTION"</span>,<span class="attr">"description"</span>:<span class="string">"some description"</span>&#125;</span><br></pre></td></tr></table></figure><p>显然，Json 中的 <code>@class</code> 并不是 QuestionTicket 对象的字段，而是我们的注解导致这个字段的出现。<br>这时我们使用这个 Json 来做反序列化，就能得到一个 Ticket 对象，并且实际类型是 QuestionTicket。</p><h3 id="MINIMAL-CLASS-标识"><a href="#MINIMAL-CLASS-标识" class="headerlink" title="MINIMAL_CLASS 标识"></a>MINIMAL_CLASS 标识</h3><p>这个标识同样使用类名来作为 Id，但是与 <code>CLASS</code> 不同，它不使用全限定名，而是根据子类来计算出应该是使用单纯的类名，还是包含一部分的包名。并且，最终的值前面会加上一个 <code>.</code>。</p><p>使用这个标识时，使用 <code>@c</code> 作为 key 插入到 Json 中，上面的代码会得到这样的 Json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"@c"</span>:<span class="string">".QuestionTicket"</span>,<span class="attr">"type"</span>:<span class="string">"QUESTION"</span>,<span class="attr">"description"</span>:<span class="string">"some description"</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="NAME-标识"><a href="#NAME-标识" class="headerlink" title="NAME 标识"></a>NAME 标识</h3><p>NAME 标识表示使用逻辑名称来标识 Json 对应的类型。默认情况下的逻辑名称是类名。</p><p>比如下面的代码会产生的 Json：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonTypeInfo</span>(</span><br><span class="line">  use = JsonTypeInfo.Id.NAME</span><br><span class="line">)</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> TicketType type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"@type"</span>:<span class="string">"QuestionTicket"</span>,<span class="attr">"type"</span>:<span class="string">"QUESTION"</span>,<span class="attr">"description"</span>:<span class="string">"some description"</span>&#125;</span><br></pre></td></tr></table></figure><p>我们可以使用 <code>@JsonSubTypes</code> 注解来指定逻辑名称和子类的映射关系：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonTypeInfo</span>(</span><br><span class="line">  use = JsonTypeInfo.Id.NAME</span><br><span class="line">)</span><br><span class="line"><span class="meta">@JsonSubTypes</span>(&#123;</span><br><span class="line">  <span class="meta">@JsonSubTypes</span>.Type(value = QuestionTicket<span class="class">.<span class="keyword">class</span>, <span class="title">name</span> </span>= <span class="string">"QUESTION"</span>),</span><br><span class="line">  <span class="meta">@JsonSubTypes</span>.Type(value = BugReportingTicket<span class="class">.<span class="keyword">class</span>, <span class="title">name</span> </span>= <span class="string">"BUG_REPORTING"</span>),</span><br><span class="line">&#125;)</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> TicketType type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"@type"</span>:<span class="string">"QUESTION"</span>,<span class="attr">"type"</span>:<span class="string">"QUESTION"</span>,<span class="attr">"description"</span>:<span class="string">"some description"</span>&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>@JsonSubTypes.Type</code> 注解的 name 属性没有指定时，Jackson 会查找这个类上的 <code>@JsonTypeName</code> 注解的值用作 name ；如果也不存在，就会使用类名。</p></blockquote><p>我们可以看到 <code>@JsonSubTypes</code> 注解帮助我们维护了一个逻辑上唯一的字符串和子类的映射关系，这样 Jackson 就可以根据这样的映射关系来进行序列化和反序列化了。</p><h2 id="指定标识符在-Json-中的表现形式"><a href="#指定标识符在-Json-中的表现形式" class="headerlink" title="指定标识符在 Json 中的表现形式"></a>指定标识符在 Json 中的表现形式</h2><p>上面的三种标识符类型，都是在原本对象序列化的 Json 中插入了一个字段来完成的。这是因为 <code>@JsonTypeInfo</code> 的 include 属性默认值是 <code>PROPERTY</code>，也就是说是在 Json 中插入一条 property。</p><blockquote><p>如果 Json 中恰好有一条 property 的名字和要插入的 property 重复，那么就可能看到 Json 中出现两个相同 key 的字段。这可能导致一些 Json 库识别这个 Json 时出现错误，因为 Json 规范没有规定 Json 中是否可以出现两个相同的 key，具体会表现为什么行为依赖于每个库的实现。</p></blockquote><p>当然，除了 <code>PROPERTY</code> 还有其他的形式可以选择。</p><h3 id="WRAPPER-ARRAY"><a href="#WRAPPER-ARRAY" class="headerlink" title="WRAPPER_ARRAY"></a>WRAPPER_ARRAY</h3><p>这种方式会将 Json 序列化成一个数组，第一个值是 Id，第二个值才是真正的对象序列化后的 Json。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonTypeInfo</span>(</span><br><span class="line">  use = JsonTypeInfo.Id.NAME,</span><br><span class="line">  include = JsonTypeInfo.As.WRAPPER_ARRAY</span><br><span class="line">)</span><br><span class="line"><span class="meta">@JsonSubTypes</span>(&#123;</span><br><span class="line">  <span class="meta">@JsonSubTypes</span>.Type(value = QuestionTicket<span class="class">.<span class="keyword">class</span>, <span class="title">name</span> </span>= <span class="string">"QUESTION"</span>),</span><br><span class="line">  <span class="meta">@JsonSubTypes</span>.Type(value = BugReportingTicket<span class="class">.<span class="keyword">class</span>, <span class="title">name</span> </span>= <span class="string">"BUG_REPORTING"</span>),</span><br><span class="line">&#125;)</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> TicketType type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"QUESTION"</span>,&#123;<span class="attr">"type"</span>:<span class="string">"QUESTION"</span>,<span class="attr">"description"</span>:<span class="string">"some description"</span>&#125;]</span><br></pre></td></tr></table></figure><h3 id="WRAPPER-OBJECT"><a href="#WRAPPER-OBJECT" class="headerlink" title="WRAPPER_OBJECT"></a>WRAPPER_OBJECT</h3><p>与 <code>WRAPPER_ARRAY</code> 类型，不过这种形式不是得到的数组，而是一个对象，其中的 key 就是 Id。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonTypeInfo</span>(</span><br><span class="line">  use = JsonTypeInfo.Id.NAME,</span><br><span class="line">  include = JsonTypeInfo.As.WRAPPER_OBJECT</span><br><span class="line">)</span><br><span class="line"><span class="meta">@JsonSubTypes</span>(&#123;</span><br><span class="line">  <span class="meta">@JsonSubTypes</span>.Type(value = QuestionTicket<span class="class">.<span class="keyword">class</span>, <span class="title">name</span> </span>= <span class="string">"QUESTION"</span>),</span><br><span class="line">  <span class="meta">@JsonSubTypes</span>.Type(value = BugReportingTicket<span class="class">.<span class="keyword">class</span>, <span class="title">name</span> </span>= <span class="string">"BUG_REPORTING"</span>),</span><br><span class="line">&#125;)</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> TicketType type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"QUESTION"</span>:&#123;<span class="attr">"type"</span>:<span class="string">"QUESTION"</span>,<span class="attr">"description"</span>:<span class="string">"some description"</span>&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="EXISTING-PROPERTY"><a href="#EXISTING-PROPERTY" class="headerlink" title="EXISTING_PROPERTY"></a>EXISTING_PROPERTY</h3><p>顾名思义，这个形式表示将会使用原 Json 本来就有的一个字段。</p><p>使用这种形式时：</p><ol><li>序列化将不会对原本的 Json 做任何修改</li><li>我们需要指定 property 属性，以表明使用原本 Json 中的哪一个字段来表示 Id</li></ol><p>这两点表明，在使用这种形式时，原本的 Json 的这个字段自身就应该表示出对应的类型。</p><p>反序列化时，Jackson 会找到指定的 property，通过它的值和 <code>JsonSubTypes</code> 的配置来确定应该使用哪一个子类。</p><blockquote><p>property 属性在任何时候都可以使用，它可以替换掉默认的 <code>@class</code>、<code>@c</code> 和 <code>@type</code> 字段。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonTypeInfo</span>(</span><br><span class="line">  use = JsonTypeInfo.Id.NAME,</span><br><span class="line">  include = JsonTypeInfo.As.EXISTING_PROPERTY,</span><br><span class="line">  property = <span class="string">"type"</span></span><br><span class="line">)</span><br><span class="line"><span class="meta">@JsonSubTypes</span>(&#123;</span><br><span class="line">  <span class="meta">@JsonSubTypes</span>.Type(value = QuestionTicket<span class="class">.<span class="keyword">class</span>, <span class="title">name</span> </span>= <span class="string">"QUESTION"</span>),</span><br><span class="line">  <span class="meta">@JsonSubTypes</span>.Type(value = BugReportingTicket<span class="class">.<span class="keyword">class</span>, <span class="title">name</span> </span>= <span class="string">"BUG_REPORTING"</span>),</span><br><span class="line">&#125;)</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> TicketType type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"type"</span>:<span class="string">"QUESTION"</span>,<span class="attr">"description"</span>:<span class="string">"some description"</span>&#125;</span><br></pre></td></tr></table></figure><hr><p>另外，还有一种表现形式是 <code>EXTERNAL_PROPERTY</code>，可以参考<a href="https://stackoverflow.com/a/20914599/6487869" target="_blank" rel="noopener">这个问题</a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我们了解了 Jackson 可以通过不同的标识符、以不同的形式来识别一个 Json 应该映射到哪一个类型，我们可以对如何使用做一个简单的判断。</p><p>无论是使用 <code>CLASS</code> 还是 <code>MINIMAL_CLASS</code> 类型，都会在 Json 中插入类的信息，这样既增加了 Json 和实现的耦合，也不利于重构，还导致了技术细节的泄露。</p><p>使用 <code>NAME</code> 这样的逻辑名称来标识 Json 类型看起来是比较好的做法，并且使用 Json 中本来就有的信息时，就完全去除了技术实现对 Json 的侵入，降低了耦合。</p><p>至于表现形式，则应该由 Json 本来的设计来决定。Jackson 已经给出了好几种支持，可以选择最接近设计的一种。</p>]]></content:encoded>
      
      <comments>https://blog.gaoyuexiang.cn/2020/10/02/jackson-inheritance/#disqus_thread</comments>
    </item>
    
    <item>
      <title>圈复杂度</title>
      <link>https://blog.gaoyuexiang.cn/2020/08/15/cyclomatic-complexity/</link>
      <guid>https://blog.gaoyuexiang.cn/2020/08/15/cyclomatic-complexity/</guid>
      <pubDate>Sat, 15 Aug 2020 16:56:16 GMT</pubDate>
      <description>
      
        &lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;过去我知道有圈复杂度这个概念，它代表了代码的复杂程度。但是却没有了解过它是怎么算出来的，哪些代码会影响它的结果。
今天我们就来看一下，圈复杂度这个概念。&lt;/p&gt;
&lt;/div&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<div class="paragraph"><p>过去我知道有圈复杂度这个概念，它代表了代码的复杂程度。但是却没有了解过它是怎么算出来的，哪些代码会影响它的结果。今天我们就来看一下，圈复杂度这个概念。</p></div><div class="sect1"><h2 id="_什么是圈复杂度">什么是圈复杂度</h2><div class="sectionbody"><div class="paragraph"><p>圈复杂度这个概念在 1976 年就已经被提出来了，比很多编程语言还要古老。它的英文名是 Cyclomatic complexity，中文是圈复杂度、循环复杂度或者条件复杂度。显然圈复杂度并不是一个好的翻译，因为第一次看到的时候，其实不知道它是个什么东西。但是另外两个名字也只能表示它的部分内容。</p></div><div class="paragraph"><p>圈复杂度被用来判断程序的复杂程度，圈复杂度越高，则代表程序越复杂。它的数值代表的是程序的<strong>线性独立路径</strong>的数量。</p></div><div class="quoteblock"><blockquote><div class="paragraph"><p>线性独立路径，又被称作线性无关路径，是一条至少包含一条在其他任何线性独立路径中从未有过的边的路径。</p></div></blockquote></div></div></div><div class="sect1"><h2 id="_如何计算圈复杂度">如何计算圈复杂度</h2><div class="sectionbody"><div class="sect2"><h3 id="_单结束点">单结束点</h3><div class="paragraph"><p>对于单结束点的程序，圈复杂度的计算公式很简单，我们需要先画出程序的控制流图，用 M 代表圈复杂度：</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-text" data-lang="text"><pre><code class="highlight text">M &#x3D; E - N + 2P</code></pre></code></pre></div></div><div class="paragraph"><p>上面的：</p></div><div class="ulist"><ul><li><p>E：图中的边的数量</p></li><li><p>N：图中的节点数量</p></li><li><p>P：图中 <code>connected component</code> 的数量</p></li></ul></div><div class="quoteblock"><blockquote><div class="paragraph"><p><code>connected component</code> 是来自图论的概念，叫做元件，它是一个无向子图，上面的所有节点都不能到达子图以外的节点。在程序设计的上下文里，这个值永远是 1。</p></div></blockquote></div><div class="paragraph"><p>我们可以看一下这个例子：</p></div><div class="imageblock"><div class="content"><img src="flow.jpg" alt="flow"></div></div><div class="paragraph"><p>在这个图中，我们有 10 条边、9 个节点、1 个元件，所以 M = 10 - 9 + 2 = 3。</p></div><div class="paragraph"><p>对于程序而言，因为只有一个进入点，所以上面的公式可以再做一步简化：</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-text" data-lang="text"><pre><code class="highlight text">M &#x3D; π + 1</code></pre></code></pre></div></div><div class="paragraph"><p>其中，π 代表程序中的决策点。</p></div></div><div class="sect2"><h3 id="_多结束点">多结束点</h3><div class="paragraph"><p>对于多个结束点（比如多个 return 语句）的程序，上面的公式就不太适用了，而需要一个新的公式：</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-text" data-lang="text"><pre><code class="highlight text">M &#x3D; π - s + 2</code></pre></code></pre></div></div><div class="paragraph"><p>其中 s 代表结束点的数量。我们可以发现这个公式同样适用于单结束点的程序。</p></div></div></div></div><div class="sect1"><h2 id="_影响圈复杂度的因素">影响圈复杂度的因素</h2><div class="sectionbody"><div class="paragraph"><p>既然知道了计算圈复杂度的公式，那么我们就知道了影响它的因素：决策点和结束点。</p></div><div class="paragraph"><p>对应到代码里，结束点就是 return 语句和 throw exception。</p></div><div class="paragraph"><p>而决策点就很多了，不仅包括 if、case、for 等语句，三元表达式和 catch 语句同样也是决策点。</p></div><div class="quoteblock"><blockquote><div class="paragraph"><p>这也是为什么说循环复杂度和条件复杂度这两个翻译不够好的原因，因为决策点包含了循环和条件控制这两个内容。</p></div></blockquote></div><div class="paragraph"><p>想要降低圈复杂度，我们可以选择增加 return 语句，比如提前 return 或者 throw exception。我们也可以选择减少 if 等语句的使用，通过抽方法、合并条件等重构手段达到这个目的。</p></div></div></div><div class="sect1"><h2 id="_圈复杂度与代码质量">圈复杂度与代码质量</h2><div class="sectionbody"><div class="paragraph"><p>圈复杂度与代码质量息息相关。</p></div><div class="paragraph"><p>因为越复杂的代码，越难以维护，一点小小的改动就可能造成程序运行失败。所以在一些代码扫描工具中，比如 sonarqube，就要求方法的圈复杂度不能高于 10。</p></div><div class="paragraph"><p>另外，越复杂的代码，意味着越难以测试。因为我们需要让测试覆盖到尽可能多的情况，圈复杂度越高，意味着需要覆盖的情况越多，测试也就越难写。这可能就导致这段代码没有被完整的覆盖到，再加上较高的圈复杂度导致代码阅读的困难，就难以保证对它的修改不会破坏掉它的功能。</p></div><div class="paragraph"><p>所以，为了增加代码质量，我们应该尽可能的减少圈复杂度。</p></div></div></div><div class="sect1"><h2 id="_总结">总结</h2><div class="sectionbody"><div class="paragraph"><p>我们了解了圈复杂度代表的是程序的控制流图的线性独立路径的数量，代表了程序的复杂程度。增加结束点和减少决策点都能减少圈复杂度。</p></div></div></div><div class="sect1"><h2 id="_思考">思考</h2><div class="sectionbody"><div class="paragraph"><p>尽管程序员可以修改代码降低各个程序函数的圈复杂度，但是整个程序的圈复杂度却不会改变，因为这是由业务决定的，而不是可以通过修改代码而改变的。而且在程序设计中引用圈复杂度，本来就是为了能在函数级别降低复杂度，而不是为了降低业务复杂度（本来也做不到）。所以不必纠结“方法的复杂度是下降了，但是整体的复杂度却没有”这种事情。</p></div></div></div>]]></content:encoded>
      
      <comments>https://blog.gaoyuexiang.cn/2020/08/15/cyclomatic-complexity/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Eureka 中的幽灵 —— Self Preservation 导致的幽灵服务</title>
      <link>https://blog.gaoyuexiang.cn/2020/07/25/eureka-self-preservation-mode/</link>
      <guid>https://blog.gaoyuexiang.cn/2020/07/25/eureka-self-preservation-mode/</guid>
      <pubDate>Sat, 25 Jul 2020 23:31:52 GMT</pubDate>
      <description>
      
        &lt;p&gt;Eureka 是 Spring Cloud Netflix 的服务注册与发现工具。一般情况下，它都能很好的工作，但有时却会出现一些匪夷所思的情况。&lt;br&gt;今天我们就来研究一下不当的配置导致的幽灵服务。&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>Eureka 是 Spring Cloud Netflix 的服务注册与发现工具。一般情况下，它都能很好的工作，但有时却会出现一些匪夷所思的情况。<br>今天我们就来研究一下不当的配置导致的幽灵服务。</p><h1 id="幽灵出现"><a href="#幽灵出现" class="headerlink" title="幽灵出现"></a>幽灵出现</h1><p>我们先来给幽灵服务做一个定义：它们是 Eureka 注册表中的一些节点，但是它们实际上已经被关闭了，永远无法访问。</p><p>我们可以通过 <code>GET /eureka/apps</code> 获取 Eureka 中注册的节点信息，其中包含了节点的最后更新时间： lastRenewalTimestamp 。如果发现这个时间已经过去了很久，那么这个节点可能就是一个幽灵节点。</p><p>这其实是一个非常反常的现象，因为 Eureka client 在关闭时，通过 <code>@PreDestroy</code> 触发 <code>DiscoveryClient.shutdown()</code> 方法，向 Eureka Server 发送 shutdown 请求，从 Eureka Server 注册表中注销。</p><p>那么问题来了。</p><h1 id="为什么这些服务没有注销？"><a href="#为什么这些服务没有注销？" class="headerlink" title="为什么这些服务没有注销？"></a>为什么这些服务没有注销？</h1><p>因为 <code>@PreDestroy</code> 是用来处理 <code>SIGTERM</code> 等信号的，所以只有在通过这些信息关闭 Eureka client 时，Eureka client 才会向 Eureka Server 发送 shutdown 请求。<br>但是如果是通过 <code>kill -9</code> 这样的指令，或者是 <a href="/2020/06/18/graceful-shutdown-docker-container/">不优雅的 stop docker</a> ，即发送 <code>SIGKILL</code> 信号，都不会触发 <code>PreDestroy</code>，那么这些 Eureka client 也就不会被注销了。</p><p>那么问题又来了。</p><h1 id="难道-Eureka-不会清理过期的注册信息吗？"><a href="#难道-Eureka-不会清理过期的注册信息吗？" class="headerlink" title="难道 Eureka 不会清理过期的注册信息吗？"></a>难道 Eureka 不会清理过期的注册信息吗？</h1><p>其实是会的。</p><p>在 Eureka Server 的核心库 <code>eureka-core</code> 中，有一个 <code>AbstractInstanceRegistry</code> 类，其中实现了 <code>evict()</code> 方法，用来完成清理过期注册信息的工作。这个方法被一个 <code>TimerTask</code> 定时调用，默认间隔时间是 60s。</p><p>在这个方法中，Eureka server 会：</p><ol><li>找到所有过期的 <code>Lease</code> (对应一个 Eureka client 节点)</li><li>通过本地注册的 <code>Lease</code> 数量和一个阈值 <em>(后面还有戏份)</em> 计算出一个 evictonLimit 数值</li><li>比较过期的 <code>Lease</code> 数量和 evictionLimit 的大小，选出小的那个数作为本次清理的数量</li><li>从过期的 <code>List&lt;Lease&gt;</code> 中随机挑出 n 个 <code>Lease</code>，删除 (这里的 n 就是上一步的结果)</li></ol><p>这里的阈值通过 <code>eureka.server.renewal-percent-threshold</code> 设置，默认值是 0.85。</p><p>后面限制每次清理节点数量的算法，只是一种性能优化的考虑。如果忽略掉这部分的逻辑，我们可以认为，一个节点长时间没有向 Eureka server 发送心跳请求，那么它的 <code>Lease</code> 就会过期，最终被定时任务清楚掉。</p><p>因为默认的租期时间是 90s，evict 周期是 60s，所以一个服务被不优雅的关闭后，最多经过 120s 就可以被清理出注册表。</p><p>但是 eureka 在这里却有一个 <a href="https://github.com/Netflix/eureka/issues/531" target="_blank" rel="noopener">bug</a>。Eureka server 在接收到心跳请求时，会把当前时间加上租期时间作为最后接收到心跳的时间。然后在清理时，又会在这个时间上再加一个租期时间来判断是否过期。所以一个服务过期时间总共是 180s，它被不优雅的关闭后最多经过 240s 就会被清理掉。</p><p>但是事情可能没有那么简单，别说 240s，就是过了两天，这些幽灵服务可能还在你的注册表里。</p><p>这就涉及到另一个问题，Eureka server self-preservation mode.</p><h1 id="自我保护模式"><a href="#自我保护模式" class="headerlink" title="自我保护模式"></a>自我保护模式</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>Eureka client 之间调用时，不会向 Eureka server 发送任何请求，而是根据本地维护的注册表，找到需要调用的服务，直接调用，也就是 peer to peer 的模式。本地的注册表，其实是从 Eureka server 拉取回来的，默认每 30s 拉取一次更新。<br>那么当 Eureka server 因为网络震荡没有接收到某些 Eureka client 发送的心跳请求时，并不意味着 Eureka client 之间的网络也出现了问题，Eureka client 之间可能仍然能够访问。<br>如果这个时候更新注册表，清理了只是因为网络震荡而没有发送心跳的节点，那么本可能成功的调用就会失败。<br>为了减少对服务的影响，Eureka 默认启动了自我保护模式，不会清理掉过期的注册信息。</p><p>官方详细的解释可以看<a href="https://github.com/Netflix/eureka/wiki/Server-Self-Preservation-Mode" target="_blank" rel="noopener">这里</a>。</p><h2 id="自我保护的逻辑"><a href="#自我保护的逻辑" class="headerlink" title="自我保护的逻辑"></a>自我保护的逻辑</h2><p>在上面介绍的 <code>evict</code> 方法的逻辑之前，eureka 会首先调用 <code>isLeaseExpirationEnabled</code> 方法，以判断是否要执行后续的清理逻辑。</p><p>这个方法首先会判断是否启用了自我保护模式，如果没有启用，那么就返回 <code>true</code>，否则会返回下面这个表达式的结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">number-of-renews-per-min-threshold &gt; 0 </span><br><span class="line">  &amp;&amp; num-of-renews-in-last-min &gt; number-of-renews-per-min-threshold</span><br></pre></td></tr></table></figure><p>那么接下来我们就看看这两个值是什么。</p><h3 id="Number-of-Renews-in-Last-Minute"><a href="#Number-of-Renews-in-Last-Minute" class="headerlink" title="Number of Renews in Last Minute"></a>Number of Renews in Last Minute</h3><p>这个值的含义顾名思义，就是过去一分钟内，eureka server 接收到的心跳请求次数。这不是实时数据，而是每分钟更新一次。具体逻辑被 <code>MeasureRate</code> 实现。</p><p>由于 eureka client 默认配置的心跳间隔是 30s，所以这默认情况下的这个值就是 <code>2*client-size</code>。</p><h3 id="Number-of-Renews-per-Minute-Threshold"><a href="#Number-of-Renews-per-Minute-Threshold" class="headerlink" title="Number of Renews per Minute Threshold"></a>Number of Renews per Minute Threshold</h3><p>这个值就相对复杂一些，表示的是触发自我保护模式的心跳阈值。根据表达式，就明白它的含义：当过去一分钟实际接收到的心跳总数小于等于这个心跳阈值时，就会触发自我保护模式，Eureka server 就不会清理注册信息。</p><p>接着，我们来看看这个阈值是如何计算出来的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(int) (expected-number-of-clients-sending-renews </span><br><span class="line">  * (60.0 &#x2F; expected-client-renewal-interval-seconds)</span><br><span class="line">  * renewal-percent-threshold)</span><br></pre></td></tr></table></figure><p>好了，这里又冒出来三个值，我们先来看看后两个。</p><h4 id="Expected-Client-Renewal-Interval-Seconds"><a href="#Expected-Client-Renewal-Interval-Seconds" class="headerlink" title="Expected Client Renewal Interval Seconds"></a>Expected Client Renewal Interval Seconds</h4><p>这是一个配置的值，默认 30s，通过 <code>eureka.server.expected-client-renewal-interval-seconds</code> 配置。</p><p>需要注意的是，这个值不是 client 真实的发送心跳的时间间隔，真实的心跳间隔是值 client 中配置的 <code>eureka.instance.lease-renewal-interval-in-seconds</code>，同样默认 30s。</p><p>但这两个值显然应该保持一致，因为上面的 number-of-renews-in-last-min 其实就是 <code>(60 / lease-renewal-interval-in-seconds) * client-size</code>，而这里也几乎是同样的逻辑（如果把 expected-number-of-clients-sending-renews 看作 <code>client-size</code> 的话）。</p><h4 id="Renewal-Percent-Threshold"><a href="#Renewal-Percent-Threshold" class="headerlink" title="Renewal Percent Threshold"></a>Renewal Percent Threshold</h4><p>这个值在前面讲清理注册信息的时候已经讲过了，默认值 0.85。</p><h4 id="Expected-Number-of-Clients-Sending-Renews"><a href="#Expected-Number-of-Clients-Sending-Renews" class="headerlink" title="Expected Number of Clients Sending Renews"></a>Expected Number of Clients Sending Renews</h4><p>根据名字，这个值代表的是期望的会发送心跳请求的 client 数量，也就是前面的 <code>client-size</code>。但是实际上的值却有可能不同。</p><p>这个值的一个更新时间是启动 eureka server 时。Eureka server 会尝试从配置的邻居 server 节点拉取注册表信息来配置。如果没有邻居节点，或者注册表中没有信息的话，就会被设置为默认值 1，通过 <code>eureka.server.defaultOpenForTrafficCount</code> 配置。</p><blockquote><p>不是很明白为什么要设置默认值为 1。不过相关代码中，在注册与注销时，都只有在这个值大于 0 时才会更新。</p></blockquote><p>这个值的另一个更新时间是一个定时任务，默认每 15min 执行一次。可以通过 <code>eureka.server.renewal-threshold-update-interval-ms</code> 修改这个时间。</p><p>最后，每当这个值被更新之后，都会更新我们的心跳阈值。</p><p>了解了上面的这些逻辑，我们了解到，如果符合 <code>应有的心跳数 - 失去的心跳数 ≤ 心跳阈值</code>，那么就会触发自我保护机制。</p><h2 id="处理一个幽灵服务的极限值"><a href="#处理一个幽灵服务的极限值" class="headerlink" title="处理一个幽灵服务的极限值"></a>处理一个幽灵服务的极限值</h2><p>了解了前面这些，我不禁产生一个疑问：在默认配置的情况下，有多少个 client 之后，eureka server 才会清理掉过期的注册信息？出现多少个过期的注册信息，就会触发自我保护模式？</p><p>这其实只是一个数学问题。假设集群中一共有 n 个 client，eureka server 能接受的不会触发自我保护模式的过期注册信息个数有 m 个，那么我们就可以有如下的推导：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">threshold &#x3D; (n + default-open-for-traffic-count) * (60 &#x2F; expect-client-renewal-interval-second) * renewal-percent-threshold</span><br><span class="line">&#x2F;&#x2F; 带入默认的配置之后</span><br><span class="line">&#x3D;&gt; threshold &#x3D; (n + 1) * (60 &#x2F; 30) * 0.85 &#x3D; 1.7(n + 1)</span><br><span class="line">&#x2F;&#x2F; 因为每 30s 发送一次心跳，所以 n 个服务就应该有 2n 个心跳， m 个幽灵服务就会失去 2m 个心跳</span><br><span class="line">2n - 2m ≤ 1.7(n + 1)</span><br><span class="line">&#x3D;&gt; 2n - 1.7(n + 1) ≤ 2m</span><br><span class="line">&#x3D;&gt; 0.15n - 0.85 ≤ m</span><br></pre></td></tr></table></figure><p>所以，一个集群如果要能够处理一个过期的注册信息，也就是 m=1， 那么至少需要有多于 12.33 个 eureka client，也就是 13 个。<br>换句话说，在默认配置下，如果集群中只有不到 13 个服务，那么任何一个服务被不优雅的关闭，都会出现幽灵服务。</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>为了验证上面的结论，我写了个 <a href="https://github.com/kbyyd24/eureka-self-preservation-verify" target="_blank" rel="noopener">demo</a> 来验证一下。</p><blockquote><p>为了保证每分钟的 <code>evict</code> 方法都用到最新的心跳阈值，我把 <code>expected-number-of-clients-sending-renews</code> 的更新时间设置为了 60s。</p></blockquote><blockquote><p>这个 demo 用了 docker-compose，验证的步骤需要启动 14 个 container，想要试试的同学需要给自己的 docker 多分配点资源。</p></blockquote><h4 id="12-个-client-会触发自我保护模式"><a href="#12-个-client-会触发自我保护模式" class="headerlink" title="12 个 client 会触发自我保护模式"></a>12 个 client 会触发自我保护模式</h4><p>话不多说，直接启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d eureka-clinet=12</span><br></pre></td></tr></table></figure><p>稍等一会儿，访问 <a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a> 就可以在 eureka 的页面上看到两个值：</p><ul><li>Renews threshold: 22</li><li>Renews (last min): 24</li></ul><p><img src="12-online-client.png" alt=""></p><p>这两个值都符合上面的数学计算。</p><p>然后，随便杀掉一个 client (一定要使用 docker kill，避免 client 发送 shutdown 请求):</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker kill eureka-self-preservation-verify_eureka-client_1</span><br></pre></td></tr></table></figure><p>然后几分钟过去了，eureka server 的注册服务仍然有 12 个。</p><p><img src="12-1-offline-client.png" alt=""></p><h4 id="13-个-client-能够处理掉一个幽灵服务"><a href="#13-个-client-能够处理掉一个幽灵服务" class="headerlink" title="13 个 client 能够处理掉一个幽灵服务"></a>13 个 client 能够处理掉一个幽灵服务</h4><p>还是上面的命令，只是这次我们启动 13 个 eureka-client</p><p><img src="13-online-client.png" alt=""></p><p>然后也是随便杀掉一个 client，等待结果。</p><p>被杀掉的节点被清理前：</p><p><img src="13-1-offline-client.png" alt=""></p><p>被杀掉的节点被清理后：</p><p><img src="13-evicted-client.png" alt=""></p><p>还可以观察一下杀掉两个 client 的效果：</p><p><img src="13-2-offline.png" alt=""></p><p>同时，也可以利用 <code>GET /eureka/apps</code> 查看注册信息，关注被杀掉的节点的 lastRenewalTimestamp 信息。这是它的最后注册时间，因为加了 90s，所以应该是一个未来的时间。用这个时间加上 90s，在这之后的第一次 <code>evict</code> 就应该清理掉这个节点信息，这可以在 eureka-server 的日志中看到。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我们研究了 eureka 的自我保护模式，它的目的是避免在出现网络震荡时删除掉可能正常工作的节点信息。但如果配置不当，自我保护模式反而可能产生幽灵服务。</p><p>可以影响到自我保护模式的配置主要有两个：</p><ul><li><code>eureka.server.enable-self-preservation</code> 默认为 <code>true</code></li><li><code>eureka.server.renewal-percent-threshold</code> 默认为 0.85</li></ul><p>根据实际的情况，我们可能需要直接关闭自我保护模式，或者找出一个更适合具体情况的 threshold。</p>]]></content:encoded>
      
      <comments>https://blog.gaoyuexiang.cn/2020/07/25/eureka-self-preservation-mode/#disqus_thread</comments>
    </item>
    
    <item>
      <title>如何使用 Spring Security ACL</title>
      <link>https://blog.gaoyuexiang.cn/2020/07/18/how-to-use-spring-security-acl/</link>
      <guid>https://blog.gaoyuexiang.cn/2020/07/18/how-to-use-spring-security-acl/</guid>
      <pubDate>Sat, 18 Jul 2020 12:17:26 GMT</pubDate>
      <description>
      
        使用 Spring Security ACL 的例子
      
      </description>
      
      
      <content:encoded><![CDATA[<div class="paragraph"><p>在<a href="/2020/07/02/spring-security-acl-conception-and-component/">上一篇文章</a>中，我们了解了 Spring Security ACL 的基本概念。但是几乎没有涉及实现与使用的部分。这篇文章我们就来看一看如何在使用了 Spring 的项目中使用 Spring Security。</p></div><div class="sect1"><h2 id="_导入_jar_包">导入 Jar 包</h2><div class="sectionbody"><div class="paragraph"><p>Spring Security ACL 的 GAV 是 <code>org.springframework.security:spring-security-acl:&lt;version&gt;</code>，被加入到了 <a href="https://docs.spring.io/platform/docs/1.0.1.RELEASE/reference/htmlsingle/#appendix-dependency-versions" target="_blank" rel="noopener">Spring IO Platform bom</a> 中，所以可以使用 Spring 的依赖管理插件来管理版本号。</p></div><div class="paragraph"><p>但是 Spring 没有提供相应的 boot starter，使用的时候需要自己进行配置。毕竟 ACL 中提供的默认实现很可能达不到需求，还不如自己动手。</p></div></div></div><div class="sect1"><h2 id="_存储_acl">存储 ACL</h2><div class="sectionbody"><div class="paragraph"><p>ACL 需要被持久化起来，否则系统重启后就丢掉了权限信息。</p></div><div class="sect2"><h3 id="_基于_jdbc_的持久化">基于 JDBC 的持久化</h3><div class="paragraph"><p>Spring Security ACL 提供了默认的 <code>AclService</code> 和 <code>MutableAclService</code> 实现：<code>JdbcAclService</code> 和 <code>JdbcMutableAclService</code>。</p></div><div class="paragraph"><p>因为是基于 <code>JDBC</code> 的实现，所以就可能存在性能问题（绝大多数情况下不需要更新 ACL，但使用 JDBC 时总是会访问数据库，得到一模一样的 ACL）。于是 ACL 又设计了一个缓存机制来减少对数据库的请求。缓存的接口是 <code>AclCache</code>，Spring 提供了基于 Eh-Cache 和 Spring Cache 的两个实现。</p></div><div class="quoteblock"><blockquote><div class="paragraph"><p><code>AclCache</code> 接口被安排在了 <code>org.springframework.security.acls.model</code> 包中。个人觉得这不是一个必须的元素，算不上核心概念，不应该和其他核心概念放到一起。</p></div></blockquote></div><div class="sect3"><h4 id="_创建数据库">创建数据库</h4><div class="paragraph"><p><code>JdbcAclService</code> 需要创建四张表，创建表的 SQL 已经在 jar 包里了（<strong>但是有坑</strong>），我们只是来看看这几张表分别保存了什么内容。</p></div><div class="dlist"><dl><dt class="hdlist1">acl_sid</dt><dd><div class="ulist"><ul><li><p>id: 主键</p></li><li><p>principal: 一个布尔值，表示这个 sid 是不是 <code>PrincipalSid</code>，如果值为 <code>false</code> 则表示 sid 是 <code>GrantedAuthoritySid</code></p><div class="quoteblock"><blockquote><div class="paragraph"><p>这个设计简直把扩展堵死了 🙄️</p></div></blockquote></div></li><li><p>sid: <code>Sid</code> 实例中保存的字符串，也就是 <code>Principal.getName()</code> 或 <code>GrantedAuthority.getAuthority()</code> 或自己写代码生成的字符串</p></li></ul></div></dd><dt class="hdlist1">acl_class</dt><dd><div class="ulist"><ul><li><p>id: 主键</p></li><li><p>class: Domain Object 类型的全限定名</p><div class="paragraph"><p><code>ObjectIdentity</code> 的默认实现使用 全限定名+id 的方式确定一个 Domain Object</p></div></li><li><p>class_id_type: 可选字段，保存 <code>ObjectIdentity</code> 中 <code>identifier</code> 的类型，默认是 <code>Long</code></p><div class="paragraph"><p><strong>这就是坑的所在</strong>。Jar 包中给出的 SQL 有不同的数据库的版本，只有 <code>PostgreSql</code> 和 <code>HSQL</code> 的版本中有这个字段。如果不创建这个字段，那么 <code>ObjectIdentity</code> 就只能支持 <code>Long</code> 类型的 id。<code>JdbcService</code> 默认也不会查询这个字段，需要特别配置。</p></div></li></ul></div></dd><dt class="hdlist1">acl_object_identity</dt><dd><div class="ulist"><ul><li><p>id: 主键</p></li><li><p>object_id_class: 外键依赖 <code>acl_class.id</code></p></li><li><p>object_id_identity: <code>ObjectIdentity.getIdentifer()</code> 的值，与 <code>object_id_class</code> 组成唯一键</p></li><li><p>parent_object: 外键依赖 <code>acl_object_identity.id</code>，在 <code>Acl</code> 继承时使用</p></li><li><p>owner_sid: 外键依赖 <code>acl_sid.id</code>，是 <code>Acl</code> 实例的 owner，拥有修改 <code>Acl</code> 的权限</p></li><li><p>entries_inheriting: 布尔值，表示 child acl 是否要继承 parent acl 的 ACE</p></li></ul></div></dd></dl></div><div class="paragraph"><p>这张表里保存的都是 <code>Acl</code> 持有的信息，也就是说，这张表的一行记录对应了一个 <code>Acl</code> 实例。</p></div><div class="dlist"><dl><dt class="hdlist1">acl_entry</dt><dd><div class="ulist"><ul><li><p>id: 主键</p></li><li><p>acl_object_identity: 外键依赖 <code>acl_object_identity.id</code>，表示属于哪一个 <code>Acl</code></p></li><li><p>ace_order: 表示这一条 ACE 在 <code>Acl</code> 中的顺序，和 <code>acl_object_identity</code> 组成唯一键</p></li><li><p>sid: 外键依赖 <code>acl_sid.id</code>，表示这条 ACE 的权限对应哪一个 <code>Sid</code></p></li><li><p>mask: 表示权限的 32 位二进制数字</p></li><li><p>granting: 布尔值，表示这条 ACE 是否生效</p></li><li><p>audit_success</p></li><li><p>audit_failure: 这两条是用于审计的信息，对应了 <code>AuditableAccessControlEntry</code> 接口，本文不会涉及</p></li></ul></div></dd></dl></div><div class="paragraph"><p>这张表保存的是 ACE 的信息，一行记录对应了一个 ACE 实例。</p></div></div><div class="sect3"><h4 id="_配置_jdbcaclservice">配置 JdbcAclService</h4><div class="paragraph"><p>在动手之前，我们先来看看 <code>JdbcAclService</code> 都有什么依赖：</p></div><div class="imageblock"><div class="content"><img src="jdbc-acl-service-dependencies.png" alt="jdbc acl service dependencies"></div></div><div class="paragraph"><p>因为 ACL 没有 Spring Boot 的 auto configure，所以除了 <code>DataSource</code>，我们需要自己来配置这些依赖。</p></div><div class="paragraph"><p>除非项目中不需要修改 ACL，否则都会选择创建一个 <code>JdbcMutableAclService</code> 而不是 <code>JdbcAclService</code>。</p></div><div class="sect4"><h5 id="_注入_jdbcmutableaclservice">注入 JdbcMutableAclService</h5><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-java" data-lang="java"><pre><code class="highlight java"><span class="meta">@Bean</span><span class="function"><span class="keyword">public</span> MutableAclService <span class="title">mutableAclService</span><span class="params">()</span> </span>&#123;  JdbcMutableAclService jdbcMutableAclService = <span class="keyword">new</span> JdbcMutableAclService(datasource, lookupStrategy(), aclCache());  jdbcMutableAclService.setAclClassIdSupported(<span class="keyword">true</span>); (<span class="number">1</span>)  jdbcMutableAclService.setClassIdentityQuery(<span class="string">"SELECT @@IDENTITY"</span>); (<span class="number">2</span>)  jdbcMutableAclService.setSidIdentityQuery(<span class="string">"SELECT @@IDENTITY"</span>); (<span class="number">3</span>)  <span class="keyword">return</span> jdbcMutableAclService;&#125;</code></pre></code></pre></div></div><div class="colist arabic"><ol><li><p>如果要支持 <code>acl_class.class_id_type</code> 字段，则需要将 <code>aclClassIdSupported</code> 设置为 <code>true</code>。这样 <code>JdbcAclService</code> 在查询时和 <code>JdbcMutableAclService</code> 更新时才会考虑这个字段的值。</p></li><li><p><code>classIdentityQuery</code> 会在创建 <code>Acl</code> 对象时用到，用来获取刚刚插入的 <code>acl_class.id</code>。默认值是 <code>call identity()</code>，这是 <code>H2</code> 数据库的方言，这里的例子是 <code>MySql</code> 的方言。</p></li><li><p>与 2 相同，只是用来获取刚刚插入的 <code>acl_sid.id</code></p></li></ol></div><div class="paragraph"><p>接着，我们需要配置 <code>LookupStrategy</code> 和 <code>AclCache</code>。</p></div></div><div class="sect4"><h5 id="_注入_lookupstrategy">注入 LookupStrategy</h5><div class="paragraph"><p><code>LookupStratege</code> 只有一个实现：<code>BasicLookupStrategy</code></p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-java" data-lang="java"><pre><code class="highlight java"><span class="meta">@Bean</span><span class="function"><span class="keyword">public</span> LookupStrategy <span class="title">lookupStrategy</span><span class="params">()</span> </span>&#123;  BasicLookupStrategy basicLookupStrategy = <span class="keyword">new</span> BasicLookupStrategy(datasource, aclCache(), aclAuthorizationStrategy(), permissionGrantingStrategy());  basicLookupStrategy.setAclClassIdSupported(<span class="keyword">true</span>); (<span class="number">1</span>)  <span class="keyword">return</span> basicLookupStrategy;&#125;</code></pre></code></pre></div></div><div class="colist arabic"><ol><li><p><code>BasicLookupStrategy</code> 也会自己组装 sql，需要调用这个方法以支持 <code>acl_class.class_id_type</code>。</p></li></ol></div><div class="paragraph"><p>接着，我们先来看一下 <code>AclAuthorizationStrategy</code> 和 <code>PermissionGratingStrategy</code> 这两个简单一点的依赖。</p></div></div><div class="sect4"><h5 id="_注入_aclauthorizationstrategy">注入 AclAuthorizationStrategy</h5><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-java" data-lang="java"><pre><code class="highlight java"><span class="meta">@Bean</span><span class="function"><span class="keyword">public</span> AclAuthorizationStrategy <span class="title">aclAuthorizationStrategy</span><span class="params">()</span> </span>&#123;  <span class="keyword">return</span> <span class="keyword">new</span> AclAuthorizationStrategyImpl(<span class="keyword">new</span> SimpleGrantedAuthority(<span class="string">"owner"</span>));&#125;</code></pre></code></pre></div></div><div class="paragraph"><p><code>AclAuthorizationStrategy</code> 是用来判断当前的 <code>Autentication</code> 是否有权限修改 <code>Acl</code> 的接口，它只有 <code>AclAuthorizationStrategyImpl</code> 这一个实现。这个接口规定了三种权限：</p></div><div class="ulist"><ul><li><p>change ownership 修改 Acl 的 owner</p></li><li><p>change auditing 修改 Acl 的审计信息</p></li><li><p>change general 修改 ACE</p></li></ul></div><div class="paragraph"><p>实现中有三个 <code>GrantedAuthority</code> 属性，对应了上面的三种权限，表示对 <code>Acl</code> 进行某种操作时，<code>Authentication</code> 需要满足对应的 <code>GrantedAuthority</code>。</p></div><div class="paragraph"><p>它的构造方法接受一个或三个 <code>GrantedAuthority</code>:</p></div><div class="ulist"><ul><li><p>如果只有一个参数，那么三个权限都是这个 <code>GrantedAuthority</code></p></li><li><p>如果有三个参数，那么就会按上面的顺序赋值给这三个权限</p></li></ul></div><div class="paragraph"><p>在判断权限时，如果是 <code>Acl</code> 的 owner，且不是在修改审计信息时，就可以直接获得权限；否则就需要 <code>Authentication</code> 具备对应的 <code>GrantedAuthority</code>。</p></div></div><div class="sect4"><h5 id="_注入_permissiongrantingstrategy">注入 PermissionGrantingStrategy</h5><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-java" data-lang="java"><pre><code class="highlight java"><span class="meta">@Bean</span><span class="function"><span class="keyword">public</span> PermissionGrantingStrategy <span class="title">permissionGrantingStrategy</span><span class="params">()</span> </span>&#123;  <span class="keyword">return</span> <span class="keyword">new</span> DefaultPermissionGrantingStrategy(<span class="keyword">new</span> ConsoleAuditLogger());&#125;</code></pre></code></pre></div></div><div class="paragraph"><p><code>PermissionGrantingStrategy</code> 抽象了 <code>isGranted</code> 方法，被 <code>AclImpl</code> 调用，是真正执行权限判断的地方。这个接口只有这一个实现。</p></div></div><div class="sect4"><h5 id="_注入_aclcache">注入 AclCache</h5><div class="paragraph"><p><code>AclCache</code> 有两种实现，这里为了简单，我们就使用 Spring 提供的这种实现</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-java" data-lang="java"><pre><code class="highlight java"><span class="meta">@Bean</span><span class="function"><span class="keyword">public</span> AclCache <span class="title">aclCache</span><span class="params">()</span> </span>&#123;  <span class="keyword">return</span> <span class="keyword">new</span> SpringCacheBasedAclCache(cache(), permissionGrantingStrategy(), aclAuthorizationStrategy());&#125;<span class="meta">@Bean</span><span class="function"><span class="keyword">public</span> Cache <span class="title">cache</span><span class="params">()</span> </span>&#123;  <span class="keyword">return</span> <span class="keyword">new</span> NoOpCache(<span class="string">"any"</span>);&#125;</code></pre></code></pre></div></div><div class="paragraph"><p><code>Cache</code> 是 Spring 提供的接口，有多个实现，这里为了简单，就选择了 <code>NoOpCache</code>。</p></div><div class="paragraph"><p>到这里，<code>JdbcAclService</code> 的配置就暂时告一段落了，这些配置已经足够我们在创建、更新、删除 Domain Object 之后修改 <code>Acl</code> 对象了。接下来我们就来看看如何更新 <code>Acl</code>。</p></div></div></div></div><div class="sect2"><h3 id="_创建_acl">创建 ACL</h3><div class="paragraph"><p>创建 ACL 发生在创建 Domain Object 的时候。我们可以编写代码创建 <code>Acl</code> 对象：</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-java" data-lang="java"><pre><code class="highlight java"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Class&lt;?&gt; domainClass, String id, Authentication authentication)</span> </span>&#123;  ObjectIdentity objectIdentity = <span class="keyword">new</span> ObjectIdentityImpl(domainClass, id);  PrincipalSid sid = <span class="keyword">new</span> PrincipalSid(authentication);  MutableAcl acl = findOrCreate(objectIdentity);  acl.insertAce(acl.getEntries().size(), BasePermission.ADMINISTRATION, sid, <span class="keyword">true</span>);  <span class="comment">// ... (1)</span>  mutableAclService.updateAcl(acl);&#125;<span class="function"><span class="keyword">private</span> MutableAcl <span class="title">findOrCreate</span><span class="params">(ObjectIdentity objectIdentity)</span> </span>&#123;  <span class="keyword">try</span> &#123;    <span class="keyword">return</span> (MutableAcl) mutableAclService.readAclById(objectIdentity); (<span class="number">2</span>)  &#125; <span class="keyword">catch</span> (NotFoundException e) &#123;    <span class="keyword">return</span> mutableAclService.createAcl(objectIdentity);  &#125;&#125;</code></pre></code></pre></div></div><div class="colist arabic"><ol><li><p>这里可以向 <code>Acl</code> 中插入任意需要的 ACE</p></li><li><p>这里的强制转换不会出错是因为 <code>AclImpl</code> 是 <code>Acl</code> 和 <code>MutableAcl</code> 的共有且唯一的实现</p></li></ol></div><div class="paragraph"><p>我们来梳理一下这段代码的逻辑：</p></div><div class="olist arabic"><ol class="arabic"><li><p>根据 domainClass 和 id 创建 <code>ObjectIdentity</code>，它可以用来标识一个 domain object</p></li><li><p>根据当前的 <code>Authentication</code> 创建一个 <code>PrincipalSid</code>，它后续会被用作 ACE 的 sid</p></li><li><p>根据 <code>ObjectIdentity</code> 对象查找或创建 <code>Acl</code> 对象</p><div class="paragraph"><p>创建时会使用当前的 <code>Authentication</code> 新建一个 <code>PrincipalSid</code> 对象，和这里的不是同一个对象</p></div></li><li><p>向 <code>Acl</code> 中插入 ACE</p><div class="paragraph"><p>这里可添加当前用户的 ACE，也可以添加某种 <code>GrantedAuthority</code> 的权限</p></div></li><li><p>保存 <code>Acl</code></p></li></ol></div><div class="paragraph"><p>接着我们来看一下添加 ACE 的细节，也就是 <code>Acl.insertAce()</code> 方法。</p></div><div class="sect3"><h4 id="_insertace">insertAce</h4><div class="paragraph"><p>这个方法的作用是向 <code>Acl</code> 实例的 <code>List&lt;AccessControlEntry&gt;</code> 中插入 ACE 实例。</p></div><div class="paragraph"><p>第一个参数指定了这个 ACE 在列表中的索引值。</p></div><div class="paragraph"><p>第二个参数指定这个 ACE 的权限是什么。这里我们使用了 <code>BasePermission</code> 这个实现提供的值。但无论如何，<code>Permission</code> 接口的 <code>getMask()</code> 方法一定返回的是一个 32 位的二进制数字。（类型是 int，但取值范围是 0~2<sup>32</sup>-1，这也就是所能设计的权限的个数。）</p></div><div class="paragraph"><p>第三个参数是一个 <code>Sid</code>，表示这个 <code>Sid</code> 拥有对应的权限。</p></div><div class="paragraph"><p>第四个参数是 granting，代表这条 ACE 是否生效，作用类似于 enable。</p></div><div class="paragraph"><p>调用了这个方法之后，一个新的 ACE 就被加入到 <code>Acl</code> 中了。接下来的权限判断就可以使用到这个新的 ACE。</p></div></div></div><div class="sect2"><h3 id="_更新_acl">更新 ACL</h3><div class="paragraph"><p>更新 ACL 可能更多的出现在协作软件中，比如邀请他人一起编写文档等操作。</p></div><div class="sect3"><h4 id="_添加新的_ace">添加新的 ACE</h4><div class="paragraph"><p>我们就以邀请协作作为例子，看看如何添加 ACE：</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-java" data-lang="java"><pre><code class="highlight java"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onInvite</span><span class="params">(Class&lt;?&gt; domainClass, String id, String invitedUserPrincipalName)</span> </span>&#123;  ObjectIdentity objectIdentity = <span class="keyword">new</span> ObjectIdentityImpl(domainClass, id);  PrincipalSid sid = <span class="keyword">new</span> PrincipalSid(invitedUserPrincipalName); (<span class="number">1</span>)  MutableAcl acl = findAcl(objectIdentity);  acl.insertAce(acl.getEntries().size(), BasePermission.WRITE, sid, <span class="keyword">true</span>);  mutableAclService.updateAcl(acl);&#125;<span class="function"><span class="keyword">private</span> MutableAcl <span class="title">findAcl</span><span class="params">(ObjectIdentity objectIdentity)</span> </span>&#123;  <span class="keyword">return</span> (MutableAcl) mutableAclService.readAclById(objectIdentity);&#125;</code></pre></code></pre></div></div><div class="colist arabic"><ol><li><p><code>PrincipalSid</code> 其实保存的是 <code>Authentication.getName()</code> 的返回值，本质上就是 principal name，所以可以直接使用一个字符串作为 principal name。</p></li></ol></div><div class="paragraph"><p>这里，我们给了一个具体的被邀请者一个 WRITE 权限。我们甚至可以给一组用户权限，只需要提供不同的 <code>Sid</code>。</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-java" data-lang="java"><pre><code class="highlight java">GrantedAuthoritySid sid = <span class="keyword">new</span> GrantedAuthoritySid(<span class="string">"teamA"</span>);</code></pre></code></pre></div></div></div><div class="sect3"><h4 id="_更新已有的_ace">更新已有的 ACE</h4><div class="paragraph"><p>还是前面的例子，假设某个协作者完成了自己的工作，不想误操作导致修改，希望将权限修改为只读。那么这个时候就会使用到 <code>MutableAcl.updateAce()</code> 方法。</p></div><div class="paragraph"><p>这个方法只有两个参数，第一个是要修改的 ACE 的索引，第二个是需要修改成的权限，那么我们的代码可能写出来是这个样子：</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-java" data-lang="java"><pre><code class="highlight java">List&lt;AccessControlEntry&gt; aces = acl.getEntries();aces.stream()  .filter(ace -&gt; ace.getSid().equals(sid))  .mapToInt(aces::indexOf)  .forEach(idx -&gt; acl.updateAce(idx, permission));</code></pre></code></pre></div></div><div class="paragraph"><p>这样我们就能将任何匹配到 <code>Sid</code> 的 ACE 的权限修改为指定的 <code>Permission</code>。</p></div></div><div class="sect3"><h4 id="_删除已有的_ace">删除已有的 ACE</h4><div class="paragraph"><p>还是前面的例子，假设我们协作完成了，需要关闭其他人的权限，那么我们就需要删除对应的 ACE。</p></div><div class="quoteblock"><blockquote><div class="paragraph"><p>个人更倾向于软删除，也就是将 ACE 的 <code>granting</code> 字段设置为 <code>false</code>。但是 Spring ACL 在模型设计上没有提供修改的方法，具体实现上，这个字段也被标记为 <code>final</code>。</p></div></blockquote></div><div class="paragraph"><p>删除 ACE 同样需要它的索引：</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-java" data-lang="java"><pre><code class="highlight java">List&lt;AccessControlEntry&gt; aces = acl.getEntries();aces.stream()  .filter(ace -&gt; ace.getSid().equals(sid))  .mapToInt(aces::indexOf)  .forEach(acl::deleteAce);</code></pre></code></pre></div></div></div></div><div class="sect2"><h3 id="_删除_acl">删除 ACL</h3><div class="paragraph"><p>一个 ACL 关联到一个 domain object，当一个 domain object 被删除时，ACL 也应该被删除。</p></div><div class="paragraph"><p><code>MutaleAclService</code> 也定义了 <code>deleteAcl</code> 方法用来删除 ACL，它被 <code>JdbcMutableAclService</code> 实现。</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-java" data-lang="java"><pre><code class="highlight java">mutableAclService.deleteAcl(acl, <span class="keyword">true</span>);</code></pre></code></pre></div></div><div class="paragraph"><p>其中的第二个参数表示是否要删除子 Acl。（因为 ACL 可以继承）</p></div><div class="quoteblock"><blockquote><div class="paragraph"><p>在具体的实现中，默认的 sql 会删除整个 ACL。所以如果想要实现软删除，那么不仅需要调用对应的 setter 方法来修改对应的 sql，还需要修改表结构来支持软删除。</p></div></blockquote></div></div></div></div><div class="sect1"><h2 id="_使用_acl_保护业务调用">使用 ACL 保护业务调用</h2><div class="sectionbody"><div class="paragraph"><p>现在我们知道了如何操作 ACL，那么接下来看看如果使用 ACL 来判断请求是否有权限调用业务方法。</p></div><div class="paragraph"><p>在<a href="/2020/07/02/spring-security-acl-conception-and-component/#_acl_验证逻辑的入口">上一篇文章</a>中，我们介绍过 Spring ACL 提供的三种使用 ACL 的机制，接下来我们以 expression based access control 作为例子，看看如何使用 ACL 保护业务方法。</p></div><div class="paragraph"><p>在这个例子中，我们使用 <code>PostAuthorize</code> 来保护业务方法：</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-java" data-lang="java"><pre><code class="highlight java"><span class="meta">@PostAuthorize</span>(<span class="string">"hasPermission(returnObject, 'READ')"</span>)<span class="function"><span class="keyword">public</span> DomainObject <span class="title">find</span><span class="params">(String id)</span> </span>&#123;  <span class="comment">//...</span>  <span class="keyword">return</span> domainObject;&#125;</code></pre></code></pre></div></div><div class="paragraph"><p>这个例子中，业务方法返回的 domainObject 会被作为表达式中的 returnObject 传递给 <code>hasPermission</code> 方法，验证当前用户是否有指定的 READ 权限。</p></div><div class="paragraph"><p>这里的 <code>hasPermission</code> 方法会调用到 <code>SecurityExpressionRoot</code>，最终到达 <code>AclPermissionEvaluator.hasPermission()</code> 方法。</p></div><div class="paragraph"><p>在这个方法中，returnObject 会被交给 <code>ObjectIdnetityRetrievalStrategy</code> 接口，得到 <code>ObjectIdentity</code>，用来查找对应的 <code>Acl</code> 实例。</p></div><div class="quoteblock"><blockquote><div class="paragraph"><p>具体实现上，其实是通过反射得到 className 和 <code>getId()</code> 方法，然后调用这个方法得到 identity。所以这里的 returnObject 一定要有 <code>getId()</code> 方法。</p></div></blockquote></div><div class="paragraph"><p>我们传递的 <code>'READ'</code> 参数，就是 permission，但这里被当作了 <code>Object</code>。<code>AclPermissionEvaluator</code> 通过自己实现的 <code>resolvePermission()</code> 方法来处理不同类型的参数。我们的 <code>'READ'</code> 会被当做字符串处理，交给 <code>PermissionFactory</code> 的默认实现处理。默认实现中提供了两个 <code>Map</code>，分别保存了 <code>permission name &#8594; BasePermission</code> 和 <code>mask int &#8594; BasePermission</code> 的映射关系。我们的 <code>'READ'</code> 也就这样被映射到了 <code>BasePermission.READ</code>。</p></div><div class="sect2"><h3 id="_启用_method_security">启用 Method Security</h3><div class="paragraph"><p>解释完了上面的方法，接下来就是要让这个表达式生效了。</p></div><div class="paragraph"><p>Spring Security 默认没用启用 Method Security，而 <code>PostAuthorize</code> 则需要这个支持。</p></div><div class="paragraph"><p>要启用这个功能很简单，我们只需要：</p></div><div class="olist arabic"><ol class="arabic"><li><p>enable pre/post security</p></li><li><p>创建 <code>AclPermissionEvaluator</code></p></li><li><p>创建 <code>MethodSecurityExpressionHanler</code>，并将 <code>AclPermissionEvaluator</code> 设置为它的 <code>PermissionEvaluator</code></p></li></ol></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-java" data-lang="java"><pre><code class="highlight java"><span class="meta">@Configuration</span><span class="meta">@EnableGlobalMethodSecurity</span>(prePostEnabled = <span class="keyword">true</span>)<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodSecurityConfig</span> </span>&#123;  <span class="meta">@Autowired</span> <span class="keyword">private</span> AclService aclService;  <span class="meta">@Bean</span>  <span class="function"><span class="keyword">public</span> MethodSecurityExpressionHandler <span class="title">methodSecurityExpressionHandler</span><span class="params">()</span> </span>&#123;    MethodSecurityExpressionHandler handler = <span class="keyword">new</span> DefaultMethodSecurityExpressionHandler();    handler.setPermissionEvaluator(<span class="keyword">new</span> AclPermissionEvaluator(aclService)); (<span class="number">1</span>)    <span class="keyword">return</span> handler;  &#125;&#125;</code></pre></code></pre></div></div><div class="colist arabic"><ol><li><p>我们可以给它提供一个 <code>AclSerivce</code> 而不是 <code>MutableAclService</code>，因为它不会修改 ACL</p></li></ol></div><div class="paragraph"><p>这样我们的表达式就能生效了，当一个没有 READ 权限的用户尝试访问 domain object 的时候，就会得到一个 403 响应。</p></div><div class="quoteblock"><blockquote><div class="paragraph"><p>这里就不再讲使用 <code>AclEntryVoter</code> 和 after invocation 的例子了，无论使用哪种方式，都需要自己进行相应的配置。读者如果感兴趣可以自己研究研究。</p></div></blockquote></div></div></div></div><div class="sect1"><h2 id="_总结">总结</h2><div class="sectionbody"><div class="paragraph"><p>这篇文章从代码的角度简单研究了如何使用 ACL。</p></div><div class="paragraph"><p>相信你也看出来了，没有 Spring Boot auto configure 的支持，使用 ACL 需要些大量的配置代码。这还不止。在研究源码时，发现 ACL 的实现其实比较简单，覆盖的场景看起来特别单一。如果实际项目想要使用，应该需要花一些工作来提供项目和适配的实现。</p></div><div class="quoteblock"><blockquote><div class="paragraph"><p>举个例子，<code>AclEntryVoter</code> 的实现中，要求 <code>MethodInvocation</code> 的餐宿中一定要有 domain object，这一点可能就和一些项目的实践相违背。</p></div></blockquote></div><div class="paragraph"><p>尽管如此，我仍然认为 ACL 是一种不错的设计，很好的分离了业务和访问控制的关注点，抽象的接口也可以方便的进行扩展，值得去试一试。</p></div><div class="quoteblock"><blockquote><div class="paragraph"><p>查看系列文章： <a href="/spring-security-servlet/">点这里</a></p></div></blockquote></div></div></div>]]></content:encoded>
      
      <comments>https://blog.gaoyuexiang.cn/2020/07/18/how-to-use-spring-security-acl/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Spring Security ACL 核心概念和组件</title>
      <link>https://blog.gaoyuexiang.cn/2020/07/02/spring-security-acl-conception-and-component/</link>
      <guid>https://blog.gaoyuexiang.cn/2020/07/02/spring-security-acl-conception-and-component/</guid>
      <pubDate>Thu, 02 Jul 2020 01:21:40 GMT</pubDate>
      <description>
      
        介绍 Spring Security ACL 中核心的概念和组件
      
      </description>
      
      
      <content:encoded><![CDATA[<div class="paragraph"><p>Spring Security 提供了一个 ACL 模块，也就是 Access Control List，用来做访问控制。目的是解决 <em><strong>谁</strong>对<strong>什么资源</strong>有<strong>什么权限</strong></em> 的问题。这里的重点是具体的资源。</p></div><div class="sect1"><h2 id="_面临的问题">面临的问题</h2><div class="sectionbody"><div class="paragraph"><p>我们通过 Spring Security 的 <code>WebSecurityConfigurerAdapter.configure(HttpSecurity)</code> 方法，对 <code>HttpSecurity</code> 对象进行配置，只能精确到 API 层面，决定拥有哪些权限的用户可以访问哪些 API，但是对于哪些用户对一个具体的资源有访问权限却无能为力。</p></div><div class="paragraph"><p>举个🌰，对于一个多用户的博客系统，可能存在一个 API <code>/my/drafts</code> ，可以查看当前用户的草稿，但是不能查看其他用户的草稿。那么上面的 <code>HttpSecurity</code> 就无法完成这个需求。</p></div><div class="paragraph"><p>为了解决这个问题，我们可能会有很多解决方法：</p></div><div class="ulist"><ul><li><p>实现一个 <code>AccessDecisionVoter</code>，访问数据库中的 <code>Blog</code> 记录，然后判断当前的用户是否有权限访问</p></li><li><p>实现一个 <code>AccessDecisionVoter</code>，通过 <code>Authentication</code> 对象中的 <code>GrantedAuthority[]</code> 判断是否有权限访问</p></li><li><p>抛弃 Spring Security，自己实现一套权限控制机制</p></li><li><p>将访问控制的代码和业务代码组织到一起</p></li></ul></div><div class="paragraph"><p>这些方法也不是不能用，但都有各自的缺陷（Spring Security ACL 也有，只是比这些要好一点）：</p></div><div class="ulist"><ul><li><p>第一个方案意味着在 <code>AccessDecisionVoter</code> 中会进行数据库访问，这会造成性能上的隐患</p></li><li><p>第二个方案在数据量上升后可能会面临 <code>Authentication</code> 对象无比巨大的问题</p></li><li><p>第三个方案就像自己创造一个加密算法一样，看起来厉害，但可能会有很多漏洞，毕竟没有经过实践检验</p></li><li><p>第四个方案是最轻量的，但是很容易破坏代码的单一职责原则，最后变成没人愿意维护的代码</p></li></ul></div></div></div><div class="sect1"><h2 id="_acl_核心概念">ACL 核心概念</h2><div class="sectionbody"><div class="paragraph"><p>针对上面的缺点，Spring Security ACL 则是采用了面向 Domain Object 的方式，抽象出了 Domain Object 这个概念，把 ACL 与业务代码解耦。</p></div><div class="paragraph"><p>我们可以先来看一下 ACL 中的核心概念：</p></div><div class="imageblock"><div class="content"><img src="acl-cmap.png" alt="acl cmap"></div></div><div class="paragraph"><p>除了 Domain Object 和 Security Object，其他概念都是 ACL 中的接口。这些接口都在 <code>org.springframework.security.acls.model</code> package 中。</p></div><div class="sect2"><h3 id="_domain_object">Domain Object</h3><div class="paragraph"><p>Domain Object 是对业务类实例的抽象，用 <code>DDD</code> 的话说，就是对领域模型实例的抽象。一个 Domain Object 对应的是一个实例。它可能是一篇博客，也可能是一条评论。</p></div><div class="paragraph"><p>一个 Domain Object 被一个 <code>ObjectIdentity</code> 唯一标识。</p></div><div class="paragraph"><p>因为有了这个抽象，我们就可以将 ACL 的代码和业务逻辑解耦，仅仅通过 <code>ObjectIdentity</code> 来标识 <code>Acl</code> 和 Domain Object 的关联关系。</p></div></div><div class="sect2"><h3 id="_security_object">Security Object</h3><div class="paragraph"><p>Security Object 是对用户和角色的抽象。代表了一个用户，或一种角色，或一个权限组等。往往是 <code>Principal</code> 和 <code>GrantedAuthority</code> 的抽象。</p></div></div><div class="sect2"><h3 id="_acl">Acl</h3><div class="paragraph"><p><code>Acl</code> 类是 ACL 中的核心，也就是 Access Control List 的简称。</p></div><div class="paragraph"><p>一个 <code>Acl</code> 实例拥有一个 <code>ObjectIdentity</code>，标识了一个 Domain Object。</p></div><div class="paragraph"><p>一个 <code>Acl</code> 实例拥有一组 <code>AccessControlEntity</code>，顾名思义，它们就是这个访问控制列表中的每一个访问控制项。</p></div><div class="paragraph"><p>一个 <code>Acl</code> 实例持有一个 <code>Sid</code> 对象，标识了这个 <code>Acl</code> 的 owner；owner 对这个 <code>Acl</code> 有完全的控制权。所谓完全的控制权，也就是指可以修改、删除其中的信息，甚至 <code>Acl</code> 本身。</p></div><div class="sect3"><h4 id="_mutableacl">MutableAcl</h4><div class="paragraph"><p><code>MutableAcl</code> 是对 <code>Acl</code> 的扩展，提供了一些修改 <code>Acl</code> 的方法。</p></div><div class="paragraph"><p>考虑到 <code>Acl</code> 可能更多的被使用到一些不会修改访问权限的调用中，所以它只提供了一些只读方法。但有一些可能不太频繁的<strong>会修改访问权限</strong>的操作，比如创建、删除等，所以需要一些方法能够修改 <code>Acl</code> 实例。所以扩展出了 <code>MutableAcl</code> 类，用来进行修改访问权限的操作。</p></div></div></div><div class="sect2"><h3 id="_objectidentity">ObjectIdentity</h3><div class="paragraph"><p>前面已经提到过 <code>ObjectIdentity</code> 的作用，是用来标识 Domain Object，就是一个脱离业务上下文后仍然唯一的 id。实际上是 ACL 上下文中对 Domain Object 的抽象</p></div><div class="paragraph"><p>能够做到这一点，是因为提供了两个方法：<code>getType</code> 和 <code>getIdentifier</code>。</p></div><div class="paragraph"><p><code>type</code> 用来标识 Domain Object 的类型，<code>identifier</code> 则是在 <code>type</code> 上下文中唯一的。不同的 <code>type</code> 下，可以出现相同的 <code>identifier</code>，但 <code>type</code> 却需要全局唯一。</p></div><div class="paragraph"><p>默认实现是使用 Domain Object 的 java 类全限定名作为 <code>type</code>。</p></div><div class="paragraph"><p><code>identifier</code> 则需要使用者自己实现。要求是能根据 Domain Object 找到这个 <code>identifier</code>，否则 <code>Acl</code> 和 Domain Object 就会失去联系。使用 Domain Object 的系统 id 会是一个不错的选择。</p></div></div><div class="sect2"><h3 id="_sid">Sid</h3><div class="paragraph"><p><code>Sid</code> 是 Security Identity 的简称，是在 ACL 上下文中对 Security Object 的抽象。就像 <code>ObjectIdentity</code> 对 Domain Object 的抽象一样。</p></div><div class="quoteblock"><blockquote><div class="paragraph"><p>为什么不能统一一下规范，叫 <code>SecurityIdentity</code> 呢 🙄️</p></div></blockquote></div><div class="paragraph"><p>在实现上，有 <code>PrincipalSid</code> 和 <code>GrantedAuthoritySid</code>。前者是对用户的抽象，后者是对角色、权限的抽象。</p></div></div><div class="sect2"><h3 id="_accesscontrolentry">AccessControlEntry</h3><div class="paragraph"><p><code>AccessControlEntry</code> 简称 ACE，组成了访问控制列表。每一个 ACE 标识了一个 <code>Sid</code> 的权限，权限由 <code>Permission</code> 表示。</p></div><div class="paragraph"><p>🌰：</p></div><div class="dlist"><dl><dt class="hdlist1">如果一种角色对 Domain Object 有可读权限</dt><dd><div class="ulist"><ul><li><p><code>Sid</code> 会是表示这个角色的 <code>GrantedAuthoritySid</code></p></li><li><p><code>Permission</code> 会表示 READ 权限</p></li></ul></div></dd><dt class="hdlist1">如果一个用户对 Domain Object 有可读、可写、可邀请协作的权限</dt><dd><div class="ulist"><ul><li><p>会有多个 ACE</p></li><li><p>每个 ACE 的 <code>Sid</code> 都是指向这个用户的 <code>PrincipalSid</code></p></li><li><p>每个 ACE 的 <code>Permission</code> 会不同，分别表示可读、可写、可邀请协作</p></li></ul></div></dd></dl></div></div><div class="sect2"><h3 id="_permission">Permission</h3><div class="paragraph"><p><code>Permission</code> 接口可能收到了 <code>Linux</code> 文件权限的启发，要求使用 32 位二进制数字来表示权限。</p></div><div class="paragraph"><p>所以我们可以针对一个 Domain Object 设计出 2<sup>32</sup>-1 种权限，应该足够使用了。</p></div></div><div class="sect2"><h3 id="_小结">小结</h3><div class="paragraph"><p>ACL 的核心就是 <code>Acl</code> 类，它将 Domain Object 和 对应的 Security Object 以及权限关联了起来。其中，将 Security Object 和权限关联起来的类是 <code>AccessControlEntry</code>。</p></div></div></div></div><div class="sect1"><h2 id="_acl_权限验证逻辑">ACL 权限验证逻辑</h2><div class="sectionbody"><div class="paragraph"><p>通过了解核心概念，我们知道了 ACL 的核心就是 <code>Acl</code> 类，那么进行权限验证的逻辑也就很明显了：</p></div><div class="olist arabic"><ol class="arabic"><li><p>根据要访问的对象，得到 <code>ObjectIdentity</code> 实例</p></li><li><p>从 <code>Authentication</code> 中获取 <code>Sid</code></p></li><li><p>根据 <code>ObjectIdentity</code> 找到对应的 <code>Acl</code></p></li><li><p>判断 ACE 中是否有进行访问需要的 <code>Permission</code></p></li></ol></div><div class="paragraph"><p>当上面的这个逻辑验证通过时，才会被允许访问 Domain Object，否则就会出现 <code>AccessDeniedException</code>。</p></div><div class="sect2"><h3 id="_获取_objectidentity_对象">获取 ObjectIdentity 对象</h3><div class="paragraph"><p>我们先来看看第一步，获取 <code>ObjectIdentity</code> 对象。</p></div><div class="paragraph"><p>前面介绍 <code>ObjectIdentity</code> 的时候推荐过使用 Domain Object 的 class 和系统 id 来作为 <code>ObjectIdentity</code>。这样的好处就是我们可以根据 Domain Object 实例创建出 <code>ObjectIdentity</code> 来。</p></div><div class="paragraph"><p>这个逻辑被抽象成了接口 <code>ObjectIdentityRetrievalStrategy</code>。它只提供了一个 <code>getObjectIdentity</code> 方法：<code>Object &#8594; ObjectIdentity</code>。</p></div></div><div class="sect2"><h3 id="_获取_sid_对象">获取 Sid 对象</h3><div class="paragraph"><p>因为 <code>Sid</code> 代表的是用户和角色，而这些信息被保存在 <code>Authentication</code> 对象的 <code>Principal</code> 和 <code>GrantedAuthority[]</code> 中，所以我们可以通过 <code>Authentication</code> 对象来获取 <code>Sid</code>。</p></div><div class="paragraph"><p>这个逻辑同样被抽象成了接口 <code>SidRetrivalStrategy</code>。它只提供了一个 <code>getSids</code> 方法：<code>Authentication &#8594; List&lt;Sid&gt;</code></p></div></div><div class="sect2"><h3 id="_获取_acl_对象">获取 Acl 对象</h3><div class="paragraph"><p>ACL 提供了一个接口 <code>AclService</code> 用来获取 <code>Acl</code> 对象。接口提供了多种方法，其中被这个逻辑使用到的是 <code>readAclById(ObjectIdentity, List&lt;Sid&gt;)</code>。</p></div><div class="quoteblock"><blockquote><div class="paragraph"><p>其实不提供 <code>List&lt;Sid&gt;</code> 也能查到对应的 <code>Acl</code>，但其中就会包含当前逻辑中不需要使用到的 ACE。</p></div></blockquote></div></div><div class="sect2"><h3 id="_判断权限">判断权限</h3><div class="paragraph"><p><code>Acl</code> 提供了 <code>isGranted</code> 方法用来判断当前的 <code>List&lt;Sid&gt;</code> 是否有需要的权限。</p></div><div class="paragraph"><p>在默认实现 <code>AclImpl</code> 中，判断的逻辑交给了接口 <code>PermissionGrantingStrategy</code>，这样我们可以通过实现策略而不是 <code>Acl</code> 来达到重写验证逻辑的目的。</p></div></div></div></div><div class="sect1"><h2 id="_acl_验证逻辑的入口">ACL 验证逻辑的入口</h2><div class="sectionbody"><div class="paragraph"><p>前面描述的验证逻辑，被实现在了不同的类中。这些类是具体的 security 机制相关的类，每一个类都是针对具体 security 机制的 ACL 验证逻辑的实现。</p></div><div class="sect2"><h3 id="_针对_pre_invocation">针对 pre invocation</h3><div class="paragraph"><p>在<a href="/2020/05/31/spring-security-servlet-overview/#_accessdecisionvoter">前面的文章</a>中，我们了解过 <code>AccessDecisionVoter</code> 是在实际调用发生前进行权限验证的接口。</p></div><div class="paragraph"><p>ACL 中提供了实现 <code>AclEntryVoter</code> 来实现验证逻辑。</p></div></div><div class="sect2"><h3 id="_针对_post_invocation">针对 post invocation</h3><div class="paragraph"><p>在<a href="/2020/06/13/spring-security-authorization/#_afterinvocationmanager">前面的另一篇文章</a>中，我们了解过 <code>AfterInvocationProvider</code> 是在实际调用发生后进行权限验证的接口。</p></div><div class="paragraph"><p>ACL 中提供了 <code>AbstractAclProvider</code> 来实现验证逻辑。它的两个子类则是针对不同的使用场景，分别实现权限验证和 collection filter 的逻辑。</p></div></div><div class="sect2"><h3 id="_针对_expression_based_access_control">针对 expression based access control</h3><div class="paragraph"><p>对于使用表达式的地方，比如 <code>@PostAuthority("hasPermission(returnObject, 'READ')")</code>，ACL 提供了 <code>AclPermissionEvaluator</code> 实现验证逻辑。</p></div><div class="quoteblock"><blockquote><div class="paragraph"><p>这个类实现了 <code>PermissionEvaluator</code> 接口。这是 Spring Security 中 <code>hasPermission</code> 表达式的解析接口。</p></div></blockquote></div><hr><div class="paragraph"><p>了解完了这三个入口，我们就知道当需要在某个 security 机制中使用 ACL 时，需要创建出哪一个组件注入到 Spring 容器中。</p></div></div></div></div><div class="sect1"><h2 id="_更新_acl">更新 Acl</h2><div class="sectionbody"><div class="paragraph"><p>前面的验证逻辑是使用场景更多的逻辑，也是对 <code>Acl</code> 进行只读操作的逻辑。更新 <code>Acl</code> 并不是一个频繁的操作，但却是一个必要的操作。遗憾的是，Spring Security ACL 没有为我们默认实现更新 <code>Acl</code> 的逻辑，我们需要自己实现。</p></div><div class="paragraph"><p>好在为了支持更新操作，Spring Security ACL 给我们提供了 <code>MutableAcl</code> 和 <code>MutableAclService</code> 这两个接口，提供了更新 <code>Acl</code> 的方法。</p></div><div class="paragraph"><p>以创建 <code>Acl</code> 为例，我们来看看应该写出什么样的代码。（创建 <code>Acl</code> 的场景一般是创建了新的资源时）</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-java" data-lang="java"><pre><code class="highlight java"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createAcl</span><span class="params">(Object domainObject)</span> </span>&#123;  ObjectIdentity oid = <span class="keyword">new</span> ObjectIdentityImpl(domainObject);  Sid sid = <span class="keyword">new</span> PrincipalSid(SecurityContextHolder.getSecurityContext().getAuthentication());  Permission p = BasePermission.ADMINISTRATION;  MutableAcl acl = aclService.createAcl(oid);  acl.insertAce(acl.getEntries().size(), p, sid, <span class="keyword">true</span>);  aclService.updateAcl(acl);&#125;</code></pre></code></pre></div></div><div class="paragraph"><p>对于更新 ACE、删除 <code>Acl</code> 等操作，<code>MutableAcl</code> 和 <code>MutableAclService</code> 都有相应的方法，只是和创建一样，都需要我们自己写代码调用。这些代码应该和业务代码分隔开，这样才能满足 ACL 的初衷，避免写出难以维护的代码。</p></div></div></div><div class="sect1"><h2 id="_总结">总结</h2><div class="sectionbody"><div class="paragraph"><p>本文介绍了 Spring Security ACL 中的核心概念和它们之间的关系，那张概念图就是最好的总结。</p></div><div class="paragraph"><p>另外还介绍了使用 ACL 进行权限控制的逻辑和相关的组件，也就是那些 strategy 和 service 接口。</p></div><div class="paragraph"><p>最后简单介绍了更新 <code>Acl</code> 的方法，更详细的内容会在另外的博客里以 demo 的形式呈现。</p></div><div class="quoteblock"><blockquote><div class="paragraph"><p>查看系列文章： <a href="/spring-security-servlet/">点这里</a></p></div></blockquote></div></div></div>]]></content:encoded>
      
      <comments>https://blog.gaoyuexiang.cn/2020/07/02/spring-security-acl-conception-and-component/#disqus_thread</comments>
    </item>
    
    <item>
      <title>你的 docker stop，它优雅吗？</title>
      <link>https://blog.gaoyuexiang.cn/2020/06/18/graceful-shutdown-docker-container/</link>
      <guid>https://blog.gaoyuexiang.cn/2020/06/18/graceful-shutdown-docker-container/</guid>
      <pubDate>Thu, 18 Jun 2020 22:46:13 GMT</pubDate>
      <description>
      
        如何优雅的关闭 Docker container
      
      </description>
      
      
      <content:encoded><![CDATA[<div class="paragraph"><p>我们平时在使用 <code>Docker</code> 的时候，一般会使用 <code>ctrl+c</code> 或者 <code>docker stop</code> 的方式关闭容器。但有时候我们可能会遇到 <code>ctrl+c</code> 不生效，或者 <code>docker stop</code> 之后要等待 10s 的情况，就像这样：</p></div><div class="imageblock"><div class="content"><img src="docker-stop-10s.png" alt="docker stop 10s"></div></div><div class="paragraph"><p>也许你会觉得 10s 是一个可以忍受的时间，但这样的问题真的只有 10s 这么简单吗？为什么有的时候不能立即关闭容器呢？</p></div><div class="sect1"><h2 id="_docker_stop_怎么关闭容器">docker stop 怎么关闭容器</h2><div class="sectionbody"><div class="paragraph"><p>首先我们来看一下这两个命令做了什么。</p></div><div class="sect2"><h3 id="_ctrlc_到底做了什么"><code>ctrl+c</code> 到底做了什么</h3><div class="paragraph"><p>我们能够使用 <code>ctrl+c</code> 的场景，是我们在使用 <code>foreground</code> 模式运行容器的时候。这时我们按下 <code>ctrl+c</code> 就像在普通的 <code>shell</code> 中按下这个组合键一样，发送一个 <code>SIGINT</code> 信号给当前的进程，通知它终止运行。</p></div></div><div class="sect2"><h3 id="_docker_stop_做了什么">docker stop 做了什么</h3><div class="paragraph"><p><code>docker stop</code> 命令是在对 <code>detached</code> 模式运行的容器发出停止命令时使用的，从发送信号上来讲，它将发送 <code>SIGTERM</code> 信号给容器，通知其结束运行。</p></div><div class="quoteblock"><blockquote><div class="paragraph"><p><code>SIGINT</code> 一般用于关闭前台进程，<code>SIGTERM</code> 会要求进程自己正常退出。</p></div></blockquote></div><div class="paragraph"><p>当我们在 <code>shell</code> 中给进程发送 <code>SIGTERM</code> 和 <code>SIGINT</code> 信号的时候，这些进程往往都能正确的处理。但是在 <code>docker</code> 中却不灵了。这是因为在 <code>docker</code> 中，只会将 <code>SIGTERM</code> 等所有的 <code>signal</code> 信号发送给 PID 为 1 的进程，当我们 <code>docker</code> 中运行的进程的进程号不是 1 时，就不会收到这样的信号。</p></div><div class="quoteblock"><blockquote><div class="paragraph"><p>根据<a href="https://mp.weixin.qq.com/s/vaIBGHmdUT0bHP2O722AQQ" target="_blank" rel="noopener">这篇文章</a>的说法，只有 <code>alpine</code> 会出现这个问题，但从我搜到的资料和实验来看，并不是这样，而是所有的镜像都会有这个问题。</p></div></blockquote></div></div><div class="sect2"><h3 id="_为什么是_10s">为什么是 10s</h3><div class="paragraph"><p>其实这只是 <code>docker</code> 的默认设置，如果你愿意，等十年都可以。文档链接：<a href="https://docs.docker.com/engine/reference/commandline/stop/" target="_blank" rel="noopener" class="bare">https://docs.docker.com/engine/reference/commandline/stop/</a></p></div><div class="paragraph"><p>如果达到上面的时间限制，<code>docker</code> 将会通过给内核发送 <code>SIGKILL</code> 从而强制结束容器。</p></div></div><div class="sect2"><h3 id="_验证上面的回答">验证上面的回答</h3><div class="paragraph"><p>为了验证上面查到的这些结果，我写了一点 demo。在 demo 的场景里，我们会在 <code>ENTRYPOINT</code> 配置运行一个 <code>shell</code> 脚本，在脚本中做一些准备工作后启动进程。</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-Dockerfile" data-lang="Dockerfile"><pre><code class="highlight Dockerfile"><span class="keyword">FROM</span> openjdk:<span class="number">8</span>-jre-alpine<span class="keyword">COPY</span><span class="bash"> ./build/libs/app.jar /app/app.jar</span><span class="keyword">COPY</span><span class="bash"> ./docker/entrypoint.sh /app/entrypoint.sh</span><span class="keyword">WORKDIR</span><span class="bash"> /app</span><span class="keyword">EXPOSE</span> <span class="number">8080</span><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"./entrypoint.sh"</span>]</span></code></pre></code></pre></div></div><div class="listingblock"><div class="title">entrypoint.sh</div><div class="content"><pre class="highlight"><code class="language-bash" data-lang="bash"><pre><code class="highlight bash"><span class="meta">#!/bin/sh</span><span class="built_in">echo</span> <span class="string">'Do something'</span>java -jar app.jar</code></pre></code></pre></div></div><div class="quoteblock"><blockquote><div class="paragraph"><p>后面还会用到这个例子</p></div></blockquote></div><div class="paragraph"><p>我们可以观察一下 <code>docker stop</code> 之后，<code>shell</code> 给我们的返回值</p></div><div class="imageblock"><div class="content"><img src="docker-stop-10s-kill.png" alt="docker stop 10s kill"></div><div class="title">Figure 1. 注意红色方框</div></div><div class="paragraph"><p>根据这张图，我们可以看到:</p></div><div class="olist arabic"><ol class="arabic"><li><p><code>docker stop</code> 命令等待了 10s 才结束</p></li><li><p>结束的 docker container 返回了 <code>137</code>，表示进程是因为内核接收到了 <code>SIGKILL</code> 而结束的（<code>zsh</code> 给美化成了 KILL）</p></li></ol></div></div><div class="sect2"><h3 id="_kill_导致的问题">Kill 导致的问题</h3><div class="paragraph"><p>现在我们已经了解了 <code>ctrl+c</code> 为什么不生效和 <code>docker stop</code> 等待 10s 的原因了。我们再来看看另一个问题：<strong>强制关闭容器，真的就没问题吗？</strong></p></div><div class="paragraph"><p>或许你能想到，很多进程在结束阶段会做一些清理工作：比如删除临时目录、执行 shutdown hook 等。但是当进程被强制关闭时，这些任务就不会被执行，那么我们就可能得到一些并不期望的结果。</p></div><div class="paragraph"><p>以 <code>Eureka</code> 为例。<code>Eureka client</code> 在结束进程时，需要向 <code>Eureka server</code> 发送 shutdown 信号，以注销 <code>client</code>。这本来没什么问题，因为 <code>Eureka server</code> 即使没有收到这样的信息，也会定期清理 <code>client</code> 信息。但是 <code>Eureka server</code> 还有一个 <code>self preservation</code> 模式，以防止意外的网络事件导致大量的 <code>client</code> 下线。这就有可能导致 <code>Eureka</code> 集群的注册表中出现大量的 <code>client</code> 信息，但它们其实已经关闭了。</p></div></div></div></div><div class="sect1"><h2 id="_如何优雅的关闭容器">如何优雅的关闭容器</h2><div class="sectionbody"><div class="paragraph"><p>通过前面的内容，我们已经了解了容器没有被优雅关闭的原因和可能导致的问题，接下来，我们来看看如何解决。</p></div><div class="quoteblock"><blockquote><div class="paragraph"><p>前面提到的那篇文章中提到可以使用 <code>tini</code> 来解决，但我没有成功过。<code>tini</code> 的确做到了立即关闭进程，但是进程并没有执行 shutdown hook。</p></div></blockquote></div><div class="sect2"><h3 id="_使目标进程成为_pid_1">使目标进程成为 PID 1</h3><div class="paragraph"><p>既然 <code>docker</code> 只会将 <code>sigal</code> 发送给 PID 1 的进程，那就让我们的进程成为 PID 1 的进程就好了。</p></div><div class="sect3"><h4 id="_docker_的_exec_与_shell_模式">docker 的 exec 与 shell 模式</h4><div class="paragraph"><p><code>Dockerfile</code> 的 <code>ENTRYPOINT</code> 有两种写法，即 <code>exec</code> 和 <code>shell</code>：</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-Dockerfile" data-lang="Dockerfile"><pre><code class="highlight Dockerfile"><span class="comment"># exec form</span><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"command"</span>, <span class="string">"param"</span>]</span><span class="comment"># shell form</span><span class="keyword">ENTRYPOINT</span><span class="bash"> <span class="built_in">command</span> param</span></code></pre></code></pre></div></div><div class="paragraph"><p>两者的区别在于：</p></div><div class="ulist"><ul><li><p><code>exec</code> 形式的命令会使用 PID 1 的进程</p></li><li><p><code>shell</code> 形式的命令会被执行为 <code>/bin/sh -c &lt;command&gt;</code>，不会执行在 PID 1 上，也就不会收到 <code>signal</code></p></li></ul></div><div class="paragraph"><p>所以，我们应该选择 <code>exec</code> 模式，让我们的程序成为 PID 1 进程。</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-Dockerfile" data-lang="Dockerfile"><pre><code class="highlight Dockerfile"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"java"</span>, <span class="string">"-jar"</span>, <span class="string">"app.jar"</span>]</span></code></pre></code></pre></div></div><div class="quoteblock"><blockquote><div class="paragraph"><p>更详细的信息，可以查看<a href="https://docs.docker.com/engine/reference/builder/#entrypoint" target="_blank" rel="noopener">官方文档</a>。</p></div></blockquote></div></div><div class="sect3"><h4 id="_exec_命令">exec 命令</h4><div class="paragraph"><p><code>exec</code> 形式的 <code>ENTRYPOINT</code> 只能解决 <em>无需任何准备工作就启动进程</em> 的场景，而不能解决一些需要准备工作的复杂场景。</p></div><div class="paragraph"><p>在这样的场景中，我们的 <code>ENTRYPOINT</code> 往往需要执行一个 <code>shell</code> 脚本：</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-Dockerfile" data-lang="Dockerfile"><pre><code class="highlight Dockerfile"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"./entrypoint.sh"</span>]</span></code></pre></code></pre></div></div><div class="paragraph"><p>然后在这个脚本中执行我们的准备工作，完成后再启动真正的进程。比如上面的例子，做完准备后，启动 <code>java</code> 进程。这时候，我们的 <code>java</code> 进程就无法成为 PID 1 进程。</p></div><div class="imageblock"><div class="content"><img src="docker-exec-ps-not-pid-1.png" alt="docker exec ps not pid 1"></div></div><div class="paragraph"><p>我们可以看到，<code>java</code> 进程的 PID 是 7，也就无法优雅退出了。</p></div><div class="paragraph"><p>为了解决这个问题，我们可以使用 <code>exec</code> 命令来解决。这个命令的作用就是<strong>使用新的进程替代原有的进程，并保持 PID 不变</strong>。这就意味着我们可以在执行 <code>java</code> 命令的时候使用它，从而替换掉 PID 1 的 shell 脚本：</p></div><div class="listingblock"><div class="title">entrypoint.sh</div><div class="content"><pre class="highlight"><code class="language-bash" data-lang="bash"><pre><code class="highlight bash"><span class="meta">#!/bin/sh</span><span class="built_in">echo</span> <span class="string">"Do something"</span><span class="built_in">exec</span> java -jar app.jar</code></pre></code></pre></div></div><div class="paragraph"><p>我们再来看一下容器中的进程：</p></div><div class="imageblock"><div class="content"><img src="docker-exec-ps-pid-1.png" alt="docker exec ps pid 1"></div></div><div class="paragraph"><p>使用 <code>exec</code> 命令之后，我们无论是使用 <code>ctrl+c</code> 还是 <code>docker stop</code> 都能让进程接收到信号，执行相应的操作后退出：</p></div><div class="imageblock"><div class="content"><img src="docker-stop-success-by-exec.png" alt="docker stop success by exec"></div></div><div class="paragraph"><p>这张图我们可以看到很多信息：</p></div><div class="olist arabic"><ol class="arabic"><li><p><code>docker stop</code> 命令很快结束，没有等待十秒</p></li><li><p>容器退出收到的信号是 <code>SIGTERM</code>，不是 <code>SIGKILL</code></p></li><li><p><code>Spring</code> 进程的最后一行日志是 shutdown hook 的日志</p></li></ol></div><div class="paragraph"><p>这些信息表明，<code>java</code> 进程收到了 <code>docker stop</code> 发送的 <code>SIGTERM</code> 信号，并且正确的触发了相关操作，最后退出程序。</p></div></div></div><div class="sect2"><h3 id="_使用_trap">使用 trap</h3><div class="paragraph"><p><code>exec</code> 命令在这样的场景下算是一个比较完美的方案。但如果你还想探索一下其他方式，或者你的容器中需要运行多个进程，那我们可以接着来看看 <code>trap</code> 命令。</p></div><div class="paragraph"><p><code>trap</code> 是用来设置陷阱、监听 <code>signal</code> 的 <code>shell</code> 命令，一般用来处理脚本收到的 <code>signal</code>，完成一些操作。</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-bash" data-lang="bash"><pre><code class="highlight bash"><span class="built_in">trap</span> [-lp] [[arg] sigspec ...]</code></pre></code></pre></div></div><div class="quoteblock"><blockquote><div class="paragraph"><p>本文不介绍 <code>lp</code> 参数的含义</p></div></blockquote></div><div class="ulist"><ul><li><p><code>arg</code> 代表接收到某个信号后要执行的操作，是一个 <code>shell</code> 命令</p></li><li><p><code>sigspec</code> 表示监听的信号，可以是多个</p></li></ul></div><div class="paragraph"><p>举个🌰：</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-bash" data-lang="bash"><pre><code class="highlight bash"><span class="built_in">trap</span> <span class="string">'echo "Shutting Down"'</span> TERM <span class="comment">#(1)</span></code></pre></code></pre></div></div><div class="colist arabic"><ol><li><p>表示在接收到 <code>SIGTERM</code> 信号时输出 "Shutting Down"</p></li></ol></div><div class="sect3"><h4 id="_添加_trap">添加 trap</h4><div class="paragraph"><p>简单了解了 <code>trap</code> 命令后，我们就可以来改造一下 <code>entrypoint.sh</code>：</p></div><div class="listingblock"><div class="title">entrypoint.sh</div><div class="content"><pre class="highlight"><code class="language-bash" data-lang="bash"><pre><code class="highlight bash"><span class="meta">#!/bin/sh</span><span class="built_in">echo</span> <span class="string">'Do something'</span><span class="function"><span class="title">kill_jar</span></span>() &#123;  <span class="built_in">echo</span> <span class="string">'Received TERM'</span>  <span class="built_in">kill</span> <span class="string">"<span class="variable">$(ps -ef | grep java | grep app | awk '&#123;print $1&#125;')</span>"</span> <span class="comment">#(1)</span>&#125;<span class="built_in">trap</span> <span class="string">'kill_jar'</span> TERM INT <span class="comment">#(2)</span>java -jar app.jar</code></pre></code></pre></div></div><div class="colist arabic"><ol><li><p>找到执行的进程，使用 <code>kill</code> 命令向其发送 <code>SIGTERM</code></p></li><li><p>在脚本中监听 <code>SIGTERM</code> 和 <code>SIGINT</code> 信号，然后执行 <code>kill_jar</code> 函数</p></li></ol></div><div class="paragraph"><p>上面的脚本看起来可以正常工作，但实际上不能。</p></div><div class="paragraph"><p>这是因为在 <code>bash</code> 中，即使 <code>trap</code> 收到了信号，如果这个时候 <code>bash</code> 在等待一个命令结束的话，那么 <code>trap</code> 就会等到这个命令结束才会被执行。</p></div><div class="quoteblock"><blockquote><div class="paragraph"><p>If Bash is waiting for a command to complete and receives a signal for which a trap has been set, the trap will not be executed until the command completes.</p></div></blockquote><div class="attribution">&#8212; https://www.gnu.org/software/bash/manual/html_node/Signals.html#Signals</div></div><div class="paragraph"><p>在我们的场景中，<code>bash</code> 就在等待 <code>java</code> 进程结束，才能执行 <code>trap</code> 中的命令。但是 <code>java</code> 进程又需要 <code>trap</code> 来关闭才能结束，所以程序陷入了循环依赖，只能 <code>docker stop</code> 等待 10s。</p></div></div><div class="sect3"><h4 id="_后台运行_java">后台运行 java</h4><div class="paragraph"><p>既然前面的问题是 <code>bash</code> 在等待 <code>java</code> 进程结束，那么我们就让它不等待就好了——后台执行 <code>java</code>：</p></div><div class="listingblock"><div class="title">entrypoint.sh</div><div class="content"><pre class="highlight"><code class="language-bash" data-lang="bash"><pre><code class="highlight bash"><span class="meta">#!/bin/sh</span><span class="built_in">echo</span> <span class="string">'Do something'</span><span class="function"><span class="title">kill_jar</span></span>() &#123;  <span class="built_in">echo</span> <span class="string">'Received TERM'</span>  <span class="built_in">kill</span> <span class="string">"<span class="variable">$(ps -ef | grep java | grep app | awk '&#123;print $1&#125;')</span>"</span>  <span class="built_in">echo</span> <span class="string">'Process finished'</span>&#125;<span class="built_in">trap</span> <span class="string">'kill_jar'</span> TERM INTjava -jar app.jar &amp; <span class="comment">#(1)</span><span class="built_in">wait</span> $! <span class="comment">#(2)</span></code></pre></code></pre></div></div><div class="colist arabic"><ol><li><p>后台执行 <code>java</code></p></li><li><p>使用 <code>wait</code> 命令等待 <code>java</code> 进程结束，避免 <code>entrypoint.sh</code> 执行完成后容器直接退出</p></li></ol></div><div class="paragraph"><p>是不是觉得这样就 OK 了？Naive，上面的这个脚本能够帮助我们立即结束容器，但并不会等待进程自己正常退出：</p></div><div class="imageblock"><div class="content"><img src="docker-stop-without-shutdown.png" alt="docker stop without shutdown"></div></div><div class="paragraph"><p>我们可以看到，<code>kill_jar</code> 方法中的 <code>echo</code> 被成功执行，但是却没有看到 <code>Spring</code> 的 shutdown hook 日志输出。这说明容器没有等待程序正常退出就被关闭了。</p></div><div class="paragraph"><p>这里其实有两个问题。</p></div><div class="dlist"><dl><dt class="hdlist1"><code>kill</code> 的问题</dt><dd><p>第一个是 <code>kill</code> 命令并不会等待进程结束，它只负责向进程发送 <code>SIG</code> 信号。至于程序如何处理、什么时候处理，则与它无瓜。</p></dd><dt class="hdlist1"><code>wait</code> 的问题</dt><dd><p>第二个问题则是 <code>wait</code> 命令，在上面 <code>bash</code> 对 <code>trap</code> 的解释后面，还有一句话：</p></dd></dl></div><div class="quoteblock"><blockquote><div class="paragraph"><p>When Bash is waiting for an asynchronous command via the wait builtin, the reception of a signal for which a trap has been set will cause the wait builtin to return immediately with an exit status greater than 128, immediately after which the trap is executed.</p></div></blockquote><div class="attribution">&#8212; https://www.gnu.org/software/bash/manual/html_node/Signals.html#Signals</div></div><div class="paragraph"><p>也就是说，虽然 <code>bash</code> 在等待 <code>wait</code> 结束，但是 <code>wait</code> 又被特殊处理了——<code>trap</code> 收到任何大于 128 的信号都会让 <code>wait</code> 命令结束，以执行 <code>trap</code> 中的方法。</p></div><div class="paragraph"><p>综合以上两点，我们会发现 <code>trap</code> 在执行 <code>kill_jar</code> 时，<code>entrypoint.sh</code> 中的 <code>wait</code> 已经结束，不再等待 <code>java</code> 进程结束。<code>kill_jar</code> 仅仅发送了 <code>SIGTERM</code> 信号，也不会等待 <code>java</code> 进程结束。</p></div><div class="paragraph"><p>由此，我们就可以对脚本进行改进：</p></div><div class="listingblock"><div class="title">entrypoint.sh</div><div class="content"><pre class="highlight"><code class="language-bash" data-lang="bash"><pre><code class="highlight bash"><span class="meta">#!/bin/sh</span><span class="built_in">echo</span> <span class="string">'Do something'</span><span class="function"><span class="title">kill_jar</span></span>() &#123;  <span class="built_in">echo</span> <span class="string">'Received TERM'</span>  <span class="built_in">kill</span> <span class="string">"<span class="variable">$(ps -ef | grep java | grep app | awk '&#123;print $1&#125;')</span>"</span>  <span class="built_in">wait</span> $! <span class="comment">#(1)</span>  <span class="built_in">echo</span> <span class="string">'Process finished'</span>&#125;<span class="built_in">trap</span> <span class="string">'kill_jar'</span> TERM INTjava -jar app.jar &amp;<span class="built_in">wait</span> $!</code></pre></code></pre></div></div><div class="colist arabic"><ol><li><p>在 <code>kill</code> 后加了一行 <code>wait</code>，因为 <code>kill</code> 会返回进程号，所以这里也可以使用 <code>$!</code>。</p></li></ol></div><div class="paragraph"><p>这样，我们的 <code>kill_jar</code> 就会等到 <code>java</code> 进程完全退出后才会结束：</p></div><div class="imageblock"><div class="content"><img src="docker-stop-success-by-trap.png" alt="docker stop success by trap"></div></div><div class="paragraph"><p>我们可以看到，<code>Spring</code> 的 shutdown hook 在 "Process finished" 之前输出，证明新加的 <code>wait</code> 命令发挥了作用。</p></div></div></div></div></div><div class="sect1"><h2 id="_总结">总结</h2><div class="sectionbody"><div class="olist arabic"><ol class="arabic"><li><p><code>ctrl+c</code> 与 <code>docker stop</code> 都只会向容器中 PID 1 进程发送信号</p></li><li><p><code>docker stop</code> 默认等待 10s 没有关闭容器后，会向内核发送 <code>SIGKILL</code> 以强制关闭容器</p></li><li><p>解决方案：</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>直接启动进程时，使用 <code>ENTRYPOINT</code> 的 <code>exec form</code></p></li><li><p>启动单一进程，并且需要一点准备工作时，使用 <code>exec</code> 命令</p></li><li><p>启动多个进程时，组合使用 <code>trap</code>、<code>wait</code>、<code>kill</code> 命令</p></li></ol></div></li></ol></div></div></div>]]></content:encoded>
      
      <comments>https://blog.gaoyuexiang.cn/2020/06/18/graceful-shutdown-docker-container/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Spring Security 的权限验证</title>
      <link>https://blog.gaoyuexiang.cn/2020/06/13/spring-security-authorization/</link>
      <guid>https://blog.gaoyuexiang.cn/2020/06/13/spring-security-authorization/</guid>
      <pubDate>Sat, 13 Jun 2020 16:33:33 GMT</pubDate>
      <description>
      
        &lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;在前面的文章里，我们对 Spring Security 进行权限验证的组件有了大致的了解，我们首先来回顾并探究一下细节。&lt;/p&gt;
&lt;/div&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<div class="paragraph"><p>在前面的文章里，我们对 Spring Security 进行权限验证的组件有了大致的了解，我们首先来回顾并探究一下细节。</p></div><div class="imageblock center"><div class="content"><img src="spring-authorization.png" alt="spring authorization"></div><div class="title">Figure 1. 本文涉及到的组件</div></div><div class="sect1"><h2 id="_filtersecurityinterceptor">FilterSecurityInterceptor</h2><div class="sectionbody"><div class="paragraph"><p>这是 <code>AbstractSecurityInterceptor</code> 的一个子类，并且实现了 <code>Filter</code> 接口，负责调用父类的 <code>beforeInvocation()</code>、<code>afterInvocatio()</code> 和 <code>finallyInvocation()</code> 方法以及一些 Servlet 相关的工作。真正处理权限验证的代码，其实在父类中。它存在的意义就是为了能在 <code>Filter</code> 中进行权限验证。</p></div><div class="paragraph"><p>这个 <code>Filter</code> 默认总是被安排在 <code>SecurityFilterChain</code> 的最后，因为需要保证它在所有的身份认证相关的 <code>Filter</code> 之后。</p></div><div class="sect2"><h3 id="_abstractsecurityinterceptor">AbstractSecurityInterceptor</h3><div class="paragraph"><p>这个类实现了真正的权限验证的逻辑，它有多个子类，是为了适配不同的技术而存在的，比如上面的 <code>FilterSecurityInterceptor</code> 就是为了适配 Servlet Filter 而存在的。</p></div><div class="paragraph"><p>我们可以关注一下上面提到的三个方法，这是每个子类都会调用的。</p></div><div class="paragraph"><p>子类的实现总是下面的套路：</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-java" data-lang="java"><pre><code class="highlight java">InterceptorStatusToken token = <span class="keyword">super</span>.beforeInvocation(secureObject); <span class="comment">// (1)</span><span class="keyword">try</span> &#123;  <span class="comment">// call target method, eg, filterChain.doFilter()</span>  <span class="comment">// may get a returnedObject</span>&#125; <span class="keyword">final</span> &#123;  <span class="keyword">super</span>.finallyInvocation(token);&#125;<span class="keyword">super</span>.afterInvocation(token, returnedObject);</code></pre></code></pre></div></div><div class="colist arabic"><ol><li><p><code>secureObject</code> 是一个方法调用，它的类型是 <code>Object</code>，但一般会看到 <code>MethodInvocation</code> 或者 <code>FilterInvocation</code> 这样的类型。</p></li></ol></div><div class="sect3"><h4 id="_beforeinfocation_方法">beforeInfocation 方法</h4><div class="paragraph"><p>这个方法的目标是调用 <code>AccessDecisionManager.decide()</code> 方法，完成 pre-invocation handling 操作。</p></div><div class="paragraph"><p>在前面的<a href="/2020/05/31/spring-security-servlet-overview#_权限验证">概览</a>中介绍过，<code>AccessDecisionManager.decide()</code> 方法有三个参数。其中的 secureObject 已经被子类传进来了。那么在真正调用前，就会去获取 <code>Authentication</code> 对象和 <code>Collection&lt;ConfigAttribute&gt;</code> 集合，然后进行 pre-invocation handling 操作。</p></div><div class="quoteblock"><blockquote><div class="paragraph"><p>后面会介绍 <code>ConfigAttribute</code></p></div></blockquote></div><div class="paragraph"><p>如果调用时出现 <code>AccessDecisionException</code>，那么他将会被 <code>ExceptionTranslationFilter</code> 处理。</p></div><div class="paragraph"><p>在通过权限验证之后，就会准备一个 <code>InterceptorStatusToken</code> 对象作为返回值。</p></div><div class="paragraph"><p>在创建 token 之前，会尝试使用 <code>RunAsManager</code> 创建一个 <code>Authentication</code> 对象，如果这个对象不为 <code>null</code>，那么就会把它放入一个 <code>SecurityContext</code>，替换掉 <code>SecurityContextHolder</code> 中原有的那个。</p></div><div class="paragraph"><p>原有的 <code>SecurityContext</code> 总是会被放到 token 中。</p></div><div class="quoteblock"><blockquote><div class="paragraph"><p>关于 <code>RunAsManager</code> ：这里的逻辑是替换掉 <code>SecurityContextHolder</code> 中的值，这样在目标方法中看到的 <code>Authentication</code> 对象就是这个 <code>RunAsManager</code> 创建的对象。在目标方法调用完成后，即 <a href="#_finallyinfocation_方法">finallyInvocation 方法</a> 中，会将原来的 <code>SecurityContext</code> 重新放回 <code>SecurityContextHolder</code> 中。</p></div><div class="paragraph"><p>这样的目的是为了将认证与鉴权流程中的 <code>Authentication</code> 对象与业务方法中的区分开来。</p></div></blockquote></div><div class="paragraph"><p>在上面的这些步骤中，还会发出一些 <code>ApplicationEvent</code>，包括: <code>PublicInvocationEvent</code>、<code>AuthorizationFailureEvent</code> 和 <code>AuthorizedEvent</code>。</p></div><div class="quoteblock"><blockquote><div class="paragraph"><p><code>PublicInvocationEvent</code> 只在 <code>Collection&lt;ConfigAttribute&gt;</code> 为空的时候才会发生，而且这种时候不会调用 <code>AccessDecisionManager</code>。</p></div></blockquote></div></div><div class="sect3"><h4 id="_afterinfocation_方法">afterInfocation 方法</h4><div class="paragraph"><p><code>afterInvocation</code> 方法主要目的是为了根据 <code>returnedObject</code> 进行权限验证，这使用到了 <code>AfterInvocationManager</code> 这个接口，这是在<a href="/2020/05/31/spring-security-servlet-overview#_权限验证">概览</a>里没有提到的，它被用来进行 after invocation handling。</p></div><div class="paragraph"><p>在这个方法中，如果有必要的话，就会使用 <code>AfterInvocationManager.decide()</code> 方法来处理 <code>returnedObject</code>，得到一个新的结果作为 <code>returntedObject</code>。</p></div><div class="quoteblock"><blockquote><div class="paragraph"><p>这里的有必要是指：</p></div><div class="olist arabic"><ol class="arabic"><li><p>token != null</p></li><li><p><code>afterInvocationManager</code> 字段不为空</p></li></ol></div></blockquote></div></div><div class="sect3"><h4 id="_finallyinfocation_方法">finallyInfocation 方法</h4><div class="paragraph"><p>这个方法接收 <code>InterceptorStatusToken</code> 作为参数，只做一件事情：将 token 中的 <code>SecurityContext</code> 对象放回 <code>SecurityContextHolder</code> 中。</p></div><div class="paragraph"><p>这个操作有两个判断条件：</p></div><div class="ulist"><ul><li><p>token 不为 null</p></li><li><p>token 的 <code>contextHolderRefreshRequired</code> 为 <code>true</code>。当 <code>SecurityContextHolder</code> 中的值在 <code>beforeInvocation</code> 中被替换时，这个值才为 <code>true</code></p></li></ul></div><hr><div class="paragraph"><p>权限验证的入口 <code>FilterSecurityInterceptor</code> 的介绍就到这里，接下来我们来看看 pre-invocation handling 和 after invocation handling 的内容，也就是 <code>AccessDecisionManager</code> 与 <code>AfterInvocationManager</code>。</p></div></div></div></div></div><div class="sect1"><h2 id="_accessdecisionmanager">AccessDecisionManager</h2><div class="sectionbody"><div class="paragraph"><p>这是在<a href="/2020/05/31/spring-security-servlet-overview#_权限验证">概览</a>中介绍过的内容，这里可以快速的回顾一下。</p></div><div class="imageblock center"><div class="content"><img src="access-decision-voting.png" alt="access decision voting"></div></div><div class="paragraph"><p><code>AccessDecisionManager</code> 是 pre-invocation handling 的入口。它的三个具体实现会调用多个 <code>AccessDecisionVoter</code> 的实现，然后具体实现的策略来决定如何根据 voter 的结果来判断是否通过身份验证。每一个 voter 都会根据当前的 <code>Authentication</code> 对象、<code>secureObject</code> 和 <code>Collection&lt;ConfigAttribute&gt;</code> 来做出是否允许访问的选择。</p></div><div class="paragraph"><p><code>AccessDecisionManager</code> 的三个实现，其实就是三种根据 voter 结果来决定最终结果的策略，分别是 <code>AffirmativeBased</code>、<code>ConsensusBased</code> 和 <code>UnanimousBased</code>。策略顾名思义，就不解释了。</p></div></div></div><div class="sect1"><h2 id="_afterinvocationmanager">AfterInvocationManager</h2><div class="sectionbody"><div class="paragraph"><p>之前没有讲 after invocation handling 的部分，是觉得不重要，使用场景不多（其实是自己没遇到）。现在想讲一讲，是因为发现 <code>spring-security-acl</code> 使用到了 after invocation handling 的机制。那么我们就来看看 <code>AfterInvocationManager</code> 是怎么工作的。</p></div><div class="quoteblock"><blockquote><div class="paragraph"><p><code>acl</code> 的部分涉及一些新的概念，准备单独写一篇。</p></div></blockquote></div><div class="imageblock center"><div class="content"><img src="after-invocation.png" alt="after invocation"></div></div><div class="paragraph"><p>通过这个图，我们可以清楚的了解到，<code>AfterInvocationManager</code> 也只是一个接口。它的实现 <code>AfterInvocationProviderManager</code> 则是管理了“很多的” <code>AfterInvocationProvider</code> 来真正的执行权限验证的操作。</p></div><div class="quoteblock"><blockquote><div class="paragraph"><p>这里“很多的” <code>AfterInvocationProvider</code> 其实也就只有四个个实现，其中三个都是 <code>acl</code>，包括图里的这两个。</p></div></blockquote></div><div class="paragraph"><p>剩下的那个 <code>PostInvocationAdviceProvider</code> 其实也没有真正进行 authorization 操作，而是代理给了 <code>PostInvocationAuthorizationAdvice</code> 处理。而这个 <code>PostInvocationAuthorizationAdvice</code> 也只有 <code>ExpressionBasedPostInvocationAdvice</code> 这一个实现，也就是基于 <code>SpEL</code> 表达式来进行 authorization 的实现。</p></div><div class="paragraph"><p>而上面提到的所有的 manager 和 provider，都提供了 <code>decide</code> 方法用来做权限验证。与 <code>AccessDecisionManager.decide()</code> 相比，这些方法多了一个 <code>returnedObject</code> 参数。这既是因为它需要作为判断条件参与到决策过程中，也是因为它可能会在决策过程中被处理，然后返回一个新的 <code>returnedObject</code> 作为处理后的结果。</p></div></div></div><div class="sect1"><h2 id="_configattribute">ConfigAttribute</h2><div class="sectionbody"><div class="paragraph"><p>这个类是用来存储我们的 Security 的配置的。</p></div><div class="paragraph"><p>举个例子，下面的代码就会生成相应的 <code>ConfigAttribute</code>：</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-java" data-lang="java"><pre><code class="highlight java"><span class="meta">@Override</span><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;  http.authorizeRequests()      .mvcMatchers(<span class="string">"hello"</span>)      .hasAuthority(<span class="string">"test"</span>)      .anyRequest()      .authenticated();&#125;</code></pre></code></pre></div></div><div class="paragraph"><p>上面的代码定义了：</p></div><div class="ulist"><ul><li><p>访问 <code>/hello</code> 的请求需要具有 <code>test</code> 权限</p></li><li><p>其他任意请求，需要通过身份验证（不允许匿名访问）</p></li></ul></div><div class="paragraph"><p>这样我们就能得到这样的 <code>ConfigAttribute</code>：</p></div><div class="imageblock center"><div class="content"><img src="config-attribute.png" alt="config attribute"></div></div><div class="paragraph"><p>这是 <code>FilterSecurityInterceptor</code> 的截图。其中的 <code>securityMetadataSource</code> 存储了很多的 <code>ConfigAttribute</code>。<code>AbstractSecurityInterceptor</code> 通过子类实现的 <code>obtainSecurityMetadataSource</code> 方法获取到它，然后通过它获取到本次使用的 <code>Collection&lt;ConfigAttribute&gt;</code>。</p></div><div class="paragraph"><p>截图中的 <code>requestMap</code> 保存了 <code>RequestMatcher</code> 与 <code>Collection&lt;ConfigAttribute&gt;</code> 的关系。</p></div><div class="paragraph"><p>当我们请求 <code>/hello</code> 时，就会得到第一个 <code>Collection&lt;ConfigAttribute&gt;</code>，也就是包含了 <code>hasAuthority('test')</code> 的那一个。当我们请求其他接口时，就会得到第二个。</p></div><div class="paragraph"><p>接着，这些被获取到的 <code>ConfigAttribute</code> 就可以被后续的验证逻辑使用到。</p></div></div></div><div class="sect1"><h2 id="_总结">总结</h2><div class="sectionbody"><div class="paragraph"><p>本文介绍了 Spring Security Authorization，并着重介绍了 <code>FilterSecurityInterceptor</code> 如何在 <code>SecurityFilterChain</code> 的最后使用 <code>AccessDecisionManager</code> 和 <code>AfterInvocationManager</code> 来实现 pre-invocation handling 和 after invocation handling。</p></div><div class="paragraph"><p>对于 <code>AccessDecisionManager</code> 和 <code>AfterInfocationManager</code>，则没有详细介绍内部的逻辑，而是介绍了它们如何利用子类和其他接口来完成权限验证的。其内部具体的细节逻辑，读者可以自己研究。</p></div><div class="quoteblock"><blockquote><div class="paragraph"><p>查看系列文章： <a href="/spring-security-servlet/">点这里</a></p></div></blockquote></div></div></div>]]></content:encoded>
      
      <comments>https://blog.gaoyuexiang.cn/2020/06/13/spring-security-authorization/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Spring Security 中的身份认证</title>
      <link>https://blog.gaoyuexiang.cn/2020/06/07/spring-security-authentication/</link>
      <guid>https://blog.gaoyuexiang.cn/2020/06/07/spring-security-authentication/</guid>
      <pubDate>Sun, 07 Jun 2020 22:04:29 GMT</pubDate>
      <description>
      
        &lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;本文介绍 Spring Security 的身份认证的内容，研究 Spring Security 自带的身份认证方式和添加自己的身份认证方式的方法。&lt;/p&gt;
&lt;/div&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<div class="paragraph"><p>本文介绍 Spring Security 的身份认证的内容，研究 Spring Security 自带的身份认证方式和添加自己的身份认证方式的方法。</p></div><div class="sect1"><h2 id="_身份认证相关组件">身份认证相关组件</h2><div class="sectionbody"><div class="paragraph"><p>在<a href="/2020/05/31/spring-security-servlet-overview/">上一篇文章</a>中，我们了解到了 Spring Security 会将 <code>DelegatingFilterProxy</code> 插入到 Servlet Filter Chain 中，然后将要过滤的请求通过 <code>FilterChainProxy</code> 代理给匹配的 <code>SecurityFilterChain</code>；这些 <code>SecurityFilterChain</code> 中包含着真正做安全相关工作的 <code>Filter</code>。</p></div><div class="imageblock center"><div class="content"><img src="filter-chain.png" alt="filter chain"></div><div class="title">Figure 1. 后面提到的 Filter 都是红色方框中的</div></div><div class="paragraph"><p>这些 <code>Filter</code> 中的一部分，他们的职责就是进行身份验证，比如 <code>UsernamePasswordAuthenticationFilter</code>；而他们中的大多数都有一个共同的父类 <code>AbstractAuthenticationProcessingFilter</code>。</p></div><div class="sect2"><h3 id="_abstractauthenticationprocessfilter">AbstractAuthenticationProcessFilter</h3><div class="paragraph"><p>这个类是很多身份认证的 Filter 的父类，它已经实现了 <code>doFilter</code> 方法，流程如下：</p></div><div class="imageblock center"><div class="content"><img src="abstract-authentication-processing-filter.png" alt="abstract authentication processing filter"></div></div><div class="quoteblock"><blockquote><div class="paragraph"><p>本文不涉及其中的 sessionStrategy 部分</p></div></blockquote></div><div class="paragraph"><p><code>doFilter</code> 已经帮我们搭好了这个流程，我们只需要关心其中的几个被调用的方法(红绿蓝三个颜色框)就可以了。</p></div><div class="sect3"><h4 id="_attemptauthentication">attemptAuthentication</h4><div class="paragraph"><p>这是一个抽象方法。子类实现的时候，需要从 <code>HttpServletRequest</code> 中获取需要的信息，构建出一个 <code>Authentication</code> 实例，然后调用父类中的 <code>AuthenticationManager.authenticate()</code> 方法，对 <code>Authentication</code> 对象进行认证。</p></div></div><div class="sect3"><h4 id="_unsuccessfulauthentication">unsuccessfulAuthentication</h4><div class="paragraph"><p>这个方法已经被实现，子类也可以选择重写。根据父类的实现，这个方法将完成一下步骤：</p></div><div class="olist arabic"><ol class="arabic"><li><p>清理 <code>SecurityContextHolder</code></p></li><li><p>清除 <code>RememberMeService</code> 中的信息（默认使用 <code>NullRememberMeService</code>）</p></li><li><p>调用 <code>AuthenticationFailureHandler.onAuthenticationFailure()</code> 方法</p></li></ol></div><div class="paragraph"><p>默认使用的 <code>AuthenticationFailureHandler</code> 是 <code>SimpleUrlAuthenticationFailureHandler</code>，它的逻辑是：</p></div><div class="olist arabic"><ol class="arabic"><li><p>如果没有配置 <code>defaultFailureUrl</code> （默认没有）</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>发送 401 响应</p></li></ol></div></li><li><p>根据配置的布尔值 <code>forwardToDestination</code> （默认为 <code>false</code>）判断</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>使用 Servlet forward 到配置的 <code>defaultFailureUrl</code></p></li><li><p>使用 HTTP redirect 到配置的 <code>defaultFailureUrl</code></p></li></ol></div></li></ol></div></div><div class="sect3"><h4 id="_successfulauthentication">successfulAuthentication</h4><div class="paragraph"><p>与 <code>unsuccessfulAuthentication</code> 方法一样，这个方法也已经实现，并且可以被重写，但其中的逻辑却恰好相反：</p></div><div class="olist arabic"><ol class="arabic"><li><p>将 <code>attemptAuthentication</code> 返回的 <code>Authentication</code> 对象保存到 <code>SecurityContextHolder</code> 中</p></li><li><p>保存登陆信息到 <code>RememberMeService</code> 中</p></li><li><p>发布 <code>InteractiveAuthenticationSuccessEvent</code> 事件，这样可以被配置的 <code>EventListener</code> 处理</p></li><li><p>调用 <code>AuthenticationSuccessHandler.onAuthenticationSuccess()</code> 方法</p></li></ol></div><div class="paragraph"><p>默认使用的 <code>AuthenticationSuccessHandler</code> 是 <code>SavedRequestAwareAuthenticationSuccessHandler</code>，其实现就是一次重定向。我们可以看看它重定向到哪里:</p></div><div class="ulist"><ul><li><p>当配置了 <code>alwaysUseDefaultTargetUrl</code> 或指定了 <code>targetUrlParameter</code> 且此参数存在的时候</p><div class="ulist"><ul><li><p>如果配置了 <code>alwaysUseDefaultTargetUrl</code> 则重定向到 <code>defaultTargetUrl</code>，默认是 <code>/</code></p></li><li><p>如果存在 <code>targetUrlParameter</code>（比如 redirect_uri 之类的比较常见的参数），则重定向到这个路径</p></li><li><p>如果存在 <code>Referer</code>，则重定向到这个地址</p></li><li><p>重定向到 <code>/</code></p></li></ul></div></li><li><p>从 <code>RequestCache</code> 中找到了保存的请求</p><div class="ulist"><ul><li><p>重定向到请求中设置的重定向地址</p></li></ul></div></li><li><p>如果还是没有满足条件，则进行第一步里的逻辑</p></li></ul></div><div class="quoteblock"><blockquote><div class="paragraph"><p>关于 <code>RequestCache</code>：想象你正在访问一个需要认证的资源，这个时候网站会把你重定向到登陆页面；在你登陆成功后，又会重定向回刚才的资源。<code>RequestCache</code> 就是为了保存登陆之前的请求而设计的。在这里，默认使用基于 session 的实现。</p></div></blockquote></div></div></div><div class="sect2"><h3 id="_authenticationmanager">AuthenticationManager</h3><div class="paragraph"><p>在 <code>AbstractAuthenticationProcessingFilter</code> 中保存了一个 <code>AuthenticationManager</code>，它会在子类的 <code>attemptAuthentication</code> 方法中被使用。其职责是对 <code>Filter</code> 创建的 <code>Authentication</code> 对象进行身份验证，比如查询数据库匹配用户名密码、携带的 token 是否合法等。</p></div><div class="sect3"><h4 id="_providermanager_与_authenticationprovider">ProviderManager 与 AuthenticationProvider</h4><div class="paragraph"><p>这是 <code>AuthenticationManager</code> 常用的实现。它没有实现任何认证逻辑，而是管理了一些 <code>AuthenticationProvider</code>，通过这些 provider 来实现真正的认证功能。</p></div><div class="paragraph"><p>每个 <code>AuthenticationProvider</code> 实现一种特定类型的身份认证方式，比如用户名密码登陆、OIDC 登陆等。他们可以通过 <code>Authentication</code> 的具体类型来判断是否支持这种 <code>Authentication</code> 需要的认证方式。</p></div></div></div><div class="sect2"><h3 id="_其他的一些_filter">其他的一些 Filter</h3><div class="paragraph"><p>除了 <code>AbstractAuthenticationProcessFilter</code>，还有一些进行身份验证的 <code>Filter</code>，它们并没有继承这个类，而是基于 <code>OncePerRequestFilter</code> 自己实现了一套逻辑。这些 <code>Filter</code> 包括 <code>AuthenticationFilter</code> 、<code>BasicAuthenticationFilter</code> 、<code>OAuth2AuthorizationCodeGrantFilter</code> 等等。</p></div><div class="paragraph"><p>由于它们不再是 <code>AbstractAuthenticationProcessFilter</code>，所以不会再被要求使用 <code>AuthenticationManager</code>。尽管这样，当我们选择使用 <code>OncePerReuqestFilter</code> 来实现自定义的身份认证时，仍然可以考虑使用 <code>AuthenticationManager</code> 这种方式。</p></div><div class="quoteblock"><blockquote><div class="paragraph"><p>个人觉得 <code>AuthenticationManager</code> 还算是个不错的设计，因为做到了职责分离。</p></div></blockquote></div><div class="paragraph"><p>甚至还有更加放飞自我的 <code>DigestAuthenticationFilter</code>，直接继承 <code>GenericFilterBean</code>，在实现上也是我行我素，这里就不探究了。</p></div></div><div class="sect2"><h3 id="_exceptiontranslationfilter">ExceptionTranslationFilter</h3><div class="paragraph"><p>这个 Filter 不是用来进行身份验证的，而是用来处理认证授权过程中产生的异常的。它可以处理 <code>AuthenticationException</code> 和 <code>AccessDeniedException</code>，分别表示认证失败和授权失败。这篇文章只关心如何处理 <code>AuthenticationException</code>。</p></div><div class="paragraph"><p>但是这个 <code>Filter</code> 默认被安排在 <code>SecurityFilterChain</code> 的倒数第二位，所以前面的 <code>Filter</code> 抛出的异常并不能被它捕获。但自定义的 <code>Filter</code> 可以加到它后面，这样就可以利用它来处理这两种异常。</p></div><div class="quoteblock"><blockquote><div class="paragraph"><p>最后一位是 <code>FilterSecurityInterceptor</code>，可能会抛出 <code>AccessDeniedException</code>。</p></div></blockquote></div><div class="sect3"><h4 id="_处理_authenticationexception">处理 AuthenticationException</h4><div class="paragraph"><p><code>ExceptionTranslationFilter</code> 对 <code>AuthenticationException</code> 的处理分三步：</p></div><div class="olist arabic"><ol class="arabic"><li><p>清理 <code>SecurityContextHolder</code> 中的身份信息</p></li><li><p>将当前的 request、response 保存到 <code>RequestCache</code> 中（用途可以回顾一下 <a href="#_successfulauthentication">successfulAuthentication 方法</a>）</p></li><li><p>调用 <code>AuthenticationEntryPoint.commence()</code> 方法</p></li></ol></div><div class="paragraph"><p>其中的 <code>AuthenticationEntryPoint</code> 具体实例取决于你的配置，默认会用到 <code>BasicAuthenticationEntryPoint</code>。这个接口的职责就是通过 <code>WWW-Authenticate</code> header 告诉客户端使用哪种方式进行身份验证。</p></div></div><div class="sect3"><h4 id="_处理其他异常">处理其他异常</h4><div class="paragraph"><p>对于 <code>AuthenticationException</code> 和 <code>AccessDeniedException</code> 之外的异常，<code>ExceptionTranslationFilter</code> 会将其转换成 <code>ServletException</code> 或 <code>RuntimeException</code> 抛出。</p></div><div class="paragraph"><p>如果想要处理这些异常，需要自己添加 <code>Filter</code> 实现。</p></div></div></div></div></div><div class="sect1"><h2 id="_spring_security_自动配置的_filterchainproxy">Spring Security 自动配置的 FilterChainProxy</h2><div class="sectionbody"><div class="paragraph"><p>当我们启动 Spring 应用之后，会在日志里看到打印所有配置的 <code>FilterChainProxy</code>。</p></div><div class="paragraph"><p>默认情况下，我们会看到这样的一条链：</p></div><div class="imageblock center"><div class="content"><img src="default-filter-chain.png" alt="default filter chain"></div></div><div class="paragraph"><p>这是引入 <code>spring-boot-starter-security</code> 之后自动配置的 <code>FilterChainProxy</code>，在引入更多的 security 相关的依赖和编写了相关配置之后，这个 filter chain 也会相应变化。</p></div></div></div><div class="sect1"><h2 id="_几种内置的身份认证方式">几种内置的身份认证方式</h2><div class="sectionbody"><div class="paragraph"><p>接下来，我们以 <code>UsernamePawwrodAuthenticationFilter</code> 和 <code>BasicAuthenticationFilter</code> 为例，看看他们是如何实现身份认证的。</p></div><div class="sect2"><h3 id="_usernamepasswordauthenticationfilter">UsernamePasswordAuthenticationFilter</h3><div class="paragraph"><p><code>UsernamePasswordAuthenticationFilter</code> 是一个 <code>AbstractAuthenticationProcessingFilter</code> 的子类，实现了 <code>attemptAuthentication</code> 方法，没有重写其他方法。所以用户认证成功后，会被重定向到一个地址，具体逻辑参考上面的 <a href="#_successfulauthentication">successfulAuthentication 方法</a>。</p></div><div class="sect3"><h4 id="_attemptauthentication_2">attemptAuthentication</h4><div class="paragraph"><p><code>attemptAuthentication</code> 方法会从 <code>HttpServletRequest.getParameter()</code> 方法中获取用户名密码，从而进行身份验证。具体从哪里获取用户名密码，则可以被子类通过重写 <code>obtainUsername()</code> 和 <code>obtainPassword()</code> 方法修改。</p></div><div class="paragraph"><p>之后，<code>UsernamePasswordAuthenticationFilter</code> 会构建出一个 <code>UsernameAuthenticationToken</code>，交给 <code>AuthenticationManager</code> 进行认证。</p></div></div><div class="sect3"><h4 id="_daoauthenticationprovider">DaoAuthenticationProvider</h4><div class="paragraph"><p>这是 <code>UsernamePasswordAuthenticationFilter</code> 对应的 <code>AuthenticationProvider</code>，负责对 <code>UsernameAuthenticationToken</code> 进行认证。</p></div><div class="paragraph"><p>它使用一个 <code>UserDetailsService</code> 来加载用户信息，使用 <code>PasswordEncoder</code> 来匹配用户的密码。</p></div><div class="paragraph"><p>这两个接口具体使用哪一个实现，取决于具体的配置。比如 <code>UserDetailsService</code> 就有 in memory 和 JDBC 的实现。</p></div><div class="quoteblock"><blockquote><div class="paragraph"><p><code>UsernamePasswordAuthenticationFilter</code> 是用于单独处理登录的 <code>Filter</code>，它不是用来在请求业务 API 时进行身份认证的 <code>Filter</code>。</p></div><div class="paragraph"><p>事实上，所有继承了 <code>AbstractAuthenticationProcessFilter</code> 但没有重写 <code>successfulAuthentication</code> 方法的 <code>Filter</code> 都是这样的，它们会在登陆成功后重定向到登录前的地址或默认的地址。这也符合它的语义：进行<strong>身份认证流程</strong>，而不是业务请求的一部分。</p></div></blockquote></div></div></div><div class="sect2"><h3 id="_basicauthenticationfilter">BasicAuthenticationFilter</h3><div class="paragraph"><p>与 <code>UsernamePasswordAuthenticationFilter</code> 不同，<code>BasicAuthenticationFilter</code> 没有继承 <code>AbstractAuthenticationProcessingFilter</code>，而是直接继承 <code>OncePerRequestFilter</code>。因为它是被使用在请求业务 API 的请求上，而不是进行身份认证流程。</p></div><div class="paragraph"><p><code>BasicAuthenticationFilter</code> 的实现并不复杂，无非是从 <code>Authorization</code> header 中取出用户名密码，然后创建出 <code>UsernameAuthenticationToken</code>，接着调用 <code>AuthenticationManager.authenticate()</code> 方法。</p></div><div class="quoteblock"><blockquote><div class="paragraph"><p>之所以它也会使用 <code>AuthenticationManager</code>，应该是出于复用的考虑。这样它就可以使用和 <code>UsernamePasswordAuthenticationFilter</code> 一样的 <code>AuthenticationProvider</code>。</p></div></blockquote></div><div class="paragraph"><p>它与 <code>UsernamePasswordAuthenticationFilter</code> 的区别在于认证之后的行为。</p></div><div class="paragraph"><p>无论认证成功与否，<code>BasicAuthenticationFilter</code> 都不会做出重定向的响应。</p></div><div class="ulist"><ul><li><p>如果认证失败，则通过默认的 <code>BasicAuthenticationEntryPoint</code> 返回 401 响应</p></li><li><p>如果认证成功，则继续执行 filter chain，这样就能执行到真正的业务方法</p></li></ul></div></div></div></div><div class="sect1"><h2 id="_如何添加自己的身份认证方式">如何添加自己的身份认证方式</h2><div class="sectionbody"><div class="paragraph"><p>前面介绍了两种不同的 <code>Filter</code> 实现，以及它们被使用的场景，现在我们知道了该选择哪一种方式去实现自定义的 <code>Filter</code>。但是，如何把它们加入到 <code>SecurityFilterChain</code> 中去处理身份认证呢？</p></div><div class="sect2"><h3 id="_配置_securityfilterchain">配置 SecurityFilterChain</h3><div class="paragraph"><p>我们如果需要任何对 <code>SecurityFilterChain</code> 的配置，都需要扩展 <code>WebSecurityConfigurerAdapter</code>，实现自己的一个配置类。每创建这样的一个实现，都会创建一个 <code>SecurityFilterChain</code> 加入到 <code>FilterChainProxy</code> 中。</p></div><div class="sect3"><h4 id="_配置_requestmathcer">配置 requestMathcer</h4><div class="paragraph"><p>我们在前一篇文章提到过，<code>FilterChainProxy</code> 需要根据 url 来判断选择哪一个 <code>SecurityFilterChain</code>。我们需要将这个配置写到这个实现类中，比如：</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-java" data-lang="java"><pre><code class="highlight java"><span class="meta">@Override</span><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;  http.requestMatchers(matcher -&gt; matcher.mvcMatchers(<span class="string">"/hello"</span>));&#125;</code></pre></code></pre></div></div><div class="paragraph"><p>这样，<code>FilterChainProxy</code> 就知道了对 <code>/hello</code> 的请求需要使用这个 <code>SecurityFilterChain</code>。</p></div></div><div class="sect3"><h4 id="_向_securityfilterchain_加入_filter">向 SecurityFilterChain 加入 Filter</h4><div class="paragraph"><p>现在有了对应的 <code>SecurityFilterChain</code>，我们就可以将自定义的 <code>Filter</code> 加入到这个 chain 中：</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-java" data-lang="java"><pre><code class="highlight java"><span class="meta">@Override</span><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;  http.addFilter(HelloFilter<span class="class">.<span class="keyword">class</span>)</span>;&#125;</code></pre></code></pre></div></div><div class="paragraph"><p><code>addFilter</code> 方法也有一些变体，可以控制 <code>Filter</code> 在 chain 中的位置，这里就不赘述了。</p></div></div><div class="sect3"><h4 id="_添加_authenticationprovider">添加 AuthenticationProvider</h4><div class="paragraph"><p>与 <code>Filter</code> 一样，<code>AuthenticationProvider</code> 也是被安排到单独的 <code>FilterChainProxy</code> 中的，并且需要自己配置。如果你的自定义 <code>Filter</code> 需要 <code>AuthenticationProvider</code> 的话，同样需要配置：</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-java" data-lang="java"><pre><code class="highlight java"><span class="meta">@Override</span><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;  auth.authenticationProvider(HelloAuthenticationProvider<span class="class">.<span class="keyword">class</span>)</span>;&#125;</code></pre></code></pre></div></div></div></div></div></div><div class="sect1"><h2 id="_总结">总结</h2><div class="sectionbody"><div class="paragraph"><p>这篇文章比较详细的梳理了 <code>AbstractAuthenticationProcessingFilter</code> 及其子类 <code>UsernamePasswordAuthenticationFilter</code> 的实现和 <code>BasicAuthenticationFilter</code> 的实现，了解了需要实现自定义身份验证的 <code>Filter</code> 时应该选择哪种方式：</p></div><div class="ulist"><ul><li><p>只是进行身份验证，完成后进行重定向，而不调用业务方法，那么就继承 <code>AbstractAuthenticationProcessFilter</code></p></li><li><p>需要调用业务方法，身份验证是为了保护业务，那么就继承 <code>OncePerRequestFilter</code>，完全控制认证的流程</p></li></ul></div><div class="quoteblock"><blockquote><div class="paragraph"><p>当然，这不是一个强制的限制，你仍然可以通过重写 <code>AbstractAuthenticationProcessFilter.successfulAuthentication()</code> 方法来修改重定向的行为。</p></div></blockquote></div><div class="paragraph"><p>另外，也了解到了实现完 <code>Filter</code> 后，需要实现 <code>WebSecurityConfigurerAdapter</code>，将 <code>Filter</code> 加入到 <code>SecurityFilterChain</code> 中。</p></div><div class="quoteblock"><blockquote><div class="paragraph"><p>查看系列文章： <a href="/spring-security-servlet/">点这里</a></p></div></blockquote></div></div></div>]]></content:encoded>
      
      <comments>https://blog.gaoyuexiang.cn/2020/06/07/spring-security-authentication/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Spring Security Servlet 概览</title>
      <link>https://blog.gaoyuexiang.cn/2020/05/31/spring-security-servlet-overview/</link>
      <guid>https://blog.gaoyuexiang.cn/2020/05/31/spring-security-servlet-overview/</guid>
      <pubDate>Sun, 31 May 2020 19:58:38 GMT</pubDate>
      <description>
      
        &lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Spring Security 是 Spring 框架中用于实现 Security 相关需求的项目。我们可以通过使用这个框架来实现项目中的安全需求。&lt;/p&gt;
&lt;/div&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<div class="paragraph"><p>Spring Security 是 Spring 框架中用于实现 Security 相关需求的项目。我们可以通过使用这个框架来实现项目中的安全需求。</p></div><div class="paragraph"><p>今天这篇文章将会讨论 Spring Security Servlet 是如何工作的。</p></div><div class="paragraph"><p>之所以将内容限定到 Servlet，是因为现在 Spring Security 已经开始支持 Reactive Web Server，因为底层的技术不同，当然需要分开讨论。</p></div><div class="sect1"><h2 id="_spring_security_在哪里生效">Spring Security 在哪里生效</h2><div class="sectionbody"><div class="paragraph"><p>我们知道，在 Servlet 中，一次请求会经过这样的阶段: client &#8594; servlet container &#8594; filter &#8594; servlet</p></div><div class="paragraph"><p>而 Spring MVC 虽然引入了一些其他概念，但整体流程差别不大：</p></div><div class="imageblock center"><div class="content"><img src="filter-and-interceptor.png" alt="filter and interceptor"></div></div><div class="paragraph"><p>Spring Security 则是通过实现了 <code>Filter</code> 来实现的 Security 功能。这样一来，只要使用了 Servlet Container，就可以使用 Spring Security，不需要关心有没有使用 Spring Web 或别的 Spring 项目。</p></div><div class="sect2"><h3 id="_delegatingfilterproxy">DelegatingFilterProxy</h3><div class="paragraph"><p>这是 Spring Security 实现的一个 Servlet Filter。它被加入到 Servlet Filter Chain 中，将 filter 的任务桥接给 Spring Context 管理的 bean。</p></div><div class="sect3"><h4 id="_filterchainproxy">FilterChainProxy</h4><div class="paragraph"><p>这是被 <code>DelegatingFilterProxy</code> 封装的一个 <code>Filter</code>，其实也是一个代理。这个类维护了一个 <code>List&lt;SecurityFilterChain&gt;</code>，它会将请求代理给这个 list 进行 filter 的工作。</p></div><div class="paragraph"><p>但这个代理不是遍历整个 list，而是通过 <code>RequestMatcher</code> 来判断是否要使用这一个 <code>SecurityFilterChain</code>。我们配置时写的 <code>mvcMatchers</code> 之类的方法就会影响到这里的判断。</p></div><div class="sect4"><h5 id="_securityfilterchain">SecurityFilterChain</h5><div class="paragraph"><p>这个接口的实现维护了一个 <code>Filter</code> 列表，这些 <code>Filter</code> 是真正进行 filter 工作的类，比如 <code>CorsFilter</code>、<code>UsernamePasswordAuthenticationFilter</code> 等。</p></div><div class="paragraph"><p>上面提到的 <code>RequestMatcher</code> 是这个接口的默认实现使用的。</p></div><div class="paragraph"><p>综上，我们可以得到一个 big picture：</p></div><div class="imageblock center"><div class="content"><img src="multi-securityfilterchain.png" alt="multi securityfilterchain"></div></div></div></div></div><div class="sect2"><h3 id="_处理_security_exception">处理 Security Exception</h3><div class="paragraph"><p>这里说的 Security Exception，其实只有两种：<code>AuthenticationException</code> 和 <code>AccessDeniedException</code>。它们会在 <code>ExceptionTranslationFilter</code> 中被处理，而这个 Filter 往往被安排在 <code>SecurityFilterChain</code> 的最后。</p></div><div class="sect3"><h4 id="_authenticationexception">AuthenticationException</h4><div class="paragraph"><p>这个异常代表身份认证失败。<code>ExceptionTranslationFilter</code> 会调用 <code>startAuthentication</code> 方法处理它，其流程是：</p></div><div class="olist arabic"><ol class="arabic"><li><p>清理 <code>SecurityContextHolder</code> 中的身份信息（后面的身份认证内容会涉及）</p></li><li><p>将当前请求保存到 <code>RequestCache</code> 中，当用户通过身份验证后，会从其中取出当前请求，继续业务流程</p></li><li><p>调用 <code>AuthenticationEntryPoint</code>，要求用户提供身份信息。方式可以是重定向到登陆页面，也可以是返回携带 <code>WWW-Authenticate</code> header 的 HTTP 响应</p></li></ol></div></div><div class="sect3"><h4 id="_accessdeniedexception">AccessDeniedException</h4><div class="paragraph"><p>这个异常代表权限验证失败，意味着当前用户的身份已确认，但被服务拒绝了请求。</p></div><div class="paragraph"><p><code>ExceptionTranslationFilter</code> 会将这个异常交给 <code>AccessDeniedHanlder</code> 处理。默认的实现会重定向到 <code>/error</code>，并得到一个 403 响应。</p></div><hr><div class="paragraph"><p>了解了 Spring Security 在哪里生效之后，我们再来看看两个重要的问题：身份认证和权限验证。</p></div></div></div></div></div><div class="sect1"><h2 id="_身份认证">身份认证</h2><div class="sectionbody"><div class="sect2"><h3 id="_securitycontextholder">SecurityContextHolder</h3><div class="paragraph"><p><code>SecurityContextHolder</code> 是保存身份信息的地方，默认通过 <code>ThreadLocal</code> 的方式保存 <code>SecurityContext</code>。可以通过静态方法 <code>SecurityContextHolder.getSecurityContext()</code> 获取当前线程的 <code>SecurityContext</code>。</p></div><div class="quoteblock"><blockquote><div class="paragraph"><p><code>SecurityContextHolder.getSecurityContext()</code> 方法虽然是静态的，可以在任何地方调用。但个人不建议这么做，而是应该作为参数传递给使用到的方法，避免当前的 <code>SecurityContext</code> 成为隐式输入。</p></div></blockquote></div><div class="paragraph"><p><code>SecurityContext</code> 是一个接口，提供 <code>getAuthentication</code> 方法获取当前用户信息；<code>setAuthentication</code> 设置当前用户信息。</p></div><div class="paragraph"><p><code>Authentication</code> 也是一个接口，它的实现保存了当前用户的信息。在身份验证的流程中，总是在围绕着 <code>Authentication</code> 操作 —— 通过 <code>Principal</code> 和 <code>Credentials</code> 判断用户身份、通过调用 <code>setAuthenticated</code> 方法保存身份认证是否通过的结果。</p></div><div class="paragraph"><p>另外，在身份验证成功后，<code>Authentication</code> 中还保存了 <code>GrantedAuthority</code> 的集合，表示当前用户的角色和权限，用于后续的权限验证操作。</p></div><div class="imageblock center"><div class="content"><img src="securitycontextholder.png" alt="securitycontextholder"></div></div></div><div class="sect2"><h3 id="_authenticationmanager">AuthenticationManager</h3><div class="paragraph"><p><code>AuthenticationManager</code> 提供了 <code>authenticate()</code> 方法用于进行身份验证，但并不是它自己完成，而是通过 <code>AuthenticationProvider</code> 完成。</p></div><div class="paragraph"><p><code>AuthenticationProvider</code> 提供 <code>support(Authentication)</code> 方法用于判断是否能够验证这种类型的 <code>Authentication</code>。</p></div><div class="paragraph"><p>在 <code>AuthenticationManager</code> 的实现 <code>ProviderManager</code> 中保存了 <code>List&lt;AuthenticationProvider&gt;</code>。它会按顺序调用支持当前 <code>Authentication</code> 类型的 <code>AuthenticationProvider</code> 的 <code>authenticate</code> 方法，直到身份验证成功（返回值 non-null）或全部失败。</p></div><div class="paragraph"><p>在这个过程中出现的 <code>AuthenticationException</code> 将会被上面提到的 <code>ExceptionTranslationFilter</code> 处理。</p></div></div><div class="sect2"><h3 id="_abstractauthenticationprocessingfilter">AbstractAuthenticationProcessingFilter</h3><div class="paragraph"><p><code>AbstractAuthenticationProcessingFilter.doFilter()</code> 方法实现了身份验证的流程，包括成功和失败的处理。</p></div><div class="paragraph"><p>它提供了一个抽象方法 <code>attemptAuthentication()</code> 用于身份验证。子类可以调用它的 <code>authenticationManager</code> 来实现 <code>authenticate</code> 的功能。</p></div><div class="paragraph"><p>整体流程如图：</p></div><div class="imageblock center"><div class="content"><img src="abstractauthenticationprocessingfilter.png" alt="abstractauthenticationprocessingfilter"></div></div><div class="paragraph"><p>其中的 <code>1</code> &amp; <code>2</code> 都在 <code>attemptAuthentication()</code> 方法中完成，需要子类实现。</p></div><div class="paragraph"><p><code>3</code> 通过 <code>successfulAuthentication()</code> 方法实现，可以被子类重写。</p></div><div class="paragraph"><p><code>4</code> 中除 <code>SessionAuthenticationStrategy</code> 外都交给 <code>unsuccessfulAuthentication()</code> 方法处理，同样可以被子类重写。</p></div><div class="quoteblock"><blockquote><div class="paragraph"><p>考虑到越来越多的应用都是基于无状态的 <code>RESTful</code> API，所以 <code>SessionAuthenticationStrategy</code> 不会在本文涉及</p></div></blockquote></div></div></div></div><div class="sect1"><h2 id="_权限验证">权限验证</h2><div class="sectionbody"><div class="sect2"><h3 id="_在_servlet_中权限验证">在 Servlet 中权限验证</h3><div class="paragraph"><p>Spring Security 权限验证的入口有很多处，关注到 Servlet 上的话，那就是 <code>FilterSecurityInterceptor</code> 这个 <code>Filter</code>。他会被配置到所有的 <code>AbstractAuthenticationProcessingFilter</code> 子类之后，这样他就能从 <code>SecurityContextHodler</code> 中得到 <code>Authentication</code>，用以进行权限验证。</p></div><div class="sect3"><h4 id="_accessdecisionmanager">AccessDecisionManager</h4><div class="paragraph"><p>权限验证的过程，被交给 <code>AccessDecisionManager</code> 实现，他的 <code>decide</code> 方法接收三个参数：</p></div><div class="ulist"><ul><li><p><code>Authentication</code>：这就是从 <code>SecurityContextHolder</code> 中拿到的对象</p></li><li><p>secureObject：这是一个 Object 类型，对于 <code>FilterSecurityIntercepter</code> 来说，会用 request、response 和 filterChain 创建一个 <code>FilterInvocation</code> 对象作为 secureObject</p></li><li><p><code>Collection&lt;ConfigAttribute&gt;</code>： <code>FilterSecurityIntercepter</code> 使用 <code>ExpressionBasedFilterInvocationSecurityMetadataSource</code> 保存这些 <code>ConfigAttribute</code>，这些值用来给 <code>AccessDecisionManager</code> 提供做判断的信息</p></li></ul></div><div class="paragraph"><p><code>AccessDecisionManager</code> 自然也不是包含具体的判断逻辑的角色，真正根据上面三个参数来进行权限验证的类，其实是 <code>AccessDecisionVoter</code>。</p></div></div><div class="sect3"><h4 id="_accessdecisionvoter">AccessDecisionVoter</h4><div class="paragraph"><p><code>AccessDecisionVoter</code> 提供一个 <code>vote</code> 方法，接收上面的 <code>decide</code> 方法一样的参数。</p></div><div class="paragraph"><p>他的实现包括 <code>RoleVoter</code> 和 <code>AuthenticationVoter</code>。顾名思义，分别是根据角色和权限信息来判断是否通过权限验证的实现。而<em>什么样的角色/权限可以访问这个对象</em>则是通过 <code>ConfigAttribute</code> 传入的。</p></div><div class="paragraph"><p>不管具体的 Voter 实现如何，最终会返回一个 <code>int</code>，只有 -1、0、1 三个值，分别表示拒绝、弃权、同意。</p></div><div class="paragraph"><p>一个 <code>AccessDecisionManager</code> 会管理多个 <code>AccessDecisionVoter</code>，最终会根据所有 voter 的结果来判断是验证成功，还是抛出 <code>AccessDeniedException</code>。</p></div><div class="paragraph"><p>具体判断的策略则是交给了 <code>AccessDecisionManager</code> 的三个实现来决定：</p></div><div class="dlist"><dl><dt class="hdlist1">ConsensusBased</dt><dd><p>像一般的比赛投票一样，票多的结果就是最终决定。可以配置票数相等（不是全部弃权）时，结果是否通过，默认值是允许通过。也可以配置全部弃权时，结果是否通过，默认值是不允许。</p></dd><dt class="hdlist1">AffirmativeBased</dt><dd><p>只要有一个 voter 同意，就允许通过。同样可以配置全部弃权时的决定，默认也是不允许。</p></dd><dt class="hdlist1">UnanimousBased</dt><dd><p>要求所有 voter 一致同意时才通过。同样可以配置全部弃权时的决定，默认也是不允许。</p></dd></dl></div><div class="paragraph"><p><code>AccessDecisionManager</code> 与 <code>AccessDecisionVoter</code> 的关系：</p></div><div class="imageblock center"><div class="content"><img src="access-decision-voting.png" alt="access decision voting"></div></div></div></div><div class="sect2"><h3 id="_abstractsecurityinterceptor">AbstractSecurityInterceptor</h3><div class="paragraph"><p>到此，权限验证用到的核心类基本介绍完了，让我们回过头来想一个问题：<code>FilterSecurityInterceptor</code> 明明是一个 <code>Filter</code>，为什么要叫做 <code>Interceptor</code>？</p></div><div class="paragraph"><p>如果回顾上面介绍的这些类，你会发现只有 <code>FilterSecurityInterceptor</code> 通过实现 <code>Filter</code> 接口和 Servlet 绑定了起来，<code>AccessDecisionManager</code> 和 <code>AccessDecisionVoter</code> 都没有和 Servlet 绑定。</p></div><div class="paragraph"><p>这么做的目的就是为了能支持 Method Security 和 AspectJ Security，这样就能复用真正做权限验证逻辑的代码。</p></div><div class="paragraph"><p>我们可以看到 <code>FilterSecurityInterceptor</code> 扩展了 <code>AbstractSecurityInterceptor</code>。而这个父类的另外两个实现 <code>MethodSecurityInterceptor</code> 和 <code>AspectJMethodSecurityInterceptor</code> 都是非 Servlet 的实现。由此便做到了对不同的权限验证方式的支持，并且复用了代码。</p></div><hr><div class="paragraph"><p>关于权限验证，还有一个很重要的 ACL 没有提到，它并没有影响整个权限验证的架构，这里就不写了，以后有空再说吧。</p></div></div></div></div><div class="sect1"><h2 id="_总结">总结</h2><div class="sectionbody"><div class="paragraph"><p>这篇文章梳理了 Spring Security 在 Servlet 中的代码架构，构建了一个 big picture。</p></div><div class="paragraph"><p>通过这篇文章，我们了解到，在请求到达真正处理业务的 Controller 之前，经历了：</p></div><div class="ulist"><ul><li><p>各种 <code>AbstractAuthenticationProcessingFilter</code> 过滤请求，交给 <code>AuthenticationManager</code> 管理的 <code>AuthenticationProvider</code> 尝试不同的身份认证方式</p><div class="ulist"><ul><li><p>最终得到一个保存在 <code>SecurityContextHolder</code> 中的 <code>Authentication</code> 对象</p></li><li><p>或者无法确定身份的情况下抛出 <code>AuthenticationException</code></p></li></ul></div></li><li><p>被 <code>FilterSecurityInterceptor</code> 过滤，使用先前创建的 <code>Authentication</code> 对象交给 <code>AccessDecisionManager</code> 进行权限验证</p><div class="ulist"><ul><li><p>最终成功调用业务方法</p></li><li><p>或者抛出 <code>AccessDeniedException</code></p></li></ul></div></li><li><p>上面抛出的 <code>AuthenticationException</code> 和 <code>AccessDeniedException</code> 将会被 <code>ExceptionTranslationFilter</code> 处理，转化成 401 和 403 的响应。</p></li></ul></div><div class="imageblock center"><div class="content"><img src="securityarch.png" alt="securityarch"></div></div><div class="paragraph"><p>有了这个 big picture，在接下来研究细节的时候，就不至于摸不着头脑了。</p></div><div class="quoteblock"><blockquote><div class="paragraph"><p>查看系列文章： <a href="/spring-security-servlet/">点这里</a></p></div></blockquote></div></div></div>]]></content:encoded>
      
      <comments>https://blog.gaoyuexiang.cn/2020/05/31/spring-security-servlet-overview/#disqus_thread</comments>
    </item>
    
    <item>
      <title>使用 Gradle 的 Java 插件构建 Java 项目</title>
      <link>https://blog.gaoyuexiang.cn/2020/02/24/use-gradle-to-build-java-project/</link>
      <guid>https://blog.gaoyuexiang.cn/2020/02/24/use-gradle-to-build-java-project/</guid>
      <pubDate>Mon, 24 Feb 2020 21:09:31 GMT</pubDate>
      <description>
      
        &lt;p&gt;在&lt;a href=&quot;https://blog.gaoyuexiang.cn/2020/02/22/use-gradle-to-build-java-project-without-plugin/&quot;&gt;上一篇文章&lt;/a&gt;中，我们在没有使用任何插件的情况下，练习了使用 &lt;code&gt;Gradle&lt;/code&gt; 构建 &lt;code&gt;Java&lt;/code&gt; 项目，最后得到一个脆弱的构建脚本和不符合约定的目录结构。&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>在<a href="https://blog.gaoyuexiang.cn/2020/02/22/use-gradle-to-build-java-project-without-plugin/">上一篇文章</a>中，我们在没有使用任何插件的情况下，练习了使用 <code>Gradle</code> 构建 <code>Java</code> 项目，最后得到一个脆弱的构建脚本和不符合约定的目录结构。</p><p>对此，<code>Gradle</code> 使用了插件来解决这些问题。</p><h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><p><code>Gradle</code> 中的插件，可以给我们带来很多好处，包括：</p><ol><li>添加 <code>Task</code></li><li>添加领域对象</li><li>约定优于配置的实现</li><li>扩展 <code>Gradle</code> 的核心类</li></ol><p><code>Gradle</code> 将插件分为两类，<code>Script Plugin</code> &amp; <code>Binary Plugin</code>。</p><p>那些写到单独的 <code>gradle</code> 文件中，并被 <code>build.gradle</code> 文件使用的脚本文件，就是 <code>Script Plugin</code>。常见的实践是将某一插件或某一方面的配置写到单独的文件中，比如 <code>jacoco.gradle</code>，然后通过下面的语法导入到 <code>build.gradle</code> 文件中：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="keyword">from</span>: <span class="keyword">file</span>(<span class="string">"$projectDir/gradle/jacoco.gradle"</span>)</span><br></pre></td></tr></table></figure><p>而常见的 <code>java</code>、<code>idea</code> 这样的 <code>core Plugin</code> 和 <code>org.springframework.boot</code> 等可以在 <a href="https://plugins.gradle.org/" target="_blank" rel="noopener">https://plugins.gradle.org/</a> 找到的插件，就是 <code>Binary Plugin</code>，它们通过 <code>plugins{}</code> 语法块引入：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">  id <span class="string">'java'</span></span><br><span class="line">  id <span class="string">'org.springframework.boot'</span> version <span class="string">'2.2.4.RELEASE'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>接下来，我们接着上一篇文章的例子，使用 <code>Java Plugin</code> 来改造我们的构建脚本。</p><h1 id="改造-Hello-World"><a href="#改造-Hello-World" class="headerlink" title="改造 Hello World"></a>改造 Hello World</h1><p><code>Java</code> 插件的文档：<a href="https://docs.gradle.org/current/userguide/java_plugin.html" target="_blank" rel="noopener">https://docs.gradle.org/current/userguide/java_plugin.html</a></p><h2 id="Import-Java-Plugin"><a href="#Import-Java-Plugin" class="headerlink" title="Import Java Plugin"></a>Import <code>Java</code> Plugin</h2><p>如上所述，我们使用 <code>Java Plugin</code> 需要先导入它：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">  id <span class="string">'java'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 <code>Java</code> 插件是 <code>Gradle</code> 提供的核心插件，它是和 <code>Gradle</code> 版本绑定的，所以不需要使用 <code>version</code> 参数。</p><h2 id="SourceSet"><a href="#SourceSet" class="headerlink" title="SourceSet"></a><code>SourceSet</code></h2><p>引入 <code>Java</code> 插件后，我们先来了解一个核心概念：<code>SourceSet</code>。这是 <code>Java</code> 插件引入的概念，每一个 <code>SourceSet</code> 都包含了一组相关的资源。默认情况下，一个 <code>SourceSet</code> 对应 <code>src</code> 目录下的一个目录，目录名称就是 <code>SourceSet</code> 的名称；目录下会有一个 <code>java</code> 目录和一个 <code>resources</code> 目录。根据约定，这两个目录分别是存放 <code>java</code> 文件的目录和存放配置等资源文件的目录。</p><p><code>SourceSet</code> 还有更多的信息可以配置，参见：<a href="https://docs.gradle.org/current/userguide/building_java_projects.html#sec:java_source_sets" target="_blank" rel="noopener">https://docs.gradle.org/current/userguide/building_java_projects.html#sec:java_source_sets</a></p><p><code>Java</code> 插件还默认配置好了两个 <code>SourceSet</code>，分别是 <code>main</code> &amp; <code>test</code>。所以在使用 <code>Java</code> 插件后，无需任何配置，就可以得到约定的目录结构：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">❯ tree src</span><br><span class="line">src</span><br><span class="line">├── main</span><br><span class="line">│   ├── java</span><br><span class="line">│   └── resources</span><br><span class="line">└── test</span><br><span class="line">    ├── java</span><br><span class="line">    └── resources</span><br></pre></td></tr></table></figure><p>所以，我们需要将 <code>HelloWorld.java</code> 从 <code>src</code> 目录移动到符合约定的 <code>src/main/java</code> 目录下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">❯ tree src</span><br><span class="line">src</span><br><span class="line">└── main</span><br><span class="line">    └── java</span><br><span class="line">        └── HelloWorld.java</span><br></pre></td></tr></table></figure><h2 id="Task"><a href="#Task" class="headerlink" title="Task"></a><code>Task</code></h2><h3 id="Java-插件引入的-Task"><a href="#Java-插件引入的-Task" class="headerlink" title="Java 插件引入的 Task"></a><code>Java</code> 插件引入的 <code>Task</code></h3><p>接着我们来看看 <code>Task</code> 需要做哪些修改。</p><p><code>Java</code> 插件引入了下面的这些 <code>Task</code>，并且添加了依赖关系：</p><p><img src="javaPluginTasks.png" alt=""></p><p>其中有四个 <code>task</code> 是由 <code>base plugin</code> 添加的：<code>clean</code>, <code>check</code>, <code>assemble</code> 和 <code>build</code>。</p><p>其中，<code>check</code>, <code>assemble</code> 和 <code>build</code> 是 <code>lifecycle task</code>，本身不执行任务，只是定义了执行它们时应该执行什么样的任务：</p><ul><li><code>check</code>：聚合所有进行验证操作的 <code>task</code> ，比如测试</li><li><code>assemble</code>：聚合所有会产生项目产出物的 <code>task</code>，比如打包</li><li><code>build</code>：聚合前面两个 <code>task</code></li></ul><p>其他的 <code>task</code> 中，很容易发现，<code>compileJava</code> 与 <code>compileTestJava</code>、<code>processResources</code> 与 <code>processTestResources</code>、<code>classes</code> 与 <code>testClasses</code> 命名类似。实际上，每一对 <code>task</code> 表达的是同样的含义，只是一个针对 <code>main sourceSet</code>，一个针对 <code>test sourceSet</code> 而已。如果你创建了一个自定义的 <code>SourceSet</code>，那 <code>Java</code> 插件会自动的添加 <code>compileSourceSetJava</code>、<code>processSourceSetResources</code> 和 <code>sourceSetClasses</code>，其中的 <code>sourceSet</code> 就是 <code>SourceSet.name</code>。</p><ul><li><code>compileJava</code>：编译该 <code>sourceSet</code>下的 <code>java</code> 文件</li><li><code>processResource</code>：将该 <code>sourceSet</code> 中的资源文件复制到 <code>build</code> 目录中</li><li><code>classes</code>：准备打包和执行需要的 <code>class</code> 文件和资源文件</li></ul><blockquote><p>注意，执行测试是 <code>test</code> 任务，它没有因为添加 <code>sourceSet</code> 而自动添加 <code>sourceSetTest</code> 方法。因为自定义的 <code>SourceSet</code> 不一定是组件测试之类的不同类别的测试。所以，如果你添加了这样的 <code>SourceSet</code>，需要自己手动编写 <code>Test</code> 类型的测试 <code>task</code>。</p></blockquote><h3 id="改进-Hello-World"><a href="#改进-Hello-World" class="headerlink" title="改进 Hello World"></a>改进 Hello World</h3><p>由上面的了解可知，<code>Java</code> 插件已经为我们添加了 <code>compileJava</code> 和 <code>jar</code> 这两个 <code>task</code>，所以我们不需要再创建这样的 <code>task</code>。但是我们还是可以对这些 <code>task</code> 进行配置。</p><p>比如，我们仍然希望控制 <code>jar</code> 产出的文件名，那我们的脚本就可以改成这样：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task compileJava(type: JavaCompile) &#123;</span></span><br><span class="line"><span class="comment">//   source fileTree("$projectDir/src")</span></span><br><span class="line"><span class="comment">//   include "**/*.java"</span></span><br><span class="line"><span class="comment">//   destinationDir = file("$&#123;buildDir&#125;/classes")</span></span><br><span class="line"><span class="comment">//   sourceCompatibility = '1.8'</span></span><br><span class="line"><span class="comment">//   targetCompatibility = '1.8'</span></span><br><span class="line"><span class="comment">//   classpath = files("$&#123;buildDir&#125;/classes", configurations.forHelloWorld)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// tasks.create('jar', Jar)</span></span><br><span class="line"></span><br><span class="line">jar &#123;</span><br><span class="line">  archiveBaseName = <span class="string">'base-name'</span></span><br><span class="line">  archiveAppendix = <span class="string">'appendix'</span></span><br><span class="line">  archiveVersion = <span class="string">'0.0.1'</span></span><br><span class="line"><span class="comment">//   from compileJava.outputs</span></span><br><span class="line"><span class="comment">//   include "**/*.class"</span></span><br><span class="line">  manifest &#123;</span><br><span class="line">    attributes(<span class="string">"something"</span>: <span class="string">"value"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//   setDestinationDir file("$buildDir/lib")</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中注释的部分可以删除，这里仅仅作为修改前后的对比。</p><p>根据 <code>assemble</code> 的定义，我们的 <code>fatJar</code> 的输出应当看作项目的产出物，所以需要让 <code>assemble</code> 依赖于 <code>fatJar</code> ：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assemble.dependsOn fatJar</span><br></pre></td></tr></table></figure><h2 id="Dependency-Configuration"><a href="#Dependency-Configuration" class="headerlink" title="Dependency Configuration"></a><code>Dependency Configuration</code></h2><h3 id="Java-插件引入的-Configuration"><a href="#Java-插件引入的-Configuration" class="headerlink" title="Java 插件引入的 Configuration"></a><code>Java</code> 插件引入的 <code>Configuration</code></h3><p>上一篇文章讲到，在 <code>Gradle</code> 中声明依赖，需要关联到 <code>configuration</code>。<code>Java</code> 插件也提前为我们设计了一些 <code>configuration</code>，他们的主要关系可以通过两幅图来表示。</p><p>与 <code>main sourceSet</code> 相关的：</p><p><img src="java-main-configurations.png" alt=""></p><p>其中：</p><ol><li>灰色文字表示已经被废弃的 <code>configuration</code></li><li>绿色表示用于声明依赖的 <code>configuration</code></li><li>蓝灰色表示给 <code>task</code> 使用的 <code>configuration</code></li><li>浅蓝色表示 <code>task</code></li></ol><p>由这个图，我们就能看出声明到不同 <code>configuration</code> 中的依赖最终会在什么地方使用到。</p><p>与 <code>test sourceSet</code> 相关的：</p><p><img src="java-test-configurations.png" alt=""></p><p>其中的字体和颜色与上一张图一致。</p><p>我们可以看到，除去 <code>compile</code>, <code>implementation</code>, <code>runtime</code> 和 <code>rumtimeOnly</code>，其他的 <code>configuration</code> 与上图几乎一致。这里画出他们，仅仅是为了展示出扩展关系而已。</p><blockquote><p>如果你使用过以前版本的 <code>Gradle</code>，想必会比较好奇为什么 <code>Compile</code> 会被废弃。这其实是出于构建工具的性能的考虑，关闭掉不必要的传递依赖。</p></blockquote><p>你也许也发现了，和 <code>task</code> 一样，有一些名称相近的 <code>configuration</code>，所以很自然的推测：添加了自定义的 <code>SourceSet</code> 后，<code>Java</code> 插件会自动的添加一些 <code>configuration</code>。这些 <code>sourceSet configuration</code> 都可以在 <code>Java</code> 插件的页面上找到。</p><h3 id="改进-Hello-World-1"><a href="#改进-Hello-World-1" class="headerlink" title="改进 Hello World"></a>改进 Hello World</h3><p>首先，我们可以直接使用 <code>Java</code> 插件提供的 <code>implementation</code>，而不需要自己创建任何 <code>configuration</code>:</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// configurations &#123;</span></span><br><span class="line"><span class="comment">//   forHelloWorld</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">  <span class="comment">// forHelloWorld group: 'com.google.guava', name: 'guava', version: '28.2-jre'</span></span><br><span class="line">  implementation <span class="keyword">group</span>: <span class="string">'com.google.guava'</span>, name: <span class="string">'guava'</span>, version: <span class="string">'28.2-jre'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，注释只是为了对比。</p><p>接着，我们的 <code>fatJar</code> 也不能再使用 <code>forHelloWorld</code> 这个 <code>configuration</code>，但也不能直接使用 <code>implementation</code>，而应该使用 <code>runtimeClasspath</code> 这个给 <code>task</code> 消费的、语义更符合我们使用目标的 <code>configuration</code>：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span>(<span class="string">'fatJar'</span>, type: Jar) &#123;</span><br><span class="line">  archiveBaseName = <span class="string">'base-name'</span></span><br><span class="line">  archiveAppendix = <span class="string">'appendix'</span></span><br><span class="line">  archiveVersion = <span class="string">'0.0.1'</span></span><br><span class="line">  archiveClassifier = <span class="string">'boot'</span></span><br><span class="line">  <span class="keyword">from</span> compileJava</span><br><span class="line">  <span class="comment">// from configurations.forHelloWorld.collect &#123;</span></span><br><span class="line">  <span class="keyword">from</span> <span class="keyword">configurations</span>.rumtimeClasspath.<span class="keyword">collect</span> &#123;</span><br><span class="line">    it.isDirectory() ? it : zipTree(it)</span><br><span class="line">  &#125;</span><br><span class="line">  manifest &#123;</span><br><span class="line">    attributes <span class="string">"Main-Class"</span>: <span class="string">"HelloWorld"</span></span><br><span class="line">  &#125;</span><br><span class="line">  setDestinationDir <span class="keyword">file</span>(<span class="string">"$buildDir/libs"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>经过使用 <code>Java</code> 插件，并对构建脚本的修改，我们得到了更具有鲁棒性、实现了约定优于配置的构建脚本。</p><p>完整的脚本如下：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">  id <span class="string">'java'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">repositories</span> &#123;</span><br><span class="line">  mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">  implementation <span class="keyword">group</span>: <span class="string">'com.google.guava'</span>, name: <span class="string">'guava'</span>, version: <span class="string">'28.2-jre'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">compileJava.<span class="keyword">doLast</span> &#123;</span><br><span class="line">  <span class="keyword">println</span> <span class="string">'compile success!'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jar &#123;</span><br><span class="line">  archiveBaseName = <span class="string">'base-name'</span></span><br><span class="line">  archiveAppendix = <span class="string">'appendix'</span></span><br><span class="line">  archiveVersion = <span class="string">'0.0.1'</span></span><br><span class="line">  manifest &#123;</span><br><span class="line">    attributes(<span class="string">"something"</span>: <span class="string">"value"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">task</span>(<span class="string">'fatJar'</span>, type: Jar) &#123;</span><br><span class="line">  archiveBaseName = <span class="string">'base-name'</span></span><br><span class="line">  archiveAppendix = <span class="string">'appendix'</span></span><br><span class="line">  archiveVersion = <span class="string">'0.0.1'</span></span><br><span class="line">  archiveClassifier = <span class="string">'boot'</span></span><br><span class="line">  <span class="keyword">from</span> compileJava</span><br><span class="line">  <span class="keyword">from</span> <span class="keyword">configurations</span>.runtimeClasspath.<span class="keyword">collect</span> &#123;</span><br><span class="line">    it.isDirectory() ? it : zipTree(it)</span><br><span class="line">  &#125;</span><br><span class="line">  manifest &#123;</span><br><span class="line">    attributes <span class="string">"Main-Class"</span>: <span class="string">"HelloWorld"</span></span><br><span class="line">  &#125;</span><br><span class="line">  setDestinationDir <span class="keyword">file</span>(<span class="string">"$buildDir/libs"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">assemble.dependsOn(fatJar)</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://blog.gaoyuexiang.cn/2020/02/24/use-gradle-to-build-java-project/#disqus_thread</comments>
    </item>
    
    <item>
      <title>使用 Gradle 但不使用 Java 插件构建 Java 项目</title>
      <link>https://blog.gaoyuexiang.cn/2020/02/22/use-gradle-to-build-java-project-without-plugin/</link>
      <guid>https://blog.gaoyuexiang.cn/2020/02/22/use-gradle-to-build-java-project-without-plugin/</guid>
      <pubDate>Sat, 22 Feb 2020 23:42:35 GMT</pubDate>
      <description>
      
        &lt;p&gt;本文目标是探索在没有使用任何额外插件的情况下，如何使用 &lt;code&gt;Gradle&lt;/code&gt; 构建一个 &lt;code&gt;Java&lt;/code&gt; 项目，以此对比使用 &lt;code&gt;Java&lt;/code&gt; 插件时得到的好处。&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>本文目标是探索在没有使用任何额外插件的情况下，如何使用 <code>Gradle</code> 构建一个 <code>Java</code> 项目，以此对比使用 <code>Java</code> 插件时得到的好处。</p><h1 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h1><p>使用 <code>Gradle Init</code> 插件提供的 <code>init</code> task 来创建一个 <code>Gradle</code> 项目：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradle init --type basic --dsl groovy --project-name gradle-demo</span><br></pre></td></tr></table></figure><p>运行完成后，我们将得到这些文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">❯ tree</span><br><span class="line">.</span><br><span class="line">├── build.gradle</span><br><span class="line">├── gradle</span><br><span class="line">│   └── wrapper</span><br><span class="line">│       ├── gradle-wrapper.jar</span><br><span class="line">│       └── gradle-wrapper.properties</span><br><span class="line">├── gradlew</span><br><span class="line">├── gradlew.bat</span><br><span class="line">└── settings.gradle</span><br></pre></td></tr></table></figure><p>接下来，我们将关注点放到 <code>build.gradle</code> 上面，这是接下来编写构建脚本的地方。</p><h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><p>首先，我们编写一个 <code>Java</code> 的 HelloWorld，做为业务代码的代表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Hello Wrold"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，将这个内容保存到 <code>src/HelloWorld.java</code> 文件中，不按照 <code>maven</code> 的约定来组织项目结构。</p><h1 id="编译-Java"><a href="#编译-Java" class="headerlink" title="编译 Java"></a>编译 Java</h1><p>接着，我们需要给我们的构建脚本添加任务来编译刚才写的 <code>Java</code> 文件。这里就需要使用到 <code>Task</code>。关于 <code>Task</code>，<code>Gradle</code> 上有比较详细的文档描述如何使用它：<a href="https://docs.gradle.org/current/dsl/org.gradle.api.Task.html#org.gradle.api.Task" target="_blank" rel="noopener">https://docs.gradle.org/current/dsl/org.gradle.api.Task.html#org.gradle.api.Task</a> &amp; <a href="https://docs.gradle.org/current/userguide/more_about_tasks.html。" target="_blank" rel="noopener">https://docs.gradle.org/current/userguide/more_about_tasks.html。</a></p><p>现在，我们可以创建一个 <code>JavaCompile</code> 类型的 <code>Task</code> 对象，命名为 <code>compileJava</code> ：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> compileJava(type: JavaCompile) &#123;</span><br><span class="line">  <span class="keyword">source</span> <span class="keyword">fileTree</span>(<span class="string">"$projectDir/src"</span>)</span><br><span class="line">  <span class="keyword">include</span> <span class="string">"**/*.java"</span></span><br><span class="line">  <span class="keyword">destinationDir</span> = <span class="keyword">file</span>(<span class="string">"$&#123;buildDir&#125;/classes"</span>)</span><br><span class="line">  <span class="keyword">sourceCompatibility</span> = <span class="string">'1.8'</span></span><br><span class="line">  <span class="keyword">targetCompatibility</span> = <span class="string">'1.8'</span></span><br><span class="line">  <span class="keyword">classpath</span> = files(<span class="string">"$&#123;buildDir&#125;/classes"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们：</p><ol><li>通过 <code>source</code> &amp; <code>include</code> 方法指定了要被编译的文件所在的目录和文件的扩展名</li><li>通过 <code>destinationDir</code> 指定了编译后的 <code>class</code> 文件的存放目录</li><li>通过 <code>sourceCompatibility</code> &amp; <code>targetCompatibility</code> 指定了源码的 <code>Java</code> 版本和 <code>class</code> 文件的版本</li><li>通过 <code>classpath</code> 指定了编译时使用的 <code>classpath</code></li></ol><p>那么，接下来我们就可以执行 <code>compileJava</code> 这个任务了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">❯ gradle compileJava</span><br><span class="line">❯ tree build</span><br><span class="line">build</span><br><span class="line">├── classes</span><br><span class="line">│   └── HelloWorld.class</span><br><span class="line">└── tmp</span><br><span class="line">    └── compileJava</span><br><span class="line">❯ <span class="built_in">cd</span> build/classes</span><br><span class="line">❯ java HelloWorld</span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure><p>我们可以看到，HelloWorld 已经编译成功，并且可以被正确执行。</p><h1 id="添加第三方依赖"><a href="#添加第三方依赖" class="headerlink" title="添加第三方依赖"></a>添加第三方依赖</h1><p>在实际的项目中，难免会使用到其他人开发的库。要使用别人开发的库，就需要添加依赖。在 <code>Gradle</code> 中添加依赖，需要做这样四个事情：</p><ol><li>申明 <code>repository</code></li><li>定义 <code>configuration</code></li><li>申明 <code>dependency</code></li><li>将 <code>dependency</code> 添加到 <code>classpath</code></li></ol><h2 id="申明-repository"><a href="#申明-repository" class="headerlink" title="申明 repository"></a>申明 <code>repository</code></h2><p>在 <code>Gradle</code> 中可以定义项目在哪些 <code>repository</code> 中寻找依赖，通过 <code>dependencies</code> 语法块申明：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">repositories</span> &#123;</span><br><span class="line">  mavenCentral()</span><br><span class="line">  maven &#123;</span><br><span class="line">    url <span class="string">'https://maven.springframework.org/release'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 <code>mavenCentral</code> 和 <code>jcenter</code> 是比较常见的两个仓库，所以 <code>Gradle</code> 提供了函数可以直接使用。而其他的仓库则需要自己指定仓库的地址。</p><p>申明了 <code>repository</code> 之后，<code>Gradle</code> 才会知道在哪里寻找申明的依赖。</p><h2 id="定义-configuration"><a href="#定义-configuration" class="headerlink" title="定义 configuration"></a>定义 <code>configuration</code></h2><p>如果你使用过 <code>maven</code> 的话，也许 <code>repository</code> 和 <code>dependency</code> 都能理解，但对 <code>configuration</code> 却可能感到陌生。</p><p><code>Configuration</code> 是一组为了完成一个具体目标的依赖的集合。那些需要使用依赖的地方，比如 <code>Task</code>，应该使用 <code>configuration</code>，而不是直接使用依赖。这个概念仅在依赖管理范围内适用。</p><p><code>Configuration</code> 还可以扩展其他 <code>configuration</code>，被扩展的 <code>configuration</code> 中的依赖，都将被传递到扩展的 <code>configuration</code> 中。</p><p>我们可以来创建给 HelloWorld 程序使用的 <code>configuration</code> ：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">configurations</span> &#123;</span><br><span class="line">  forHelloWorld</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义 <code>configuration</code> 仅仅需要定义名字，不需要进行其他配置。如果需要扩展，可以使用 <code>extendsFrom</code> 方法：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">configurations</span> &#123;</span><br><span class="line">  testHelloWorld.extendsFrom forHelloWorld</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="申明-dependency"><a href="#申明-dependency" class="headerlink" title="申明 dependency"></a>申明 <code>dependency</code></h2><p>申明 <code>dependency</code> 需要使用到上一步的 <code>configuration</code>，将依赖关联到一个 <code>configuration</code> 中：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">  forHelloWorld <span class="string">'com.google.guava:guava:28.2-jre'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这样的申明，在 <code>forHelloWorld</code> 这个 <code>configuration</code> 中就存在了 <code>guava</code> 这个依赖。</p><h2 id="将-dependency-添加到-classpath"><a href="#将-dependency-添加到-classpath" class="headerlink" title="将 dependency 添加到 classpath"></a>将 <code>dependency</code> 添加到 <code>classpath</code></h2><p>接下来，我们就需要将 <code>guava</code> 这个依赖添加到 <code>compileJava</code> 这个 <code>task</code> 的 <code>classpath</code> 中，这样我们在代码中使用的 <code>guava</code> 提供的代码就能在编译期被 <code>JVM</code> 识别到。</p><p>但就像在<a href="#定义-configuration">定义 <code>configuration</code></a> 中描述的那样，我们需要消费 <code>configuration</code> 以达到使用依赖的目的，而不能直接使用依赖。所以我们需要将 <code>compileJava.classpath</code> 修改成下面这样：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">classpath</span> = files(<span class="string">"$&#123;buildDir&#125;/classes"</span>, <span class="keyword">configurations</span>.forHelloWorld)</span><br></pre></td></tr></table></figure><h2 id="修改-HelloWorld"><a href="#修改-HelloWorld" class="headerlink" title="修改 HelloWorld"></a>修改 HelloWorld</h2><p>完成上面四步之后，我们就可以在我们的代码中使用 <code>guava</code> 的代码了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.collect.ImmutableMap;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWrold</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ImmutableMap.of(<span class="string">"Hello"</span>, <span class="string">"World"</span>)</span><br><span class="line">        .forEach((key, value) -&gt; System.out.println(key + <span class="string">" "</span> + value));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h1><p>前面已经了解过如何进行编译，接着我们来看看如何打包。</p><p><code>Java</code> 打包好之后，往往有两种类型的 <code>Jar</code>：</p><ol><li>一种是普通的 <code>Jar</code>，里面不包含自己的依赖，而是在 <code>Jar</code> 文件外的一个 <code>metadata</code> 文件申明依赖，比如 <code>maven</code> 中的 <code>pom.xml</code></li><li>另一种被称作 <code>fatJar</code> (or <code>uberJar</code>) ，里面已经包含了所有的运行时需要的 <code>class</code> 文件和 <code>resource</code> 文件。</li></ol><h2 id="创建普通的-Jar-文件"><a href="#创建普通的-Jar-文件" class="headerlink" title="创建普通的 Jar 文件"></a>创建普通的 <code>Jar</code> 文件</h2><p>在这个练习中，我们就只关注 <code>Jar</code> 本身，不关心 <code>metadata</code> 文件。</p><p>在这里，我们自然是要创建一个 <code>task</code>，类型就使用 <code>Jar</code> ：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">tasks.create(<span class="string">'jar'</span>, Jar)</span><br><span class="line"></span><br><span class="line">jar &#123;</span><br><span class="line">  archiveBaseName = <span class="string">'base-name'</span></span><br><span class="line">  archiveAppendix = <span class="string">'appendix'</span></span><br><span class="line">  archiveVersion = <span class="string">'0.0.1'</span></span><br><span class="line">  <span class="keyword">from</span> compileJava.outputs</span><br><span class="line">  <span class="keyword">include</span> <span class="string">"**/*.class"</span></span><br><span class="line">  manifest &#123;</span><br><span class="line">    attributes(<span class="string">"something"</span>: <span class="string">"value"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  setDestinationDir <span class="keyword">file</span>(<span class="string">"$buildDir/lib"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们：</p><ol><li>指定了 <code>archiveBaseName</code>, <code>archiveAppendix</code>, <code>archiveVersion</code> 属性，他们和 <code>archiveClassfier</code>, <code>archiveExtension</code> 将决定最后打包好的 <code>jar</code> 文件名</li><li>使用 <code>from</code> 方法，指定要从 <code>compileJava</code> 的输出中拷贝文件，这样就隐式的添加了 <code>jar</code> 对 <code>compileJava</code> 的依赖</li><li>使用 <code>include</code> 要求仅复制 <code>class</code> 文件</li><li>可以使用 <code>manifest</code> 给 <code>META-INF/MANIFEST.MF</code> 文件添加信息</li><li><code>setDestinationDir</code> 方法已经被标记为 <code>deprecated</code> 但没有替代的方法</li></ol><p>接着，我们就可以使用 <code>jar</code> 进行打包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">❯ gradle jar</span><br><span class="line">❯ tree build</span><br><span class="line">build</span><br><span class="line">├── classes</span><br><span class="line">│   └── HelloWorld.class</span><br><span class="line">├── lib</span><br><span class="line">│   └── base-name-appendix-0.0.1.jar</span><br><span class="line">└── tmp</span><br><span class="line">    ├── compileJava</span><br><span class="line">    └── jar</span><br><span class="line">        └── MANIFEST.MF</span><br><span class="line">        ❯ zipinfo build/lib/base-name-appendix-0.0.1.jar</span><br><span class="line">❯ zipinfo build/lib/base-name-appendix-0.0.1.jar</span><br><span class="line">Archive:  build/lib/base-name-appendix-0.0.1.jar</span><br><span class="line">Zip file size: 1165 bytes, number of entries: 3</span><br><span class="line">drwxr-xr-x  2.0 unx        0 b- defN 20-Feb-22 23:14 META-INF/</span><br><span class="line">-rw-r--r--  2.0 unx       43 b- defN 20-Feb-22 23:14 META-INF/MANIFEST.MF</span><br><span class="line">-rw-r--r--  2.0 unx     1635 b- defN 20-Feb-22 23:14 HelloWorld.class</span><br><span class="line">3 files, 1678 bytes uncompressed, 825 bytes compressed:  50.8%</span><br></pre></td></tr></table></figure><h2 id="创建-fatJar"><a href="#创建-fatJar" class="headerlink" title="创建 fatJar"></a>创建 <code>fatJar</code></h2><p>接着，同样使用 <code>Jar</code> 这个类型，我们创建一个 <code>fatJar</code> 任务：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span>(<span class="string">'fatJar'</span>, type: Jar) &#123;</span><br><span class="line">  archiveBaseName = <span class="string">'base-name'</span></span><br><span class="line">  archiveAppendix = <span class="string">'appendix'</span></span><br><span class="line">  archiveVersion = <span class="string">'0.0.1'</span></span><br><span class="line">  archiveClassifier = <span class="string">'boot'</span></span><br><span class="line">  <span class="keyword">from</span> compileJava</span><br><span class="line">  <span class="keyword">from</span> <span class="keyword">configurations</span>.forHelloWorld.<span class="keyword">collect</span> &#123;</span><br><span class="line">    it.isDirectory() ? it : zipTree(it)</span><br><span class="line">  &#125;</span><br><span class="line">  manifest &#123;</span><br><span class="line">    attributes <span class="string">"Main-Class"</span>: <span class="string">"HelloWorld"</span></span><br><span class="line">  &#125;</span><br><span class="line">  setDestinationDir <span class="keyword">file</span>(<span class="string">"$buildDir/lib"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比于 <code>jar</code>，我们的配置变更在于：</p><ol><li>添加 <code>archiveClassfier</code> 以区别 <code>fatJar</code> 和 <code>jar</code> 产生的不同 <code>jar</code> 文件</li><li>使用 <code>from</code> 将 <code>forHelloWorld</code> <code>configuration</code> 的依赖全部解压后拷贝到 <code>jar</code> 文件</li><li>指定 <code>Main-Class</code> 属性，以便直接运行 <code>jar</code> 文件</li></ol><p>然后我们再执行 <code>fatJar</code> :</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">❯ gradle fatJar</span><br><span class="line">❯ tree build</span><br><span class="line">build</span><br><span class="line">├── classes</span><br><span class="line">│   └── HelloWorld.class</span><br><span class="line">├── lib</span><br><span class="line">│   ├── base-name-appendix-0.0.1-boot.jar</span><br><span class="line">│   └── base-name-appendix-0.0.1.jar</span><br><span class="line">└── tmp</span><br><span class="line">    ├── compileJava</span><br><span class="line">    ├── fatJar</span><br><span class="line">    │   └── MANIFEST.MF</span><br><span class="line">    └── jar</span><br><span class="line">        └── MANIFEST.MF</span><br><span class="line">❯ java -jar build/lib/base-name-appendix-0.0.1-boot.jar</span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过练习在不使用 <code>Java Plugin</code> 的情况下，使用 <code>Gradle</code> 来构建项目，实现了编译源码、依赖管理和打包的功能，并得到了如下完整的 <code>gradle.build</code> 文件：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">repositories</span> &#123;</span><br><span class="line">  mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">configurations</span> &#123;</span><br><span class="line">  forHelloWorld</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">  forHelloWorld <span class="keyword">group</span>: <span class="string">'com.google.guava'</span>, name: <span class="string">'guava'</span>, version: <span class="string">'28.2-jre'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">task</span> compileJava(type: JavaCompile) &#123;</span><br><span class="line">  <span class="keyword">source</span> <span class="keyword">fileTree</span>(<span class="string">"$projectDir/src"</span>)</span><br><span class="line">  <span class="keyword">include</span> <span class="string">"**/*.java"</span></span><br><span class="line">  <span class="keyword">destinationDir</span> = <span class="keyword">file</span>(<span class="string">"$&#123;buildDir&#125;/classes"</span>)</span><br><span class="line">  <span class="keyword">sourceCompatibility</span> = <span class="string">'1.8'</span></span><br><span class="line">  <span class="keyword">targetCompatibility</span> = <span class="string">'1.8'</span></span><br><span class="line">  <span class="keyword">classpath</span> = files(<span class="string">"$&#123;buildDir&#125;/classes"</span>, <span class="keyword">configurations</span>.forHelloWorld)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">compileJava.<span class="keyword">doLast</span> &#123;</span><br><span class="line">  <span class="keyword">println</span> <span class="string">'compile success!'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tasks.create(<span class="string">'jar'</span>, Jar)</span><br><span class="line"></span><br><span class="line">jar &#123;</span><br><span class="line">  archiveBaseName = <span class="string">'base-name'</span></span><br><span class="line">  archiveAppendix = <span class="string">'appendix'</span></span><br><span class="line">  archiveVersion = <span class="string">'0.0.1'</span></span><br><span class="line">  <span class="keyword">from</span> compileJava.outputs</span><br><span class="line">  <span class="keyword">include</span> <span class="string">"**/*.class"</span></span><br><span class="line">  manifest &#123;</span><br><span class="line">    attributes(<span class="string">"something"</span>: <span class="string">"value"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  setDestinationDir <span class="keyword">file</span>(<span class="string">"$buildDir/lib"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">task</span>(<span class="string">'fatJar'</span>, type: Jar) &#123;</span><br><span class="line">  archiveBaseName = <span class="string">'base-name'</span></span><br><span class="line">  archiveAppendix = <span class="string">'appendix'</span></span><br><span class="line">  archiveVersion = <span class="string">'0.0.1'</span></span><br><span class="line">  archiveClassifier = <span class="string">'boot'</span></span><br><span class="line">  <span class="keyword">from</span> compileJava</span><br><span class="line">  <span class="keyword">from</span> <span class="keyword">configurations</span>.forHelloWorld.<span class="keyword">collect</span> &#123;</span><br><span class="line">    it.isDirectory() ? it : zipTree(it)</span><br><span class="line">  &#125;</span><br><span class="line">  manifest &#123;</span><br><span class="line">    attributes <span class="string">"Main-Class"</span>: <span class="string">"HelloWorld"</span></span><br><span class="line">  &#125;</span><br><span class="line">  setDestinationDir <span class="keyword">file</span>(<span class="string">"$buildDir/lib"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写了这么多构建脚本，仅仅完成了 <code>Java Plugin</code> 提供的一小点功能，伤害太明显。</p><p>完整的例子可以在这个 <code>repo</code> 的 <code>commit</code> 中找到 <a href="https://github.com/kbyyd24/gradle-practice" target="_blank" rel="noopener">https://github.com/kbyyd24/gradle-practice</a></p>]]></content:encoded>
      
      <comments>https://blog.gaoyuexiang.cn/2020/02/22/use-gradle-to-build-java-project-without-plugin/#disqus_thread</comments>
    </item>
    
    <item>
      <title>《微服务架构设计模式》读书总结</title>
      <link>https://blog.gaoyuexiang.cn/2020/02/01/microservice-arch-pattern/</link>
      <guid>https://blog.gaoyuexiang.cn/2020/02/01/microservice-arch-pattern/</guid>
      <pubDate>Sat, 01 Feb 2020 02:53:38 GMT</pubDate>
      <description>
      
        &lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;《微服务架构设计模式》这本书介绍了引入微服务架构后面临的挑战，提供了一些模式用于应对这些挑战。所有的模式都可以在 &lt;a href=&quot;https://microservices.io/patterns/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;作者的网站上找到&lt;/a&gt;，书上只是使用了更加具体的例子和更详细的语言来阐述而已。&lt;/p&gt;
&lt;/div&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<div class="paragraph"><p>《微服务架构设计模式》这本书介绍了引入微服务架构后面临的挑战，提供了一些模式用于应对这些挑战。所有的模式都可以在 <a href="https://microservices.io/patterns/index.html" target="_blank" rel="noopener">作者的网站上找到</a>，书上只是使用了更加具体的例子和更详细的语言来阐述而已。</p></div><div class="paragraph"><p>本文是个人的读书总结，不是系统的知识梳理，<strong>慎读</strong>。</p></div><div class="sect1"><h2 id="_模式">模式</h2><div class="sectionbody"><div class="paragraph"><p>为了解决特定条件下的问题的固定解决方案称为<strong>模式</strong>。</p></div><div class="paragraph"><p>另一个词，<strong>模式语言</strong> 是指在特定领域内相关的模式的集合。</p></div><div class="paragraph"><p>在模式这个概念中，还有一些关键点</p></div><div class="ulist"><ul><li><p>需求</p><div class="paragraph"><p>指必须解决的问题</p></div><div class="paragraph"><p>描述了必须解决的问题和围绕这个问题的特定上下文</p></div></li><li><p>结果上下文</p><div class="paragraph"><p>描述采用模式后可能带来的后果</p></div><div class="ulist"><ul><li><p>好处</p><div class="paragraph"><p>这个模式解决的问题</p></div></li><li><p>弊端</p><div class="paragraph"><p>这个模式没有解决的问题</p></div></li><li><p>问题</p><div class="paragraph"><p>这个模式带来的新问题</p></div></li></ul></div></li><li><p>相关模式指与其他模式的关系</p><div class="ulist"><ul><li><p>前导模式</p><div class="paragraph"><p>催生这个模式解决的需求的模式。换句话说，采用了一个模式的前导模式，可能还有没解决的问题或新引入的问题，这些问题可以通过这个模式解决。</p></div></li><li><p>后续模式</p><div class="paragraph"><p>与前导模式相对应</p></div></li><li><p>替代模式</p><div class="paragraph"><p>可以替换当前模式的模式</p></div></li><li><p>泛化模式</p><div class="paragraph"><p>针对某种问题的一般性解决方案</p></div></li><li><p>特化模式</p><div class="paragraph"><p>针对特定问题的解决方案</p></div></li></ul></div></li></ul></div><div class="paragraph"><p>上面这些概念，化成思维导图：</p></div><div class="imageblock"><div class="content"><img src="pattern.png" alt="模式"></div></div><div class="paragraph"><p>了解了模式这个概念之后，再去看所有的微服务架构的设计模式，就能够建立起一个知识网络，把这些模式关联起来，知道什么样的问题可以使用哪个或哪些模式来解决。</p></div></div></div><div class="sect1"><h2 id="_微服务的模式语言">微服务的模式语言</h2><div class="sectionbody"><div class="paragraph"><p>作者在书中将微服务的模式语言分为了三类：<code>应用相关</code>、<code>应用基础设施相关</code>、<code>基础设施相关</code>，而这三类模式都是 <code>微服务架构模式</code> 的后续模式。这三类下还有更细粒度的划分，一点一点来看。</p></div><div class="paragraph"><p>我不会完全按照作者的小类属于某个大类来划分，我会按照面临的问题来划分模式语言，有的模式可能出现在多个问题的解决方案中。</p></div><div class="sect2"><h3 id="_服务拆分相关">服务拆分相关</h3><div class="paragraph"><p>这一小类被划分到了 <code>应用相关</code> 下，包括了两种模式：<code>根据业务能力进行拆分</code> 和 <code>根据子域进行拆分</code>。</p></div><div class="paragraph"><p>这两个模式涉及到了 <code>业务能力</code> 和 <code>子域</code> 两概念，要理解这两个模式就要先理解这两个概念。</p></div><div class="ulist"><ul><li><p>业务能力：能够为公司产生价值的商业活动。</p></li><li><p>子域：来自 <code>DDD</code>，将领域划分后的产物，一般认为一个子域就会被设计为一个服务。</p></li></ul></div><div class="paragraph"><p>业务能力这个词，对我来讲太抽象，个人理解是使用在没有采用 <code>DDD</code> 的环境中的替代子域的方案。而 <code>DDD</code> 至少实践过，也有理论支持。</p></div><div class="paragraph"><p>这两个模式互为替代模式。</p></div></div><div class="sect2"><h3 id="_进程间通信相关">进程间通信相关</h3><div class="paragraph"><p>将微服务拆分为单体后，面临的第一个问题就是服务间的访问问题，毕竟需要不同的服务相互协作，才能完成所有的业务。</p></div><div class="paragraph"><p>要解决进程间通信的问题，首先要解决的问题就是进程在哪里。</p></div><div class="sect3"><h4 id="_服务发现">服务发现</h4><div class="paragraph"><p>服务发现就是解决进程在哪里的问题，他的解决方案又可以分为 <code>应用层服务发现</code> 和 <code>平台层服务发现</code>。它们一个需要自己写代码或使用第三方类库来实现，一个需要部署平台来实现，而它们又都是两个模式的组合使用来实现的。</p></div><div class="ulist"><ul><li><p>应用层服务发现</p><div class="ulist"><ul><li><p>自注册模式</p></li><li><p>客户端发现模式</p></li></ul></div></li><li><p>平台层服务发现</p><div class="ulist"><ul><li><p>第三方注册模式</p></li><li><p>服务器发现模式</p></li></ul></div></li></ul></div><div class="paragraph"><p>它们的典型代表分别是 Netflix 的 Eureka 和 Kubernates。这两种组合的模式互为替换模式。</p></div></div><div class="sect3"><h4 id="_服务间通信方式">服务间通信方式</h4><div class="paragraph"><p>解决了服务发现的问题之后，服务就能找到想要通信的服务在哪里，那么就要解决真正的通信问题。</p></div><div class="paragraph"><p>这个问题又可以分为 <code>同步的远程调用</code> 和 <code>异步的远程调用</code>。</p></div><div class="paragraph"><p>异步的方式，只有 <code>消息模式</code> 可以选择。</p></div><div class="paragraph"><p>同步的方式，也只有 <code>远程过程调用模式</code>，但实现方式却多种多样。比如 <code>REST</code>、 <code>gRPC</code> 等等。但同步又会引入新的问题，那就是调用有可能失败。</p></div><div class="paragraph"><p>针对失败的情况，可以使用 <code>断路器模式</code> 实现服务降级来应对。</p></div><div class="paragraph"><p>同步的模式与异步的模式互为替换模式，一般会根据业务需求来进行选择。</p></div></div></div><div class="sect2"><h3 id="_数据一致性问题">数据一致性问题</h3><div class="paragraph"><p>数据一致性问题算是分布式应用的一大痛点。目前的解决方案有 <code>2PC 模式</code> 和 <code>Saga 模式</code>。它们互为替换模式</p></div><div class="paragraph"><p>其中的 <code>Saga 模式</code> 又可以采用 <code>协同式</code> 或 <code>编排式</code> 来实现。</p></div><div class="paragraph"><p>书中有详细讲述如何实现 <code>Saga 模式</code>。</p></div></div><div class="sect2"><h3 id="_查询相关">查询相关</h3><div class="paragraph"><p>微服务引入的另一个问题是，查询的时候，很难进行连表查询，因为数据被划分到了不同的数据库实例中，无法连接。</p></div><div class="paragraph"><p>针对这个问题可以使用 <code>API 组合</code> 或 <code>CQRS</code> 模式。</p></div></div><div class="sect2"><h3 id="_外部_api">外部 API</h3><div class="paragraph"><p>对于来自微服务系统外的请求，如果让它直接到达服务本身，就会让外部实现和服务产生紧耦合，没有做到封装。</p></div><div class="paragraph"><p>为了解决这个问题，可以使用 <code>API Gateway 模式</code> 和 <code>BFF 模式</code> 来实现。</p></div><div class="paragraph"><p><code>API Gateway 模式</code> 是提供一个服务，对外只暴露这个服务，由这个服务来转发请求到真正的服务上。并且在这个 API Gateway 服务上，可以统一实现如认证授权、缓存等公共功能。</p></div><div class="paragraph"><p><code>BFF 模式</code> 是提供一个服务，编写一个 API 暴露到服务外部，屏蔽底层服务的 API 。外部服务调用的是 <code>BFF</code> 暴露的 API 。一般会针对不同类型的设备开发不同的 <code>BFF</code> 服务。</p></div></div><div class="sect2"><h3 id="_服务安全性">服务安全性</h3><div class="paragraph"><p>服务间访问时，如何辨别是谁在请求，是微服务引入的问题之一。</p></div><div class="paragraph"><p>解决方案是 <code>访问令牌模式</code>。这里的令牌中包含了用户信息，帮助服务判断当前的访问者是谁、有没有权限执行请求。常见的令牌是 <code>JWT</code>。</p></div><div class="paragraph"><p>一般会选择使用 <code>API Gateway 模式</code>，在 API Gateway 服务上认证用户、颁发令牌。</p></div></div><div class="sect2"><h3 id="_可配置性">可配置性</h3><div class="paragraph"><p>引入微服务后，会发现配置管理是一个问题，所以引入了 <code>外部化配置模式</code> 来解决它。</p></div></div><div class="sect2"><h3 id="_可观测性">可观测性</h3><div class="paragraph"><p>这不仅仅是微服务的问题，只是在引入微服务后这个问题变得更大。针对不同的观测需求，需要采用不同的模式。</p></div><div class="ulist"><ul><li><p><code>健康检查 API 模式</code>：查看服务是否在正常运行。</p></li><li><p><code>日志聚合模式</code>：在统一的地方查看所有服务的日志，而不需要到不同的地方查看。</p></li><li><p><code>分布式追踪模式</code>：在追踪一个请求时，因为请求会跨域多个服务，为了追踪整条请求链路而设计。</p></li><li><p><code>应用程序指标模式</code>：用于观测资源使用情况和告警。</p></li><li><p><code>异常追踪模式</code>：将异常发送到特定的服务，该服务对异常进行警报、管理等工作。</p></li><li><p><code>审核日志记录模式</code>：单体也需要。</p></li></ul></div></div><div class="sect2"><h3 id="_服务基底模式">服务基底模式</h3><div class="paragraph"><p>考虑到所有的服务都有一些公共功能，比如日志、分布式追踪、服务发现等等，使用某种基底模式可以简化服务的开发工作。</p></div><div class="ulist"><ul><li><p><code>微服务基底模式</code>：将公共功能实现在框架上，在新加服务时，直接使用这个框架。</p></li><li><p><code>服务网格模式</code>：服务网格是一个网络层，由它来实现服务发现、负载均衡等问题。</p></li><li><p><code>边车模式</code>：边车是一个与服务同生同死的进程，由它来负责公共功能。</p></li></ul></div></div><div class="sect2"><h3 id="_部署模式">部署模式</h3><div class="paragraph"><p>这里的四种部署模式和微服务没有关系，单体应用也可以使用这些模式，这没有什么强制性。</p></div><div class="ulist"><ul><li><p><code>编程语言特定的发布包模式</code></p></li><li><p><code>发布为虚拟机模式</code></p></li><li><p><code>发布为容器模式</code></p></li><li><p><code>Serverless 部署模式</code></p></li></ul></div><div class="paragraph"><p>作者推荐的考虑顺序从下往上，但这仅仅是技术考虑的结果。实际选择时，还要考虑数据敏感性、部署环境技术限制等因素，Serverless 模式可能是最不会被选择的一个。</p></div></div><div class="sect2"><h3 id="_测试相关">测试相关</h3><div class="paragraph"><p>测试方面面临的挑战主要是如何验证服务本身是工作的，以及如何验证服务间的集成是工作的。</p></div><div class="paragraph"><p>针对第一个问题，可以使用 <code>服务组件测试模式</code> 来解决。其中的组件是指一个服务。在这样的测试中，对外部的调用将会被 mock，测试的关注点在于服务本身是否工作。</p></div><div class="paragraph"><p>针对第二个问题，可以使用 <code>消费者驱动的契约测试模式</code> 来解决。一份契约，既可以在消费者端称为 stub，又可以在服务者端做为测试用例。</p></div><div class="paragraph"><p>值得注意的是，即使上面两个测试都通过了，你仍然需要一个针对整个系统的 <code>E2E 测试</code> ，才能保证系统是正常工作的。因为从测试金字塔来看，上面两个测试是在 <code>E2E 测试</code> 的下一层。</p></div></div><div class="sect2"><h3 id="_重构的模式">重构的模式</h3><div class="paragraph"><p>毕竟微服务都是拆出来的。实践微服务时，往往面临的问题是将一个巨大的单体服务拆分为微服务。针对这样的问题，就要祭出大名鼎鼎的 <code>绞杀着模式</code> 。</p></div><div class="paragraph"><p>使用这个模式需要考虑三种策略：</p></div><div class="ulist"><ul><li><p>将新功能实现为服务</p></li><li><p>隔离表现层与后端（本质上是指责分离）</p></li><li><p>提取业务到服务中</p></li></ul></div><div class="paragraph"><p>当采用第一种和第三种策略时，都需要加入新的服务，那就需要准备好你的微服务需要的基础设施，也就是服务发现、API Gateway 等等一系列的模式都需要准备好，这样新加入的服务才能和单体一起工作。但这也不是绝对的，也可以逐渐演进，而不用一步到位。</p></div></div></div></div>]]></content:encoded>
      
      <comments>https://blog.gaoyuexiang.cn/2020/02/01/microservice-arch-pattern/#disqus_thread</comments>
    </item>
    
    <item>
      <title>端口与适配器架构</title>
      <link>https://blog.gaoyuexiang.cn/2020/01/05/hexagonal-architecture/</link>
      <guid>https://blog.gaoyuexiang.cn/2020/01/05/hexagonal-architecture/</guid>
      <pubDate>Sun, 05 Jan 2020 19:26:44 GMT</pubDate>
      <description>
      
        &lt;div class=&quot;imageblock center&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;images/hexagonal-architecture.png&quot; alt=&quot;hexagonal architecture&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<div class="imageblock center"><div class="content"><img src="images/hexagonal-architecture.png" alt="hexagonal architecture"></div></div><div class="paragraph"><p>端口与适配器架构又被称为六边形架构，是一种约定代码设计的架构。它解决的是如何设计代码的问题，主要的关注点在于业务与技术的解耦。</p></div><div class="paragraph"><p>第一次看到这个名字的时候，就有很多问题冒了出来：</p></div><div class="ulist"><ul><li><p>它解决什么问题？</p></li><li><p>什么是端口？什么是适配器？</p></li><li><p>按照这个架构写出来的代码应该是什么样子？</p></li><li><p>它为什么又被称作六边形架构？有什么特殊含义？</p></li></ul></div><div class="paragraph"><p>带着这些问题，搜索了一些资料，算是有了下面的这些理解。</p></div><div class="sect1"><h2 id="_为什么又被称作六边形架构">为什么又被称作六边形架构</h2><div class="sectionbody"><div class="paragraph"><p>其实它被称作六边形架构，仅仅是因为它的作者 Dr. Alistair Cockburn 画成这样的而已，没有什么深意。这个架构和“六”这个数字以及“六边形”这个图形都没有任何关联。</p></div><div class="paragraph"><p>那么，这个“六边形”又代表什么呢？</p></div><div class="paragraph"><p>这个“六边形”就是我们所说的“应用”，六边形内的东西，是与技术无关的业务代码。而这些业务代码如何设计，它并没有约定。你可以在内部使用 <code>DDD</code> 战术，也可以使用 “意大利面条式”的代码设计。</p></div></div></div><div class="sect1"><h2 id="_一些概念">一些概念</h2><div class="sectionbody"><div class="sect2"><h3 id="_actor">Actor</h3><div class="paragraph"><p>Actor 是指那些与应用交互的组件，包括浏览器、命令行甚至其他的应用。所有这些东西都是在我们的“六边形”之外的。</p></div><div class="paragraph"><p>Actor 也有分类，依据是与应用交互的方式：</p></div><div class="sect3"><h4 id="_drivers">Drivers</h4><div class="paragraph"><p>又被称作 Primary Actors。这些 Actor 的特点是它们会调用应用，以完成业务目的。</p></div><div class="paragraph"><p>在画六边形时，Driver 会被画到六边形的左边和上面。</p></div></div><div class="sect3"><h4 id="_driven_actors">Driven Actors</h4><div class="paragraph"><p>又被称作 Secondary Actors。这些 Actor 被应用调用，它们提供技术方面的功能以帮助应用完成业务逻辑。</p></div><div class="paragraph"><p>在画六边形时，Driven Actor 会被画到六边形的右边和下边。</p></div></div></div><div class="sect2"><h3 id="_ports">Ports</h3><div class="paragraph"><p>端口处在“六边形”的边缘，用于应用和 <code>Actors</code> 的交互。</p></div><div class="paragraph"><p>根据交互的 <code>Actor</code> 的不同，可以将端口分类为 <code>Driver Port</code> 和 <code>Driven Port</code> ，或者按照《微服务架构设计模式》的说法称作 <code>入站端口</code> 和 <code>出站端口</code> 。</p></div><div class="paragraph"><p>它们被这样分类是因为：</p></div><div class="ulist"><ul><li><p>入站端口提供了访问应用的 <code>API</code></p></li><li><p>出站端口被应用调用，提供 <code>SPI</code> 供 <code>Driven Actor</code> 实现</p></li></ul></div><div class="paragraph"><p>端口描述了应用的业务功能，关注点仍然在业务上。</p></div><div class="paragraph"><p>以 <code>Driver Port</code> 来说，可以提供一个 <code>createOrder</code> 端口提供下单的功能。</p></div><div class="paragraph"><p>以 <code>Driven Port</code> 来说，可以提供一个 <code>sendNotification</code> 端口来要求一个发送通知的功能。</p></div><div class="paragraph"><p>但 <code>Actor</code> 并不是直接和端口交互，而是通过 <code>Adapter</code> 来进行的。</p></div></div><div class="sect2"><h3 id="_adapters">Adapters</h3><div class="paragraph"><p>适配器处在“六边形”之外，所有的 <code>Actor</code> 都是通过适配器来和 <code>Port</code> 交互，以达到和应用交互的效果。</p></div><div class="paragraph"><p>适配器可以根据适配的端口的不同，分为 <code>Driver Adapter</code> 和 <code>Driven Adapter</code> （或 <code>入站适配器</code> 和 <code>出站适配器</code> ）。</p></div><div class="paragraph"><p>适配器就是从“六边形”中解耦出来的“技术”。</p></div><div class="paragraph"><p>以 <code>Driver Adapter</code> 来说，可以实现 <code>REST适配器</code> 来提供 <code>REST</code> 风格的接口来调用端口使用应用；也可以实现 <code>CLI适配器</code> 来提供 <code>CLI</code> 接口来调用端口使用应用。</p></div><div class="paragraph"><p>以 <code>Driven Adapter</code> 来说，可以实现一个 <code>MySQL适配器</code> 以使用 <code>MySQL</code> 持久化数据；也可以实现一个 <code>MongoDB适配器</code> 以使用 <code>MongoDB</code> 持久化数据；也可以实现一个 <code>邮件通知适配器</code> 来实现以邮件形式发送通知的功能。</p></div></div><div class="sect2"><h3 id="_小结">小结</h3><div class="paragraph"><p>以上就是端口与适配器架构的核心的概念。</p></div><div class="paragraph"><p>我们可以看到，它的关注点仅仅在于如何将技术代码与业务代码分离开。所以它定义了 <code>Actors</code>、<code>Ports</code> 和 <code>Adapters</code> 这三个概念。而“六边形”并不是一个又特殊含义的东西，只有画出应用的边界和区别 <code>Driver</code> 与 <code>Driven Actor</code> 的作用。</p></div><div class="paragraph"><p>这些概念中，只有 <code>Ports</code> 是属于应用的，其他两个概念都是在应用之外。- 所有的业务代码，都被包含在了应用之中，而没有被泄漏到应用之外- 所有需要与第三方交互的技术代码都被放到了 <code>Adapters</code> 里，也就是应用之外，没有侵入到业务代码中</p></div><div class="sect3"><h4 id="_解决的问题">解决的问题</h4><div class="paragraph"><p>与其他应用交互的代码的设计。</p></div></div><div class="sect3"><h4 id="_没解决的问题">没解决的问题</h4><div class="paragraph"><p>业务代码怎么写。这需要使用其他的模式来解决，比如 DDD 的战术模式。</p></div></div></div></div></div><div class="sect1"><h2 id="_如何实现">如何实现</h2><div class="sectionbody"><div class="paragraph"><p>端口与适配器架构模式要求将应用与适配器分离开，这意味着实现这个模式的时候，需要对应用代码和技术代码做一些技术隔离。对于 <code>Java</code> 而言，无论是使用 <code>Maven</code> 还是 <code>Gradle</code> 都能比较容易的分离 <code>subproject</code>。其他语言也可以使用类似的技术来实现。虽然不是特别麻烦，但总归是增加了系统的复杂度。</p></div><div class="paragraph"><p>Java 的例子可以参考 <a href="https://github.com/letcodespeak/hexagonal-architecture" target="_blank" rel="noopener">这里</a>。</p></div></div></div><div class="sect1"><h2 id="_总结">总结</h2><div class="sectionbody"><div class="paragraph"><p>总的来说，端口与适配器模式并不复杂，搞清楚三个关键概念和“六边形”没有意义这个点，就算立即到这个架构模式了。</p></div><div class="paragraph"><p>参考连接： <a href="https://softwarecampament.wordpress.com/portsadapters/" target="_blank" rel="noopener" class="bare">https://softwarecampament.wordpress.com/portsadapters/</a></p></div></div></div>]]></content:encoded>
      
      <comments>https://blog.gaoyuexiang.cn/2020/01/05/hexagonal-architecture/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Spring 里那么多种 CORS 的配置方式，到底有什么区别</title>
      <link>https://blog.gaoyuexiang.cn/2019/06/14/how-spring-implement-cors/</link>
      <guid>https://blog.gaoyuexiang.cn/2019/06/14/how-spring-implement-cors/</guid>
      <pubDate>Fri, 14 Jun 2019 22:14:37 GMT</pubDate>
      <description>
      
        &lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;作为一个后端开发，我们经常遇到的一个问题就是需要配置 &lt;code&gt;CORS&lt;/code&gt;，好让我们的前端能够访问到我们的 API，并且不让其他人访问。而在 &lt;code&gt;Spring&lt;/code&gt; 中，我们见过很多种 &lt;code&gt;CORS&lt;/code&gt; 的配置，很多资料都只是告诉我们可以这样配置、可以那样配置，但是这些配置有什么区别？&lt;/p&gt;
&lt;/div&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<div class="paragraph"><p>作为一个后端开发，我们经常遇到的一个问题就是需要配置 <code>CORS</code>，好让我们的前端能够访问到我们的 API，并且不让其他人访问。而在 <code>Spring</code> 中，我们见过很多种 <code>CORS</code> 的配置，很多资料都只是告诉我们可以这样配置、可以那样配置，但是这些配置有什么区别？</p></div><div class="sect1"><h2 id="_cors_是什么">CORS 是什么</h2><div class="sectionbody"><div class="paragraph"><p>首先我们要明确，<code>CORS</code> 是什么，以及规范是如何要求的。这里只是梳理一下流程，具体的规范请看 <a href="https://www.w3.org/TR/cors/" target="_blank" rel="noopener">这里</a>。</p></div><div class="paragraph"><p><code>CORS</code> 全称是 <code>Cross-Origin Resource Sharing</code>，直译过来就是跨域资源共享。要理解这个概念就需要知道<strong>域</strong>、<strong>资源</strong>和<strong>同源策略</strong>这三个概念。</p></div><div class="ulist"><ul><li><p>域，指的是一个站点，由 <code>protocal</code>、<code>host</code> 和 <code>port</code> 三部分组成，其中 <code>host</code> 可以是域名，也可以是 <code>ip</code> ；<code>port</code> 如果没有指明，则是使用 <code>protocal</code> 的默认端口</p></li><li><p>资源，是指一个 <code>URL</code> 对应的内容，可以是一张图片、一种字体、一段 <code>HTML</code> 代码、一份 <code>JSON</code> 数据等等任何形式的任何内容</p></li><li><p>同源策略，指的是为了防止 <code>XSS</code>，浏览器、客户端应该仅请求与当前页面来自同一个域的资源，请求其他域的资源需要通过验证。</p></li></ul></div><div class="paragraph"><p>了解了这三个概念，我们就能理解为什么有 <code>CORS</code> 规范了：从站点 A 请求站点 B 的资源的时候，由于浏览器的同源策略的影响，这样的跨域请求将被禁止发送；为了让跨域请求能够正常发送，我们需要一套机制在不破坏同源策略的安全性的情况下、允许跨域请求正常发送，这样的机制就是 <code>CORS</code>。</p></div><div class="sect2"><h3 id="_预检请求">预检请求</h3><div class="paragraph"><p>在 <code>CORS</code> 中，定义了一种预检请求，即 <code>preflight request</code>，当实际请求不是一个 <code>简单请求</code> 时，会发起一次预检请求。预检请求是针对实际请求的 URL 发起一次 <code>OPTIONS</code> 请求，并带上下面三个 <code>headers</code> ：</p></div><div class="ulist"><ul><li><p><code>Origin</code>：值为当前页面所在的域，用于告诉服务器当前请求的域。如果没有这个 <code>header</code>，服务器将不会进行 <code>CORS</code> 验证。</p></li><li><p><code>Access-Control-Request-Method</code>：值为实际请求将会使用的方法</p></li><li><p><code>Access-Control-Request-Headers</code>：值为实际请求将会使用的 <code>header</code> 集合</p></li></ul></div><div class="paragraph"><p>如果服务器端 <code>CORS</code> 验证失败，则会返回客户端错误，即 <code>4xx</code> 的状态码。</p></div><div class="paragraph"><p>否则，将会请求成功，返回 <code>200</code> 的状态码，并带上下面这些 <code>headers</code>：</p></div><div class="ulist"><ul><li><p><code>Access-Control-Allow-Origin</code>：允许请求的域，多数情况下，就是预检请求中的 <code>Origin</code> 的值</p></li><li><p><code>Access-Control-Allow-Credentials</code>：一个布尔值，表示服务器是否允许使用 <code>cookies</code></p></li><li><p><code>Access-Control-Expose-Headers</code>：实际请求中可以出现在响应中的 <code>headers</code> 集合</p></li><li><p><code>Access-Control-Max-Age</code>：预检请求返回的规则可以被缓存的最长时间，超过这个时间，需要再次发起预检请求</p></li><li><p><code>Access-Control-Allow-Methods</code>：实际请求中可以使用到的方法集合</p></li></ul></div><div class="paragraph"><p>浏览器会根据预检请求的响应，来决定是否发起实际请求。</p></div></div><div class="sect2"><h3 id="_小结">小结</h3><div class="paragraph"><p>到这里， 我们就知道了跨域请求会经历的故事：</p></div><div class="olist arabic"><ol class="arabic"><li><p>访问另一个域的资源</p></li><li><p>有可能会发起一次预检请求（非简单请求，或超过了 <code>Max-Age</code>）</p></li><li><p>发起实际请求</p></li></ol></div><div class="paragraph"><p>接下来，我们看看在 Spring 中，我们是如何让 <code>CORS</code> 机制在我们的应用中生效的。</p></div></div></div></div><div class="sect1"><h2 id="_几种配置的方式">几种配置的方式</h2><div class="sectionbody"><div class="paragraph"><p>Spring 提供了多种配置 <code>CORS</code> 的方式，有的方式针对单个 API，有的方式可以针对整个应用；有的方式在一些情况下是等效的，而在另一些情况下却又出现不同。我们这里例举几种典型的方式来看看应该如何配置。</p></div><div class="paragraph"><p>假设我们有一个 API：</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-kotlin" data-lang="kotlin"><pre><code class="highlight kotlin"><span class="meta">@RestController</span><span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;    <span class="meta">@GetMapping(<span class="meta-string">"hello"</span>)</span>    <span class="function"><span class="keyword">fun</span> <span class="title">hello</span><span class="params">()</span></span>: String &#123;        <span class="keyword">return</span> <span class="string">"Hello, CORS!"</span>    &#125;&#125;</code></pre></code></pre></div></div><div class="sect2"><h3 id="_crossorigin_注解"><code>@CrossOrigin</code> 注解</h3><div class="paragraph"><p>使用`@CorssOrigin` 注解需要引入 <code>Spring Web</code> 的依赖，该注解可以作用于方法或者类，可以针对这个方法或类对应的一个或多个 API 配置 <code>CORS</code> 规则：</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-kotlin" data-lang="kotlin"><pre><code class="highlight kotlin"><span class="meta">@RestController</span><span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;    <span class="meta">@GetMapping(<span class="meta-string">"hello"</span>)</span>    <span class="meta">@CrossOrigin(origins = [<span class="meta-string">"http://localhost:8080"</span>])</span>    <span class="function"><span class="keyword">fun</span> <span class="title">hello</span><span class="params">()</span></span>: String &#123;        <span class="keyword">return</span> <span class="string">"Hello, CORS!"</span>    &#125;&#125;</code></pre></code></pre></div></div></div><div class="sect2"><h3 id="_实现_webmvcconfigurer_addcorsmappings_方法">实现 <code>WebMvcConfigurer.addCorsMappings</code> 方法</h3><div class="paragraph"><p><code>WebMvcConfigurer</code> 是一个接口，它同样来自于 <code>Spring Web</code>。我们可以通过实现它的 <code>addCorsMappings</code> 方法来针对全局 API 配置 <code>CORS</code> 规则：</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-kotlin" data-lang="kotlin"><pre><code class="highlight kotlin"><span class="meta">@Configuration</span><span class="meta">@EnableWebMvc</span><span class="class"><span class="keyword">class</span> <span class="title">MvcConfig</span>: <span class="type">WebMvcConfigurer &#123;</span></span>    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">addCorsMappings</span><span class="params">(registry: <span class="type">CorsRegistry</span>)</span></span> &#123;        registry.addMapping(<span class="string">"/hello"</span>)                .allowedOrigins(<span class="string">"http://localhost:8080"</span>)    &#125;&#125;</code></pre></code></pre></div></div></div><div class="sect2"><h3 id="_注入_corsfilter">注入 <code>CorsFilter</code></h3><div class="paragraph"><p><code>CorsFilter</code> 同样来自于 <code>Spring Web</code>，但是实现 <code>WebMvcConfigurer.addCorsMappings</code> 方法并不会使用到这个类，具体原因我们后面来分析。我们可以通过注入一个 <code>CorsFilter</code> 来使用它：</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-kotlin" data-lang="kotlin"><pre><code class="highlight kotlin"><span class="meta">@Configuration</span><span class="class"><span class="keyword">class</span> <span class="title">CORSConfiguration</span> </span>&#123;    <span class="meta">@Bean</span>    <span class="function"><span class="keyword">fun</span> <span class="title">corsFilter</span><span class="params">()</span></span>: CorsFilter &#123;        <span class="keyword">val</span> configuration = CorsConfiguration()        configuration.allowedOrigins = listOf(<span class="string">"http://localhost:8080"</span>)        <span class="keyword">val</span> source = UrlBasedCorsConfigurationSource()        source.registerCorsConfiguration(<span class="string">"/hello"</span>, configuration)        <span class="keyword">return</span> CorsFilter(source)    &#125;&#125;</code></pre></code></pre></div></div><div class="paragraph"><p>注入 <code>CorsFilter</code> 不止这一种方式，我们还可以通过注入一个 <code>FilterRegistrationBean</code> 来实现，这里就不给例子了。</p></div><div class="quoteblock"><blockquote><div class="paragraph"><p>在仅仅引入 <code>Spring Web</code> 的情况下，实现 <code>WebMvcConfigurer.addCorsMappings</code> 方法和注入 <code>CorsFilter</code> 这两种方式可以达到同样的效果，二选一即可。它们的区别会在引入 <code>Spring Security</code> 之后会展现出来，我们后面再来分析。</p></div></blockquote></div></div><div class="sect2"><h3 id="_spring_security_中的配置">Spring Security 中的配置</h3><div class="paragraph"><p>在引入了 <code>Spring Security</code> 之后，我们会发现前面的方法都不能正确的配置 <code>CORS</code>，每次 <code>preflight request</code> 都会得到一个 <code>401</code> 的状态码，表示请求没有被授权。这时，我们需要增加一点配置才能让 <code>CORS</code> 正常工作：</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-kotlin" data-lang="kotlin"><pre><code class="highlight kotlin"><span class="meta">@Configuration</span><span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> : <span class="type">WebSecurityConfigurerAdapter</span></span>() &#123;    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">configure</span><span class="params">(http: <span class="type">HttpSecurity</span>?)</span></span> &#123;        http?.cors()    &#125;&#125;</code></pre></code></pre></div></div><div class="paragraph"><p>或者，干脆不实现 <code>WebMvcConfigurer.addCorsMappings</code> 方法或者注入 <code>CorsFilter</code> ，而是注入一个 <code>CorsConfigurationSource</code> ，同样能与上面的代码配合，正确的配置 <code>CORS</code>：</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-kotlin" data-lang="kotlin"><pre><code class="highlight kotlin"><span class="meta">@Bean</span><span class="function"><span class="keyword">fun</span> <span class="title">corsConfigurationSource</span><span class="params">()</span></span>: CorsConfigurationSource &#123;    <span class="keyword">val</span> configuration = CorsConfiguration()    configuration.allowedOrigins = listOf(<span class="string">"http://localhost:8080"</span>)    <span class="keyword">val</span> source = UrlBasedCorsConfigurationSource()    source.registerCorsConfiguration(<span class="string">"/hello"</span>, configuration)    <span class="keyword">return</span> source&#125;</code></pre></code></pre></div></div><hr><div class="paragraph"><p>到此，我们已经看过了几种典型的例子了，完整的内容可以在 <a href="https://github.com/kbyyd24/spring-cors-practice" target="_blank" rel="noopener">Demo</a> 中查看，我们接下来看看 Spring 到底是如何实现 <code>CORS</code> 验证的。</p></div></div></div></div><div class="sect1"><h2 id="_这些配置有什么区别">这些配置有什么区别</h2><div class="sectionbody"><div class="paragraph"><p>我们会主要分析实现 <code>WebMvcConfigurer.addCorsMappings</code> 方法和调用 <code>HttpSecurity.cors</code> 方法这两种方式是如何实现 <code>CORS</code> 的，但在进行之前，我们要先复习一下 <code>Filter</code> 与 <code>Interceptor</code> 的概念。</p></div><div class="sect2"><h3 id="_filter_与_interceptor">Filter 与 Interceptor</h3><div class="imageblock center"><div class="content"><img src="filter-and-interceptor.png" alt="filter and interceptor"></div></div><div class="paragraph"><p>上图很形象的说明了 <code>Filter</code> 与 <code>Interceptor</code> 的区别，一个作用在 <code>DispatcherServlet</code> 调用前，一个作用在调用后。</p></div><div class="paragraph"><p>但实际上，它们本身并没有任何关系，是完全独立的概念。</p></div><div class="paragraph"><p><code>Filter</code> 由 <code>Servlet</code> 标准定义，要求 <code>Filter</code> 需要在 <code>Servlet</code> 被调用之前调用，作用顾名思义，就是用来过滤请求。在 <code>Spring Web</code> 应用中，<code>DispatcherServlet</code> 就是唯一的 <code>Servlet</code> 实现。</p></div><div class="paragraph"><p><code>Interceptor</code> 由 Spring 自己定义，由 <code>DispatcherServlet</code> 调用，可以定义在 <code>Handler</code> 调用前后的行为。这里的 <code>Handler</code> ，在多数情况下，就是我们的 <code>Controller</code> 中对应的方法。</p></div><div class="paragraph"><p>对于 <code>Filter</code> 和 <code>Interceptor</code> 的复习就到这里，我们只需要知道它们会在什么时候被调用到，就能理解后面的内容了。</p></div></div><div class="sect2"><h3 id="_webmvcconfigurer_addcorsmappings_方法做了什么"><code>WebMvcConfigurer.addCorsMappings</code> 方法做了什么</h3><div class="paragraph"><p>我们从 <code>WebMvcConfigurer.addCorsMappings</code> 方法的参数开始，先看看 <code>CORS</code> 配置是如何保存到 Spring 上下文中的，然后在了解一下 Spring 是如何使用的它们。</p></div><div class="sect3"><h4 id="_注入_cors_配置">注入 CORS 配置</h4><div class="sect4"><h5 id="_corsregistry_和_corsregistration">CorsRegistry 和 CorsRegistration</h5><div class="paragraph"><p><code>WebMvcConfigurer.addCorsMappings</code> 方法的参数 <code>CorsRegistry</code> 用于注册 <code>CORS</code> 配置，它的源码如下：</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-java" data-lang="java"><pre><code class="highlight java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CorsRegistry</span> </span>&#123;<span class="keyword">private</span> <span class="keyword">final</span> List&lt;CorsRegistration&gt; registrations = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="function"><span class="keyword">public</span> CorsRegistration <span class="title">addMapping</span><span class="params">(String pathPattern)</span> </span>&#123;CorsRegistration registration = <span class="keyword">new</span> CorsRegistration(pathPattern);<span class="keyword">this</span>.registrations.add(registration);<span class="keyword">return</span> registration;&#125;<span class="function"><span class="keyword">protected</span> Map&lt;String, CorsConfiguration&gt; <span class="title">getCorsConfigurations</span><span class="params">()</span> </span>&#123;Map&lt;String, CorsConfiguration&gt; configs = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(<span class="keyword">this</span>.registrations.size());<span class="keyword">for</span> (CorsRegistration registration : <span class="keyword">this</span>.registrations) &#123;configs.put(registration.getPathPattern(), registration.getCorsConfiguration());&#125;<span class="keyword">return</span> configs;&#125;&#125;</code></pre></code></pre></div></div><div class="paragraph"><p>我们发现这个类仅仅有两个方法：</p></div><div class="ulist"><ul><li><p><code>addMapping</code> 接收一个 <code>pathPattern</code>，创建一个 <code>CorsRegistration</code> 实例，保存到列表后将其返回。在我们的代码中，这里的 <code>pathPattern</code> 就是 <code>/hello</code></p></li><li><p><code>getCorsConfigurations</code> 方法将保存的 <code>CORS</code> 规则转换成 <code>Map</code> 后返回</p></li></ul></div><div class="paragraph"><p><code>CorsRegistration</code> 这个类，同样很简单，我们看看它的部分源码：</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-java" data-lang="java"><pre><code class="highlight java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CorsRegistration</span> </span>&#123;<span class="keyword">private</span> <span class="keyword">final</span> String pathPattern;<span class="keyword">private</span> <span class="keyword">final</span> CorsConfiguration config;<span class="function"><span class="keyword">public</span> <span class="title">CorsRegistration</span><span class="params">(String pathPattern)</span> </span>&#123;<span class="keyword">this</span>.pathPattern = pathPattern;<span class="keyword">this</span>.config = <span class="keyword">new</span> CorsConfiguration().applyPermitDefaultValues();&#125;<span class="function"><span class="keyword">public</span> CorsRegistration <span class="title">allowedOrigins</span><span class="params">(String... origins)</span> </span>&#123;<span class="keyword">this</span>.config.setAllowedOrigins(Arrays.asList(origins));<span class="keyword">return</span> <span class="keyword">this</span>;&#125;&#125;</code></pre></code></pre></div></div><div class="paragraph"><p>不难发现，这个类仅仅保存了一个 <code>pathPattern</code> 字符串和 <code>CorsConfiguration</code>，很好理解，它保存的是一个 <code>pathPattern</code> 对应的 <code>CORS</code> 规则。</p></div><div class="paragraph"><p>在它的构造函数中，调用的 <code>CorsConfiguration.applyPermitDefaultValues</code> 方法则用于配置默认的 <code>CORS</code> 规则：</p></div><div class="ulist"><ul><li><p>allowedOrigins 默认为所有域</p></li><li><p>allowedMethods 默认为 <code>GET</code> 、<code>HEAD</code> 和 <code>POST</code></p></li><li><p>allowedHeaders 默认为所有</p></li><li><p>maxAge 默认为 30 分钟</p></li><li><p>exposedHeaders 默认为 null，也就是不暴露任何 header</p></li><li><p>credentials 默认为 null</p></li></ul></div><div class="paragraph"><p>创建 <code>CorsRegistration</code> 后，我们可以通过它的 <code>allowedOrigins</code>、<code>allowedMethods</code> 等方法修改它的 <code>CorsConfiguration</code>，覆盖掉上面的默认值。</p></div><div class="paragraph"><p>现在，我们已经通过 <code>WebMvcConfigurer.addCorsMappings</code> 方法配置好 <code>CorsRegistry</code> 了，接下来看看这些配置会在什么地方被注入到 Spring 上下文中。</p></div></div><div class="sect4"><h5 id="_webmvcconfigurationsupport">WebMvcConfigurationSupport</h5><div class="paragraph"><p><code>CorsRegistry.getCorsConfigurations</code> 方法，会被 <code>WebMvcConfigurationSupport.getConfigurations</code> 方法调用，这个方法如下：</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-java" data-lang="java"><pre><code class="highlight java"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> Map&lt;String, CorsConfiguration&gt; <span class="title">getCorsConfigurations</span><span class="params">()</span> </span>&#123;<span class="keyword">if</span> (<span class="keyword">this</span>.corsConfigurations == <span class="keyword">null</span>) &#123;CorsRegistry registry = <span class="keyword">new</span> CorsRegistry();addCorsMappings(registry);<span class="keyword">this</span>.corsConfigurations = registry.getCorsConfigurations();&#125;<span class="keyword">return</span> <span class="keyword">this</span>.corsConfigurations;&#125;</code></pre></code></pre></div></div><div class="quoteblock"><blockquote><div class="paragraph"><p><code>addCorsMappings(registry)</code> 调用的是自己的方法，由子类 <code>DelegatingWebMvcConfiguration</code> 通过委托的方式调用到 <code>WebMvcConfigurer.addCorsMappings</code> 方法，我们的配置也由此被读取到。</p></div></blockquote></div><div class="paragraph"><p><code>getCorsConfigurations</code> 是一个 <code>protected</code> 方法，是为了在扩展该类时，仍然能够直接获取到 <code>CORS</code> 配置。而这个方法在这个类里被四个地方调用到，这四个调用的地方，都是为了注册一个 <code>HandlerMapping</code> 到 Spring 容器中。每一个地方都会调用 <code>mapping.setCorsConfigurations</code> 方法来接收 <code>CORS</code> 配置，而这个 <code>setCorsConfigurations</code> 方法，则由 <code>AbstractHandlerMapping</code> 提供，<code>CorsConfigurations</code> 也被保存在这个抽象类中。</p></div><div class="paragraph"><p>到此，我们的 <code>CORS</code> 配置借由 <code>AbstractHandlerMapping</code> 被注入到了多个 <code>HandlerMapping</code> 中，而这些 <code>HandlerMapping</code> 以 Spring 组件的形式被注册到了 Spring 容器中，当请求来临时，将会被调用。</p></div></div></div><div class="sect3"><h4 id="_获取_cors_配置">获取 CORS 配置</h4><div class="paragraph"><p>还记得前面关于 <code>Filter</code> 和 <code>Interceptor</code> 那张图吗？当请求来到 <code>Spring Web</code> 时，一定会到达 <code>DispatcherServlet</code> 这个唯一的 <code>Servlet</code>。</p></div><div class="paragraph"><p>在 <code>DispatcherServlet.doDispatch</code> 方法中，会调用所有 <code>HandlerMapping.getHandler</code> 方法。好巧不巧，这个方法又是由 <code>AbstractHandlerMapping</code> 实现的：</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-java" data-lang="java"><pre><code class="highlight java"><span class="meta">@Override</span><span class="meta">@Nullable</span><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;<span class="comment">// 省略代码</span><span class="keyword">if</span> (CorsUtils.isCorsRequest(request)) &#123;CorsConfiguration globalConfig = <span class="keyword">this</span>.corsConfigurationSource.getCorsConfiguration(request);CorsConfiguration handlerConfig = getCorsConfiguration(handler, request);CorsConfiguration config = (globalConfig != <span class="keyword">null</span> ? globalConfig.combine(handlerConfig) : handlerConfig);executionChain = getCorsHandlerExecutionChain(request, executionChain, config);&#125;<span class="keyword">return</span> executionChain;&#125;</code></pre></code></pre></div></div><div class="paragraph"><p>在这个方法中，关于 <code>CORS</code> 的部分都在这个 <code>if</code> 中。我们来看看最后这个 <code>getCorsHandlerExecutionChain</code> 做了什么：</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-java" data-lang="java"><pre><code class="highlight java"><span class="function"><span class="keyword">protected</span> HandlerExecutionChain <span class="title">getCorsHandlerExecutionChain</span><span class="params">(HttpServletRequest request,</span></span><span class="function"><span class="params">HandlerExecutionChain chain, @Nullable CorsConfiguration config)</span> </span>&#123;<span class="keyword">if</span> (CorsUtils.isPreFlightRequest(request)) &#123;HandlerInterceptor[] interceptors = chain.getInterceptors();chain = <span class="keyword">new</span> HandlerExecutionChain(<span class="keyword">new</span> PreFlightHandler(config), interceptors);&#125;<span class="keyword">else</span> &#123;chain.addInterceptor(<span class="keyword">new</span> CorsInterceptor(config));&#125;<span class="keyword">return</span> chain;&#125;</code></pre></code></pre></div></div><div class="paragraph"><p>可以看到：</p></div><div class="ulist"><ul><li><p>针对 <code>preflight request</code>，由于不会有对应的 <code>Handler</code> 来处理，所以这里就创建了一个 <code>PreFlightHandler</code> 来作为这次请求的 <code>handler</code></p></li><li><p>对于其他的跨域请求，因为会有对应的 <code>handler</code>，所以就在 <code>handlerExecutionChain</code> 中加入一个 <code>CorsInterceptor</code> 来进行 <code>CORS</code> 验证</p></li></ul></div><div class="paragraph"><p>这里的 <code>PreFlightHandler</code> 和 <code>CorsInterceptor</code> 都是 <code>AbstractHandlerMapping</code> 的内部类，实现几乎一致，区别仅仅在于一个是 <code>HttpRequestHandler</code>，一个是 <code>HandlerInterceptor</code>；它们对 <code>CORS</code> 规则的验证都交由 <code>CorsProcessor</code> 接口完成，这里采用了默认实现 <code>DefaultCorsProcessor</code> 。</p></div><div class="paragraph"><p><code>DefaultCorsProcessor</code> 则是依照 <code>CORS</code> 标准来实现，并在验证失败的时候打印 <code>debug</code> 日志并拒绝请求。我们只需要关注一下标准中没有定义的验证失败时的状态码：</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-java" data-lang="java"><pre><code class="highlight java"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">rejectRequest</span><span class="params">(ServerHttpResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;response.setStatusCode(HttpStatus.FORBIDDEN);response.getBody().write(<span class="string">"Invalid CORS request"</span>.getBytes(StandardCharsets.UTF_8));&#125;</code></pre></code></pre></div></div><div class="paragraph"><p><code>CORS</code> 验证失败时调用这个方法，并设置状态码为 <code>403</code>。</p></div></div><div class="sect3"><h4 id="_小结_2">小结</h4><div class="paragraph"><p>通过对源码的研究，我们发现实现 <code>WebMvcConfigurer.addCorsMappings</code> 方法的方式配置 <code>CORS</code>，会在 <code>Interceptor</code> 或者 <code>Handler</code> 层进行 <code>CORS</code> 验证。</p></div></div></div><div class="sect2"><h3 id="_htttpsecurity_cors_方法做了什么"><code>HtttpSecurity.cors</code> 方法做了什么</h3><div class="paragraph"><p>在研究这个方法的行为之前，我们先来回想一下，我们调用这个方法解决的是什么问题。</p></div><div class="paragraph"><p>前面我们通过某种方式配置好 <code>CORS</code> 后，引入 <code>Spring Security</code>，<code>CORS</code> 就失效了，直到调用这个方法后，<code>CORS</code> 规则才重新生效。</p></div><div class="paragraph"><p>下面这些原因，导致了 <code>preflight request</code> 无法通过身份验证，从而导致 <code>CORS</code> 失效：</p></div><div class="olist arabic"><ol class="arabic"><li><p><code>preflight request</code> 不会携带认证信息</p></li><li><p><code>Spring Security</code> 通过 <code>Filter</code> 来进行身份验证</p></li><li><p><code>Interceptor</code> 和 <code>HttpRequestHanlder</code> 在 <code>DispatcherServlet</code> 之后被调用</p></li><li><p><code>Spring Security</code> 中的 <code>Filter</code> 优先级比我们注入的 <code>CorsFilter</code> 优先级高</p></li></ol></div><div class="paragraph"><p>接下来我们就来看看 <code>HttpSecurity.cors</code> 方法是如何解决这个问题的。</p></div><div class="sect3"><h4 id="_corsconfigurer_如何配置_cors_规则">CorsConfigurer 如何配置 CORS 规则</h4><div class="paragraph"><p><code>HttpSecurity.cors</code> 方法中其实只有一行代码：</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-java" data-lang="java"><pre><code class="highlight java"><span class="function"><span class="keyword">public</span> CorsConfigurer&lt;HttpSecurity&gt; <span class="title">cors</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;<span class="keyword">return</span> getOrApply(<span class="keyword">new</span> CorsConfigurer&lt;&gt;());&#125;</code></pre></code></pre></div></div><div class="paragraph"><p>这里调用的 <code>getOrApply</code> 方法会将 <code>SecurityConfigurerAdapter</code> 的子类实例加入到它的父类 <code>AbstractConfiguredSecurityBuilder</code> 维护的一个 <code>Map</code> 中，然后一个个的调用 <code>configure</code> 方法。所以，我们来关注一下 <code>CorsConfigurer.configure</code> 方法就好了。</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-java" data-lang="java"><pre><code class="highlight java"><span class="meta">@Override</span><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(H http)</span> <span class="keyword">throws</span> Exception </span>&#123;ApplicationContext context = http.getSharedObject(ApplicationContext<span class="class">.<span class="keyword">class</span>)</span>;CorsFilter corsFilter = getCorsFilter(context);<span class="keyword">if</span> (corsFilter == <span class="keyword">null</span>) &#123;<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Please configure either a "</span> + CORS_FILTER_BEAN_NAME + <span class="string">" bean or a "</span>+ CORS_CONFIGURATION_SOURCE_BEAN_NAME + <span class="string">"bean."</span>);&#125;http.addFilter(corsFilter);&#125;</code></pre></code></pre></div></div><div class="paragraph"><p>这段代码很好理解，就是在当前的 Spring Context 中找到一个 <code>CorsFilter</code>，然后将它加入到 <code>http</code> 对象的 <code>filters</code> 中。由上面的 <code>HttpSecurity.cors</code> 方法可知，这里的 <code>http</code> 对象实际类型就是 <code>HttpSecurity</code>。</p></div><div class="sect4"><h5 id="_getcorsfilter_方法做了什么">getCorsFilter 方法做了什么</h5><div class="paragraph"><p>也许你会好奇，<code>HttpSecurity</code> 要如何保证 <code>CorsFilter</code> 一定在 <code>Spring Security</code> 的 <code>Filters</code> 之前调用。但是在研究这个之前，我们先来看看同样重要的 <code>getCorsFilter</code> 方法，这里可以解答我们前面的一些疑问。</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-java" data-lang="java"><pre><code class="highlight java"><span class="function"><span class="keyword">private</span> CorsFilter <span class="title">getCorsFilter</span><span class="params">(ApplicationContext context)</span> </span>&#123;<span class="keyword">if</span> (<span class="keyword">this</span>.configurationSource != <span class="keyword">null</span>) &#123;<span class="keyword">return</span> <span class="keyword">new</span> CorsFilter(<span class="keyword">this</span>.configurationSource);&#125;<span class="keyword">boolean</span> containsCorsFilter = context.containsBeanDefinition(CORS_FILTER_BEAN_NAME);<span class="keyword">if</span> (containsCorsFilter) &#123;<span class="keyword">return</span> context.getBean(CORS_FILTER_BEAN_NAME, CorsFilter<span class="class">.<span class="keyword">class</span>)</span>;&#125;<span class="keyword">boolean</span> containsCorsSource = context.containsBean(CORS_CONFIGURATION_SOURCE_BEAN_NAME);<span class="keyword">if</span> (containsCorsSource) &#123;CorsConfigurationSource configurationSource = context.getBean(CORS_CONFIGURATION_SOURCE_BEAN_NAME, CorsConfigurationSource<span class="class">.<span class="keyword">class</span>)</span>;<span class="keyword">return</span> <span class="keyword">new</span> CorsFilter(configurationSource);&#125;<span class="keyword">boolean</span> mvcPresent = ClassUtils.isPresent(HANDLER_MAPPING_INTROSPECTOR,context.getClassLoader());<span class="keyword">if</span> (mvcPresent) &#123;<span class="keyword">return</span> MvcCorsFilter.getMvcCorsFilter(context);&#125;<span class="keyword">return</span> <span class="keyword">null</span>;&#125;</code></pre></code></pre></div></div><div class="paragraph"><p>这是 <code>CorsConfigurer</code> 寻找 <code>CorsFilter</code> 的全部逻辑，我们用人话来说就是：</p></div><div class="olist arabic"><ol class="arabic"><li><p><code>CorsConfigurer</code> 自己是否有配置 <code>CorsConfigurationSource</code>，如果有的话，就用它创建一个 <code>CorsFilter</code>。</p></li><li><p>在当前的上下文中，是否存在一个名为 <code>corsFilter</code> 的实例，如果有的话，就把他当作一个 <code>CorsFilter</code> 来用。</p></li><li><p>在当前的上下文中，是否存在一个名为 <code>corsConfigurationSource</code> 的 <code>CorsConfigurationSource</code> 实例，如果有的话，就用它创建一个 <code>CorsFilter</code>。</p></li><li><p>在当前上下文的类加载器中，是否存在类 <code>HandlerMappingIntrospector</code>，如果有的话，则通过 <code>MvcCorsFilter</code> 这个内部类创建一个 <code>CorsFilter</code>。</p></li><li><p>如果没有找到，那就返回一个 <code>null</code>，调用的地方最后会抛出异常，阻止 Spring 初始化。</p></li></ol></div><div class="paragraph"><p>上面的第 2、3、4 步能解答我们前面的配置为什么生效，以及它们的区别。</p></div><div class="paragraph"><p>注册 <code>CorsFilter</code> 的方式，这个 <code>Filter</code> 最终会被直接注册到 Servlet container 中被使用到。</p></div><div class="paragraph"><p>注册 <code>CorsConfigurationSource</code> 的方式，会用这个 <code>source</code> 创建一个 <code>CorsFiltet</code> 然后注册到 Servlet container 中被使用到。</p></div><div class="paragraph"><p>而第四步的情况比较复杂。<code>HandlerMappingIntrospector</code> 是 <code>Spring Web</code> 提供的一个类，实现了 <code>CorsConfigurationSource</code> 接口，所以在 <code>MvcCorsFilter</code> 中，它被直接用于创建 <code>CorsFilter</code>。它实现的 <code>getCorsConfiguration</code> 方法，会经历：</p></div><div class="olist arabic"><ol class="arabic"><li><p>遍历 <code>HandlerMapping</code></p></li><li><p>调用 <code>getHandler</code> 方法得到 <code>HandlerExecutionChain</code></p></li><li><p>从中找到 <code>CorsConfigurationSource</code> 的实例</p></li><li><p>调用这个实例的 <code>getCorsConfiguration</code> 方法，返回得到的 <code>CorsConfiguration</code></p></li></ol></div><div class="paragraph"><p>所以得到的 <code>CorsConfigurationSource</code> 实例，实际上就是前面讲到的 <code>CorsInterceptor</code> 或者 <code>PreFlightHandler</code>。</p></div><div class="paragraph"><p>所以第四步实际上匹配的是实现 <code>WebMvcConfigurer.addCorsMappings</code> 方法的方式。</p></div><div class="paragraph"><p>由于在 <code>CorsFilter</code> 中每次处理请求时都会调用 <code>CorsConfigurationSource.getCorsConfiguration</code> 方法，而 <code>DispatcherServlet</code> 中也会每次调用 <code>HandlerMapping.getHandler</code> 方法，再加上这时的 <code>HandlerExecutionChain</code> 中还有 <code>CorsInterceptor</code>，所以使用这个方式相对于其他方式，做了很多重复的工作。所以 <code>WebMvcConfigurer.addCorsMappings</code> + <code>HttpSecurity.cors</code> 的方式降低了我们代码的效率，也许微乎其微，但能避免的情况下，还是不要使用。</p></div></div></div><div class="sect3"><h4 id="_httpsecurity_中的_filters_属性">HttpSecurity 中的 filters 属性</h4><div class="paragraph"><p>在 <code>CorsConfigurer.configure</code> 方法中调用的 <code>HttpSecurity.addFilter</code> 方法，由它的父类 <code>HttpSecurityBuilder</code> 声明，并约定了很多 <code>Filter</code> 的顺序。然而 <code>CorsFilter</code> 并不在其中。不过在 <code>Spring Security</code> 中，目前还只有 <code>HttpSecurity</code> 这一个实现，所以我们来看看这里的代码实现就知道 <code>CorsFilter</code> 会排在什么地方了。</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-java" data-lang="java"><pre><code class="highlight java"><span class="function"><span class="keyword">public</span> HttpSecurity <span class="title">addFilter</span><span class="params">(Filter filter)</span> </span>&#123;Class&lt;? extends Filter&gt; filterClass = filter.getClass();<span class="keyword">if</span> (!comparator.isRegistered(filterClass)) &#123;<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"..."</span>);&#125;<span class="keyword">this</span>.filters.add(filter);<span class="keyword">return</span> <span class="keyword">this</span>;&#125;</code></pre></code></pre></div></div><div class="paragraph"><p>我们可以看到，<code>Filter</code> 会被直接加到 <code>List</code> 中，而不是按照一定的顺序来加入的。但同时，我们也发现了一个 <code>comparator</code> 对象，并且只有被注册到了该类的 <code>Filter</code> 才能被加入到 <code>filters</code> 属性中。这个 <code>comparator</code> 又是用来做什么的呢？</p></div><div class="paragraph"><p>在 Spring Security 创建过程中，会调用到 <code>HttpSeciryt.performBuild</code> 方法，在这里我们可以看到 <code>filters</code> 和 <code>comparator</code> 是如何被使用到的。</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-java" data-lang="java"><pre><code class="highlight java"><span class="function"><span class="keyword">protected</span> DefaultSecurityFilterChain <span class="title">performBuild</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;Collections.sort(filters, comparator);<span class="keyword">return</span> <span class="keyword">new</span> DefaultSecurityFilterChain(requestMatcher, filters);&#125;</code></pre></code></pre></div></div><div class="paragraph"><p>可以看到，Spring Security 使用了这个 <code>comparator</code> 在获取 <code>SecurityFilterChain</code> 的时候来保证 <code>filters</code> 的顺序，所以，研究这个 <code>comparator</code> 就能知道在 <code>SecurityFilterChain</code> 中的那些 <code>Filter</code> 的顺序是如何的了。</p></div><div class="paragraph"><p>这个 <code>comparator</code> 的类型是 <code>FilterComparator</code> ，从名字就能看出来是专用于 <code>Filter</code> 比较的类，它的实现也并不神秘，从构造函数就能猜到是如何实现的：</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-java" data-lang="java"><pre><code class="highlight java">FilterComparator() &#123;Step order = <span class="keyword">new</span> Step(INITIAL_ORDER, ORDER_STEP);put(ChannelProcessingFilter<span class="class">.<span class="keyword">class</span>, <span class="title">order</span>.<span class="title">next</span>())</span>;put(ConcurrentSessionFilter<span class="class">.<span class="keyword">class</span>, <span class="title">order</span>.<span class="title">next</span>())</span>;put(WebAsyncManagerIntegrationFilter<span class="class">.<span class="keyword">class</span>, <span class="title">order</span>.<span class="title">next</span>())</span>;put(SecurityContextPersistenceFilter<span class="class">.<span class="keyword">class</span>, <span class="title">order</span>.<span class="title">next</span>())</span>;put(HeaderWriterFilter<span class="class">.<span class="keyword">class</span>, <span class="title">order</span>.<span class="title">next</span>())</span>;put(CorsFilter<span class="class">.<span class="keyword">class</span>, <span class="title">order</span>.<span class="title">next</span>())</span>;  <span class="comment">// 省略代码</span>&#125;</code></pre></code></pre></div></div><div class="paragraph"><p>可以看到 <code>CorsFilter</code> 排在了第六位，在所有的 Security Filter 之前，由此便解决了 <code>preflight request</code> 没有携带认证信息的问题。</p></div></div><div class="sect3"><h4 id="_小结_3">小结</h4><div class="paragraph"><p>引入 <code>Spring Security</code> 之后，我们的 <code>CORS</code> 验证实际上是依然运行着的，只是因为 <code>preflight request</code> 不会携带认证信息，所以无法通过身份验证。使用 <code>HttpSecurity.cors</code> 方法会帮助我们在当前的 Spring Context 中找到或创建一个 <code>CorsFilter</code> 并安排在身份验证的 <code>Filter</code> 之前，以保证能对 <code>preflight request</code> 正确处理。</p></div></div></div></div></div><div class="sect1"><h2 id="_总结">总结</h2><div class="sectionbody"><div class="paragraph"><p>研究了 Spring 中 CORS 的代码，我们了解到了这样一些知识：</p></div><div class="ulist"><ul><li><p>实现 <code>WebMvcConfigurer.addCorsMappings</code> 方法来进行的 <code>CORS</code> 配置，最后会在 Spring 的 <code>Interceptor</code> 或 <code>Handler</code> 中生效</p></li><li><p>注入 <code>CorsFilter</code> 的方式会让 <code>CORS</code> 验证在 <code>Filter</code> 中生效</p></li><li><p>引入 <code>Spring Security</code> 后，需要调用 <code>HttpSecurity.cors</code> 方法以保证 <code>CorsFilter</code> 会在身份验证相关的 <code>Filter</code> 之前执行</p></li><li><p><code>HttpSecurity.cors</code> + <code>WebMvcConfigurer.addCorsMappings</code> 是一种相对低效的方式，会导致跨域请求分别在 <code>Filter</code> 和 <code>Interceptor</code> 层各经历一次 <code>CORS</code> 验证</p></li><li><p><code>HttpSecurity.cors</code> + 注册 <code>CorsFilter</code> 与 <code>HttpSecurity.cors</code> + 注册 <code>CorsConfigurationSource</code> 在运行的时候是等效的</p></li><li><p>在 Spring 中，没有通过 <code>CORS</code> 验证的请求会得到状态码为 403 的响应</p></li></ul></div></div></div>]]></content:encoded>
      
      <comments>https://blog.gaoyuexiang.cn/2019/06/14/how-spring-implement-cors/#disqus_thread</comments>
    </item>
    
    <item>
      <title>HTTP Headers 之 Origin</title>
      <link>https://blog.gaoyuexiang.cn/2019/05/23/HTTP-Headers-Origin/</link>
      <guid>https://blog.gaoyuexiang.cn/2019/05/23/HTTP-Headers-Origin/</guid>
      <pubDate>Thu, 23 May 2019 21:33:34 GMT</pubDate>
      <description>
      
        &lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_概念&quot;&gt;概念&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;HTTP 协议中的 Origin Header &lt;strong&gt;存在于请求中&lt;/strong&gt;，&lt;strong&gt;用于指明当前请求来自于哪个站点&lt;/strong&gt;。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_字段内容&quot;&gt;字段内容&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Origin 仅仅包含站点信息，&lt;strong&gt;不包含&lt;/strong&gt;任何路径信息。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_语法&quot;&gt;语法&lt;/h3&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;pre&gt;&lt;code class=&quot;highlight plain&quot;&gt;Origin: &amp;quot;&amp;quot;
Origin: &amp;quot;&amp;lt;schema&amp;gt;:&amp;#x2F;&amp;#x2F;&amp;lt;host&amp;gt;[:port]&amp;quot;
&amp;#x2F;&amp;#x2F; 例如
Origin: &amp;quot;https:&amp;#x2F;&amp;#x2F;baidu.com&amp;quot;
&amp;#x2F;&amp;#x2F; 错误示范，包含了路径信息
Origin: &amp;quot;https:&amp;#x2F;&amp;#x2F;baidu.com&amp;#x2F;&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;参考： &lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Origin&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Origin&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<div class="sect1"><h2 id="_概念">概念</h2><div class="sectionbody"><div class="paragraph"><p>HTTP 协议中的 Origin Header <strong>存在于请求中</strong>，<strong>用于指明当前请求来自于哪个站点</strong>。</p></div><div class="sect2"><h3 id="_字段内容">字段内容</h3><div class="paragraph"><p>Origin 仅仅包含站点信息，<strong>不包含</strong>任何路径信息。</p></div></div><div class="sect2"><h3 id="_语法">语法</h3><div class="listingblock"><div class="content"><pre class="highlight"><code><pre><code class="highlight plain">Origin: &quot;&quot;Origin: &quot;&lt;schema&gt;:&#x2F;&#x2F;&lt;host&gt;[:port]&quot;&#x2F;&#x2F; 例如Origin: &quot;https:&#x2F;&#x2F;baidu.com&quot;&#x2F;&#x2F; 错误示范，包含了路径信息Origin: &quot;https:&#x2F;&#x2F;baidu.com&#x2F;&quot;</code></pre></code></pre></div></div><div class="paragraph"><p>参考： <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Origin" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Origin</a></p></div></div></div></div><div class="sect1"><h2 id="_应用">应用</h2><div class="sectionbody"><div class="sect2"><h3 id="_cors">CORS</h3><div class="paragraph"><p>当我们的浏览器发出跨站请求时，行为正确的服务器会校验当前请求是不是来自被允许的站点。服务器就是通过 <code>Origin</code> 字段的值来进行的判断。</p></div><div class="paragraph"><p>当服务器的配置出错时，比如配置成了 <code><a href="https://baidu.com/" target="_blank" rel="noopener" class="bare">https://baidu.com/</a></code>，则可能造成一些难以理解的问题。</p></div><div class="paragraph"><p>比如有的浏览器（IE）能够请求成功，而有的浏览器却请求失败（Chrome）。这不是因为前一个浏览器行为正确，而是因为前一个浏览器发出请求时没有带上 <code>Origin</code> 而后一个浏览器带上了正确的 <code>Origin</code>。而在服务器端，因为没有 <code>Origin</code> Header，所以认为这不是一次 <code>CORS</code> 请求，所以没有进行 <code>CORS</code> 校验。这也反过来要求服务端强制请求带上 <code>Origin</code> Header，才能进一步保证服务器的安全性。</p></div></div></div></div>]]></content:encoded>
      
      <comments>https://blog.gaoyuexiang.cn/2019/05/23/HTTP-Headers-Origin/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java内存回收算法介绍</title>
      <link>https://blog.gaoyuexiang.cn/2019/02/10/Java-memory-collection-algorithms/</link>
      <guid>https://blog.gaoyuexiang.cn/2019/02/10/Java-memory-collection-algorithms/</guid>
      <pubDate>Sun, 10 Feb 2019 22:18:24 GMT</pubDate>
      <description>
      
        &lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;code&gt;JVM&lt;/code&gt; 提供了自动化的内存管理，使得开发者不需要编写内存回收的代码。但是，&lt;code&gt;JVM&lt;/code&gt; 是如何工作的呢？是如何知道哪些内存应该被清理呢？又如何减小垃圾回收时产生的问题的影响呢？周志明的《深入理解 Java 虚拟机》可以给我们答案，本文主要针对垃圾收集&lt;strong&gt;算法&lt;/strong&gt;做介绍。&lt;/p&gt;
&lt;/div&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<div class="paragraph"><p><code>JVM</code> 提供了自动化的内存管理，使得开发者不需要编写内存回收的代码。但是，<code>JVM</code> 是如何工作的呢？是如何知道哪些内存应该被清理呢？又如何减小垃圾回收时产生的问题的影响呢？周志明的《深入理解 Java 虚拟机》可以给我们答案，本文主要针对垃圾收集<strong>算法</strong>做介绍。</p></div><div class="sect1"><h2 id="_如何判断对象是否存活">如何判断对象是否存活</h2><div class="sectionbody"><div class="paragraph"><p><code>JVM</code> 要收集垃圾，那么久需要先判断哪些内容是垃圾，需要被收集。</p></div><div class="sect2"><h3 id="_引用计数算法">引用计数算法</h3><div class="paragraph"><p>该算法是指，给对象添加一个引用计数器，每当有一个地方引用它时，计数器加一；当引用失效时，计数器减一。</p></div><div class="paragraph"><p>这个算法看上去很简单，但是有一个很大的问题，就是没有办法解决循环引用的问题。比如，<code>A</code> 引用了 <code>B</code>，<code>B</code> 引用了 <code>C</code>，<code>C</code> 又引用了 <code>A</code>。这样每个对象都被引用了一次，但是有可能 <code>ABC</code> 三个对象我们都不再需要，也就是它们都是垃圾。但这个算法却会认为它们都被引用了，所以它们都不是垃圾，也就永远都不会被回收了。</p></div><div class="paragraph"><p>所以这个算法不应该被采用。</p></div></div><div class="sect2"><h3 id="_可达性分析算法">可达性分析算法</h3><div class="paragraph"><p>这个算法的思路是，定义一系列称作 <code>GC Roots</code> 的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径成为引用链（<code>Reference Chain</code>），当一个对象到 <code>GC Roots</code> 没有任何引用链相连时，说明这个对象是不可达对象。</p></div><div class="paragraph"><p>这个算法就解决了循环引用的问题，并且也是 <code>JVM</code> 中主流的实现。</p></div><div class="paragraph"><p><code>JVM</code> 中可以作为 <code>GC Roots</code> 的对象有：</p></div><div class="ulist"><ul><li><p>虚拟机栈中<strong>引用的对象</strong></p></li><li><p>方法区中静态属性<strong>引用的对象</strong></p></li><li><p>方法区中常量<strong>引用的对象</strong></p></li><li><p>本地方法栈中 <code>Native</code> 方法<strong>引用的对象</strong></p></li></ul></div></div></div></div><div class="sect1"><h2 id="_如何清理垃圾">如何清理垃圾</h2><div class="sectionbody"><div class="paragraph"><p>前面判断了一个对象是不是垃圾，接下来，就要看看我们应该如何清理这些垃圾了。</p></div><div class="sect2"><h3 id="_标记_清除算法mark_sweep">标记-清除算法（Mark-Sweep）</h3><div class="paragraph"><p>这个算法顾名思义，就是先标记出需要回收的对象，然后清除它们。这个算法没有被采用，主要是两个原因：</p></div><div class="olist arabic"><ol class="arabic"><li><p>效率低：无论是 <code>标记</code> 还是 <code>清除</code>，这两个过程的效率都很低下。</p></li><li><p>容易产生空间碎片：在 <code>清除</code> 过后，容易产生大量不连续的内存碎片，导致在分配大对象时找不到足够的连续空间来分配。</p></li></ol></div><div class="paragraph"><p>由此，人们基于这个算法进行改进，衍生出了后来的算法。</p></div></div><div class="sect2"><h3 id="_复制算法copying">复制算法（Copying）</h3><div class="paragraph"><p>将内存按容量分为大小相等的两块，每次只使用其中一块。垃圾回收时，将还存活的对象复制到另一块上面去，然后将刚才使用的这一块空间全部清除。</p></div><div class="paragraph"><p>优点：</p></div><div class="olist arabic"><ol class="arabic"><li><p>效率更高：每次都是对整个半块内存进行回收</p></li><li><p>避免了空间碎片问题</p></li></ol></div><div class="paragraph"><p>缺点：</p></div><div class="olist arabic"><ol class="arabic"><li><p>能够使用的内存只有一半，利用率仅有 50%。</p></li></ol></div><div class="paragraph"><p>复制算法经过改良后，被广泛的使用到 <code><strong>新生代</strong></code> 的内存回收中。</p></div><div class="sect3"><h4 id="_改进">改进</h4><div class="paragraph"><p>IBM 的研究表面，<code>JVM</code> 新生代中 98% 的对象都是“朝生夕死”的，所以没有必要按照 1:1 来划分内存空间。而在 <code>HotSpot</code> 的实现中，恰好是这样设计的。</p></div><div class="paragraph"><p><code>HotSpot</code> 将 <code>新生代</code> 分为一块较大的 <code>Eden</code> 空间和两块较小且大小相等的 <code>Survivor</code> 空间，默认比例是 8:1:1。</p></div><div class="olist arabic"><ol class="arabic"><li><p>每次使用 <code>Eden</code> 和其中一块 <code>Survivor</code></p></li><li><p>回收时，将 <code>Eden</code> 和 <code>Survivor</code> 中还存活的对象复制到另一块 <code>Survivor</code> 中去</p></li><li><p>清理掉 <code>Eden</code> 和刚才使用的那块 <code>Survivor</code></p></li><li><p>如果 <code>Survivor</code> 没有足够的空间存放对象，那么这些对象需要通过内存担保机制存入老年代</p></li></ol></div></div></div><div class="sect2"><h3 id="_标记_整理算法mark_compact">标记-整理算法（Mark-Compact）</h3><div class="paragraph"><p>顾名思义，与 <code>标记-清除</code> 算法的区别是，该算法会让所有存活的对象都向一端移动，然后直接清理掉边界之外的内存。这样可以成功的避免内存碎片。</p></div><div class="paragraph"><p><code>标记-整理</code> 算法没有解决效率低的问题，所以显而易见，没有理由在 <code>新生代</code> 中用它替换 <code>复制</code> 算法。但由于 <code>复制</code> 算法按 1:1 划分时会浪费空间，划分 <code>Eden</code> &amp; <code>Survivor</code> 又需要内存担保，所以在对象存活率较高的老年代中不适合使用。而 <code>标记-整理</code>/<code>标记-清理</code> 算法则更适合于这样的场景。</p></div></div><div class="sect2"><h3 id="_分代收集算法">分代收集算法</h3><div class="paragraph"><p>这并不是新的算法，而是根据对象存活周期的不同，将内存分为几块，分别采用不同的收集算法。</p></div><div class="paragraph"><p>我们一般把 <code>Java 堆</code> 分为新生代和老年代。</p></div><div class="dlist"><dl><dt class="hdlist1">新生代</dt><dd><p>研究表明，每次收集新生代内存时，都有大量对象死去，只有少量对象存活，所以采用改进的 <code>复制</code> 算法，付出少量对象的复制成本就可以完成收集。</p></dd><dt class="hdlist1">老年代</dt><dd><p>老年代对象存活率高，没有额外空间进行内存担保，所以没有办法使用 <code>复制</code> 算法，就必须采用 <code>Mark-Compact</code> 或 <code>Mark-Sweep</code> 算法。</p></dd></dl></div></div></div></div><div class="sect1"><h2 id="_总结">总结</h2><div class="sectionbody"><div class="paragraph"><p><code>JVM</code> 通过 <code>可达性分析算法</code> 标记需要被收集的对象，然后通过 <code>Copying</code>、 <code>Mark-Sweep</code> 和 <code>Mark-Compact</code> 算法的配合回收内存。 <code>Copying</code> 算法被改良后划分出一个 <code>Eden</code> 和两个 <code>Survivor</code> 区域，比例为 8:1:1，用于 <code>新生代</code>；<code>Mark-Sweep</code> 和 <code>Mark-Compact</code> 用于 <code>老年代</code>。</p></div></div></div>]]></content:encoded>
      
      <comments>https://blog.gaoyuexiang.cn/2019/02/10/Java-memory-collection-algorithms/#disqus_thread</comments>
    </item>
    
    <item>
      <title>使用 git submodule 管理 Hexo 博客的主题</title>
      <link>https://blog.gaoyuexiang.cn/2018/12/20/Use-Git-Submodule-to-Manage-Your-Hexo-Theme/</link>
      <guid>https://blog.gaoyuexiang.cn/2018/12/20/Use-Git-Submodule-to-Manage-Your-Hexo-Theme/</guid>
      <pubDate>Thu, 20 Dec 2018 01:26:17 GMT</pubDate>
      <description>
      
        &lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;个人十分喜欢 &lt;code&gt;Hexo&lt;/code&gt; 博客框架下的 &lt;code&gt;NexT&lt;/code&gt; 主题，所以自己的博客也就选择的这个主题。然而最近换了电脑之后傻眼了，&lt;code&gt;git clone&lt;/code&gt; 之后发现 &lt;code&gt;themes/next&lt;/code&gt; 是个空目录，&lt;code&gt;github&lt;/code&gt; 上面也是同样的空目录，并且没有任何办法可以找回当时目录里的东西。回顾自己当时刚开始使用时的场景，一切要从 &lt;code&gt;NexT&lt;/code&gt; 的官网说起。&lt;/p&gt;
&lt;/div&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<div class="paragraph"><p>个人十分喜欢 <code>Hexo</code> 博客框架下的 <code>NexT</code> 主题，所以自己的博客也就选择的这个主题。然而最近换了电脑之后傻眼了，<code>git clone</code> 之后发现 <code>themes/next</code> 是个空目录，<code>github</code> 上面也是同样的空目录，并且没有任何办法可以找回当时目录里的东西。回顾自己当时刚开始使用时的场景，一切要从 <code>NexT</code> 的官网说起。</p></div><div class="sect1"><h2 id="_next_官方推荐的安装方式">NexT 官方推荐的安装方式</h2><div class="sectionbody"><div class="paragraph"><p><code>Hexo</code> 博客框架允许我们指定任何主题，被选定的主题需要在 <code>$&#123;root&#125;/themes</code> 目录下具有一个与指定名称相同的目录。比如，我们指定使用的主题名字叫做 <code>next</code> ，那么我们就需要在 <code>$&#123;root&#125;/themes</code> 目录下面存在一个叫做 <code>next</code> 的目录（本文不涉及此目录内容）。</p></div><div class="paragraph"><p>现在我们有了一个想要使用的目录，假设就是 <code>NexT</code> 吧，自然会想到去官方网站看看有没有什么推荐的使用方式。于是 <code>NexT</code> 官网让我们这样安装：</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-shell" data-lang="shell"><pre><code class="highlight shell"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> your-hexo-site</span><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span></code></pre></code></pre></div></div><div class="paragraph"><p>不仅是 <code>NexT</code>，还有很多其他的主题都是推荐的这样的安装方式。而这样的安装方式却会带来 <code>git</code> 仓库嵌套的问题。我们会发现我们的 <code>Hexo</code> 仓库不能识别到 <code>$&#123;root&#125;/themes/next</code> 仓库里面修改的内容，只能识别到它被修改了。这也就意味着，我们的 <code>Hexo</code> 仓库不知道 <code>$&#123;root&#125;/themes/next</code> 仓库里的内容。所以我们在克隆这个仓库之后，不知道这个主题下的文件从哪里来，有什么内容。</p></div><div class="quoteblock"><blockquote><div class="paragraph"><p>关于 <code>git</code> 嵌套仓库的问题，可以参考这里的讨论： <a href="https://github.com/swcarpentry/git-novice/issues/272" target="_blank" rel="noopener" class="bare">https://github.com/swcarpentry/git-novice/issues/272</a></p></div></blockquote></div></div></div><div class="sect1"><h2 id="_正确的使用方式">正确的使用方式</h2><div class="sectionbody"><div class="paragraph"><p>现在，我们已经知道使用嵌套的 <code>git</code> 仓库是一个 <code>anti-pattern</code>，并且会导致我们丢失文件。那么正确的做法应该是什么呢？</p></div><div class="sect2"><h3 id="_git_submodule_天降神兵">git submodule 天降神兵</h3><div class="paragraph"><p>首先解决“从哪里来”的问题。</p></div><div class="paragraph"><p>因为我们需要使用到别人开发的主题，而且要做一些自定义修改，所以我们必须要拿到源码。这个时候我们就可以考虑使用 <code>git submodule</code> 了，这里正好满足使用 <code>submodule</code> 的情况。</p></div><div class="quoteblock"><blockquote><div class="paragraph"><p><code>git submodule</code> 文档看这里： <a href="https://git-scm.com/book/en/v2/Git-Tools-Submodules" target="_blank" rel="noopener" class="bare">https://git-scm.com/book/en/v2/Git-Tools-Submodules</a></p></div></blockquote></div><div class="paragraph"><p>要使用 <code>git submodule</code> 我们就不能按照 <code>NexT</code> 这些主题官网提供的安装方式，而需要使用 <code>git submodule</code> 的方式：</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-shell" data-lang="shell"><pre><code class="highlight shell"><span class="meta">$</span><span class="bash"> git submodule add git@github.com:iissnan/hexo-theme-next themes/next</span>Cloning into '/I/wont/show/this/blog/themes/next'...remote: Enumerating objects: 12036, done.remote: Total 12036 (delta 0), reused 0 (delta 0), pack-reused 12036Receiving objects: 100% (12036/12036), 12.95 MiB | 1.32 MiB/s, done.Resolving deltas: 100% (6967/6967), done.</code></pre></code></pre></div></div><div class="paragraph"><p>现在，我们的 <code>submodule</code> 已经克隆好了，并且在我们的 <code>Hexo</code> 目录下面会多一个 <code>.gitmodules</code> 文件，我们可以看看里面的内容：</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-shell" data-lang="shell"><pre><code class="highlight shell"><span class="meta">$</span><span class="bash"> cat .gitmodules</span>[submodule "themes/next"]path = themes/nexturl = git@github.com:iissnan/hexo-theme-next</code></pre></code></pre></div></div><div class="paragraph"><p>这个文件描述了当前仓库的 <code>submodule</code> 的信息，并且它会被加入到仓库中。因为我们在使用 <code>git clone</code> 的时候， <code>git</code> 不会帮我们把 <code>submodule</code> 一起克隆。</p></div><div class="paragraph"><p>所以当其他人或我们在其他地方克隆这个仓库之后，就能够通过 <code>.gitmodules</code> 这个文件知道我们所需要的 <code>submodule</code> 能够从哪里获取到。</p></div><div class="paragraph"><p>我们可以通过 <code>git</code> 的命令来获取所有的 <code>submodule</code>：</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-shell" data-lang="shell"><pre><code class="highlight shell"><span class="meta">$</span><span class="bash"> git submodule update --init</span>Submodule 'themes/next' (git@github.com:iissnan/hexo-theme-next) registered for path 'themes/next'Cloning into '/I/wont/show/this/blog/themes/next'...Submodule path 'themes/next': checked out '64302633a60c8f26ebdbad6f3c220e6d8a69723c'</code></pre></code></pre></div></div><div class="paragraph"><p>这样，我们的 <code>NexT</code> 主题又能够回到我们本地的文件中。</p></div></div><div class="sect2"><h3 id="_要好好保存自己的修改">要好好保存自己的修改</h3><div class="paragraph"><p>然后解决“有什么内容”的问题。</p></div><div class="paragraph"><p><code>submodule</code> 解决了“从哪里来”，但是我们对主题做的自定义修改又保存在哪里呢？</p></div><div class="paragraph"><p>如果我们真的按照上面的步骤来操作的话，我们会发现在新设备上的主题配置和我们自定义的配置是不一样的。这样以来，我们新的设备上如果提交，我们自定义的主题配置信息就会丢失了。除非我们重新配置一下主题文件。</p></div><div class="paragraph"><p><strong>但我们是程序员，会永远遵循 <code>DRY</code> 原则</strong>，一定是什么地方出了差错。</p></div><div class="paragraph"><p>前面的操作，我们把 <code>NexT</code> 官方仓库作为我们的 <code>submodule</code>，但因为我们不能把自定义的配置 <code>push</code> 到官方仓库中，所以我们对主题的自定义配置就只能留在本地。</p></div><div class="paragraph"><p>为了保存我们的修改，我们可以将官方仓库 <code>fork</code> 到我们自己的账号下面，获得完全的控制权，然后将这个 <code>fork</code> 的仓库作为博客的 <code>submodule</code>。当我们对主题进行了配置的时候，我们需要将这些更新 <code>push</code> 到 <code>fork</code> 的仓库中，这样在下一次拉取 <code>submodule</code> 的时候就能够拿到我们自己的修改，而不会遇到丢失自定义配置的尴尬了。</p></div><hr></div></div></div><div class="sect1"><h2 id="_总结">总结</h2><div class="sectionbody"><div class="paragraph"><p>所以，在 <code>Hexo</code> 中对自定义主题进行版本管理的正确操作就是：</p></div><div class="olist arabic"><ol class="arabic"><li><p>找到主题的 <code>Repo</code></p></li><li><p><code>fork</code> 到自己的账号下</p></li><li><p>将 <code>fork</code> 的仓库作为 <code>Hexo</code> 仓库的 <code>submodule</code></p></li></ol></div></div></div>]]></content:encoded>
      
      <comments>https://blog.gaoyuexiang.cn/2018/12/20/Use-Git-Submodule-to-Manage-Your-Hexo-Theme/#disqus_thread</comments>
    </item>
    
    <item>
      <title>什么是 Twelve-Factor App</title>
      <link>https://blog.gaoyuexiang.cn/2018/09/27/what-is-12-factors-app/</link>
      <guid>https://blog.gaoyuexiang.cn/2018/09/27/what-is-12-factors-app/</guid>
      <pubDate>Thu, 27 Sep 2018 01:14:37 GMT</pubDate>
      <description>
      
        &lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;在学习 &lt;code&gt;Spring Cloud&lt;/code&gt; 的时候，文档一开始就提到了一个概念：Twelve-Factor App。这勾起了我的好奇心，刚好有个网站用来解释这个东西，这里谈谈我的理解。 &lt;a href=&quot;https://12factor.net&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; class=&quot;bare&quot;&gt;https://12factor.net&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<div class="paragraph"><p>在学习 <code>Spring Cloud</code> 的时候，文档一开始就提到了一个概念：Twelve-Factor App。这勾起了我的好奇心，刚好有个网站用来解释这个东西，这里谈谈我的理解。 <a href="https://12factor.net" target="_blank" rel="noopener" class="bare">https://12factor.net</a></p></div><div class="sect1"><h2 id="_什么是_twelve_factor_app">什么是 Twelve-Factor App</h2><div class="sectionbody"><div class="paragraph"><p>首先，twelve-factor app 是由 <code>Heroku</code> 提出的一种用于构建 <code>software-as-a-service</code> (SaaS) 应用的方法论。但不是所有的 <code>SaaS</code> 应用都是 twelve-factor app，只有符合一些特征，才是一个 twelve-factor app。</p></div><div class="ulist"><ul><li><p>Use <strong>declarative</strong> formats for setup automation, to minimize time and cost for new developers joining the project;</p><div class="paragraph"><p>通过声明的方式来自动化配置，以达到最小化项目新成员的时间成本和学习成本。这一点很好理解。</p></div></li><li><p>Have a <strong>clean contract</strong> with the underlying operating system, offering <strong>maximum portability</strong> between execution environments;</p><div class="paragraph"><p>和底层系统之间有明确的契约，这样就能提供最大的可移植性。</p></div><div class="paragraph"><p>类似于我们现在推崇的使用 <code>docker</code> 来输出我们的软件，这样我们只需要 <code>docker</code> 的环境就能运行我们的软件；而不是提供一个 <code>jar</code> 包或者前端打包的压缩文件，需要我们自行安装 <code>java</code> 或者 <code>nginx</code> 才能运行。</p></div></li><li><p>Are suitable for <strong>deployment</strong> on modern <strong>cloud platforms</strong>, obviating the need for servers and systems administration;</p><div class="paragraph"><p>适用于部署到现代云计算平台，从而避免对服务器或系统管理员的需求。</p></div><div class="paragraph"><p>其实，这样的要求就是在减小移植的成本。</p></div></li><li><p><strong>Minimize divergence</strong> between development and production, enabling <strong>continuous deployment</strong> for maximum agility;</p><div class="paragraph"><p>最小化开发环境和生产环境的差异，并启用持续部署来最大化敏捷实践。</p></div><div class="paragraph"><p>减少开发环境和生产环境的差异，有利于我们提早发现问题和排查问题。持续部署作为一种敏捷实践，应该大力推行。</p></div></li><li><p>And can <strong>scale up</strong> without significant changes to tooling, architecture, or development practices.</p><div class="paragraph"><p>可以在不对使用的工具、基础设施和开发实践进行重大改动的情况下进行“放大”。</p></div><div class="paragraph"><p>这里的“放大”，可以指部署上的水平扩容或者功能上的改进等等。</p></div></li></ul></div></div></div><div class="sect1"><h2 id="_为什么需要_twelve_factor_app">为什么需要 Twelve-Factor App</h2><div class="sectionbody"><div class="paragraph"><p>在面对现代软件开发过程中，我们会遇到很多系统性的问题。<code>Heroku</code> 提出 Twelve-Factor App 的初衷，是为了增强我们对这些问题的认知，并提供专用的名次来命名这些问题，同时提出针对这些问题的广义上的解决方案。</p></div><div class="quoteblock"><blockquote><div class="paragraph"><p>这里的 <code>广义上的</code> ，原文用词 <code>conceptual</code> ，可以理解为是抽象的解决方案，而不是具体的解决方案。</p></div></blockquote></div><div class="paragraph"><p>这些问题和解决方案，也不是随便找了一些人来闭门造车想出来的，而是邀请了直接或间接参与了大量应用的开发、部署、运维以及扩展的拥有丰富经验的 IT 从业人员参与讨论，得出了这些系统性的问题和对应的解决方案。</p></div></div></div><div class="sect1"><h2 id="_twelve_factor_是哪十二个">Twelve-Factor 是哪十二个</h2><div class="sectionbody"><div class="paragraph"><p>Twelve-Factor App 提出了十二个方面的解决方案，这也是它的名字的由来。而每一点，官网都提供了一句话的总结和详细的描述。这里暂时简单记录一下。</p></div><div class="sect2"><h3 id="_1_codebase">1.Codebase</h3><div class="paragraph"><p>一句话总结：一份基准代码，多次部署。</p></div><div class="paragraph"><p><a href="https://12factor.net/codebase" target="_blank" rel="noopener">英文</a> <a href="https://www.12factor.net/zh_cn/codebase" target="_blank" rel="noopener">中文</a></p></div></div><div class="sect2"><h3 id="_2_dependencies">2.Dependencies</h3><div class="paragraph"><p>一句话总结：显式的声明依赖。</p></div><div class="paragraph"><p><a href="https://12factor.net/dependencies" target="_blank" rel="noopener">英文</a> <a href="https://www.12factor.net/zh_cn/dependencies" target="_blank" rel="noopener">中文</a></p></div></div><div class="sect2"><h3 id="_3_config">3.Config</h3><div class="paragraph"><p>一句话总结：在部署的环境中存储配置。</p></div><div class="paragraph"><p>这里说的配置，是指在各个部署环境中不同的值。如果某个配置在不同的环境中是相同的，那么它就不应该是一个配置。所以，这里的配置一定会针对到具体的环境中，我们应该将它们与环境绑定起来。</p></div><div class="paragraph"><p><a href="https://12factor.net/config" target="_blank" rel="noopener">英文</a> <a href="https://www.12factor.net/zh_cn/config" target="_blank" rel="noopener">中文</a></p></div></div><div class="sect2"><h3 id="_4_backing_services">4.Backing services</h3><div class="paragraph"><p>一句话总结：将后端服务当作附加资源。</p></div><div class="paragraph"><p>后端服务，不是平时所理解的 Web 应用的服务器那个后端，而是应用所调用到的其他服务，比如数据库、对象存储等等。当作附加资源，要求我们可以在不修改代码的情况下，可以切换所依赖的这些资源。比如，通过修改数据库的 URL、用户名等，切换到其他的数据库服务。</p></div><div class="paragraph"><p><a href="https://12factor.net/backing-services" target="_blank" rel="noopener">英文</a> <a href="https://www.12factor.net/zh_cn/backing-services" target="_blank" rel="noopener">中文</a></p></div></div><div class="sect2"><h3 id="_5_build_release_run">5.Build, release run</h3><div class="paragraph"><p>一句话总结：严格分离构建、发布和运行的阶段。</p></div><div class="paragraph"><p>由于每一个阶段对系统健壮性、信息完整度的要求并不一致，对不同的阶段采取不同的措施是很有必要的。</p></div><div class="paragraph"><p><a href="https://12factor.net/build-release-run" target="_blank" rel="noopener">英文</a> <a href="https://www.12factor.net/zh_cn/build-release-run" target="_blank" rel="noopener">中文</a></p></div></div><div class="sect2"><h3 id="_6_processes">6.Processes</h3><div class="paragraph"><p>一句话总结：以一个或多个无状态进程运行应用。</p></div><div class="paragraph"><p><a href="https://12factor.net/processes" target="_blank" rel="noopener">英文</a> <a href="https://www.12factor.net/zh_cn/processes" target="_blank" rel="noopener">中文</a></p></div></div><div class="sect2"><h3 id="_7_port_binding">7.Port binding</h3><div class="paragraph"><p>一句话总结：通过绑定端口来提供服务。</p></div><div class="paragraph"><p><a href="https://12factor.net/port-binding" target="_blank" rel="noopener">英文</a> <a href="https://www.12factor.net/zh_cn/port-binding" target="_blank" rel="noopener">中文</a></p></div></div><div class="sect2"><h3 id="_8_concurrency">8.Concurrency</h3><div class="paragraph"><p>一句话总结：通过进程模型来进行扩展。</p></div><div class="paragraph"><p>在 twelve-factor app 中，进程是一等公民。Twelve-factor app 借鉴 <a href="https://adam.herokuapp.com/past/2011/5/9/applying_the_unix_process_model_to_web_apps/" target="_blank" rel="noopener">unix 守护进程模型</a> 来设计应用架构，将不同的工作分配给不同的进程类型来处理。</p></div><div class="paragraph"><p><a href="https://12factor.net/concurrency" target="_blank" rel="noopener">英文</a> <a href="https://www.12factor.net/zh_cn/concurrency" target="_blank" rel="noopener">中文</a></p></div></div><div class="sect2"><h3 id="_9_disposability">9.Disposability</h3><div class="paragraph"><p>一句话总结：快速和优雅的启动、终止进程，可最大化健壮性。</p></div><div class="paragraph"><p>易处理的进程，意味着进程可以瞬间完成启动和终止。这样有利于快速的对应用进行伸缩、部署新的代码或配置。</p></div><div class="paragraph"><p><a href="https://12factor.net/disposability" target="_blank" rel="noopener">英文</a> <a href="https://www.12factor.net/zh_cn/disposability" target="_blank" rel="noopener">中文</a></p></div></div><div class="sect2"><h3 id="_10_devprod_parity">10.Dev/prod parity</h3><div class="paragraph"><p>一句话总结：尽可能的保持 Dev、staging 和 production 环境一致。</p></div><div class="paragraph"><p><a href="https://12factor.net/dev-prod-parity" target="_blank" rel="noopener">英文</a> <a href="https://www.12factor.net/zh_cn/dev-prod-parity" target="_blank" rel="noopener">中文</a></p></div></div><div class="sect2"><h3 id="_11_logs">11.Logs</h3><div class="paragraph"><p>一句话总结：像对待事件流一样对待日志。</p></div><div class="paragraph"><p><a href="https://12factor.net/logs" target="_blank" rel="noopener">英文</a> <a href="https://www.12factor.net/zh_cn/logs" target="_blank" rel="noopener">中文</a></p></div></div><div class="sect2"><h3 id="_12_admin_processes">12.Admin processes</h3><div class="paragraph"><p>一句话总结：后台管理任务当作一次性进程运行。</p></div><div class="paragraph"><p><a href="https://12factor.net/admin-processes" target="_blank" rel="noopener">英文</a> <a href="https://www.12factor.net/zh_cn/admin-processes" target="_blank" rel="noopener">中文</a></p></div><hr></div></div></div><div class="sect1"><h2 id="_总结">总结</h2><div class="sectionbody"><div class="paragraph"><p>可以将 Twelve-Factor App 理解为一种构建 cloud native 应用的指导原则（方法论），按照这样的原则设计并开发出来的应用，将会十分适用于部署到类似于 <code>Heroku</code> 这样的服务中。</p></div></div></div>]]></content:encoded>
      
      <comments>https://blog.gaoyuexiang.cn/2018/09/27/what-is-12-factors-app/#disqus_thread</comments>
    </item>
    
    <item>
      <title>创建自己的 Spring auto-configuration</title>
      <link>https://blog.gaoyuexiang.cn/2018/08/21/create-your-own-spring-auto-configuration/</link>
      <guid>https://blog.gaoyuexiang.cn/2018/08/21/create-your-own-spring-auto-configuration/</guid>
      <pubDate>Tue, 21 Aug 2018 11:19:05 GMT</pubDate>
      <description>
      
        &lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;code&gt;Spring Boot&lt;/code&gt; 为我们带来了自动配置的舒适体验，极大的提高了开发效率。当我们需要使用第三方库，而这些库没有实现 &lt;code&gt;Spring Boot Auto-Configururation&lt;/code&gt; 时，我们为了避免在不同项目中的重复配置，可能需要为这些库提供 &lt;code&gt;Auto-Configuration&lt;/code&gt;。&lt;/p&gt;
&lt;/div&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<div class="paragraph"><p><code>Spring Boot</code> 为我们带来了自动配置的舒适体验，极大的提高了开发效率。当我们需要使用第三方库，而这些库没有实现 <code>Spring Boot Auto-Configururation</code> 时，我们为了避免在不同项目中的重复配置，可能需要为这些库提供 <code>Auto-Configuration</code>。</p></div><div class="paragraph"><p><code>Spring Boot</code> 为我们提供了自定义 <code>auto-configuration</code> 的方法，可以让我们方便的定义自己的 <code>bean</code> 如何注入容器，这样，我们可以将和 <code>Spring</code> 集成的代码集中起来，减少不必要的重复配置。</p></div><div class="sect1"><h2 id="_spring_如何实现自动配置">Spring 如何实现自动配置</h2><div class="sectionbody"><div class="paragraph"><p><a href="https://www.jianshu.com/p/346cac67bfcc" target="_blank" rel="noopener">简书上的这篇文章</a> 对 <code>Spring Boot</code> 如何实现自动配置做了比较详细的介绍。</p></div><div class="paragraph"><p>简单来说，<code>Spring Boot</code> 提供了 <code>spring-boot-autoconfigure</code> 来实现自动配置，利用 <code>@Conditional</code> 注解判断需要配置的内容。<code>Spring core</code> 中的 <code>SpringFactoriesLoader</code> 类则会扫描 <code>classpath</code> 下所有的 JAR 包中 <code>META-INF/spring.factories</code> 里的内容。这个文件里包含了很多 <code>Spring</code> 里需要的内容，比如 <code>ApplicationContextInitializer</code> 、<code>ApplicationListener</code> 等类的子类信息，<code>Spring</code> 将会根据各自在生命周期中需要加载的时间进行加载。</p></div><div class="listingblock"><div class="title">spring boot autoconfigure 中的 spring.factories 部分内容</div><div class="content"><pre class="highlight"><code class="language-properties" data-lang="properties"><pre><code class="highlight properties"><span class="comment"># Initializers</span><span class="meta">org.springframework.context.ApplicationContextInitializer</span>=<span class="string">\</span>org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer,\<span class="attr">org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener</span><span class="comment"># Application Listeners</span><span class="meta">org.springframework.context.ApplicationListener</span>=<span class="string">\</span><span class="attr">org.springframework.boot.autoconfigure.BackgroundPreinitializer</span><span class="comment"># Auto Configuration Import Listeners</span><span class="meta">org.springframework.boot.autoconfigure.AutoConfigurationImportListener</span>=<span class="string">\</span><span class="attr">org.springframework.boot.autoconfigure.condition.ConditionEvaluationReportAutoConfigurationImportListener</span><span class="comment"># Auto Configuration Import Filters</span><span class="meta">org.springframework.boot.autoconfigure.AutoConfigurationImportFilter</span>=<span class="string">\</span><span class="attr">org.springframework.boot.autoconfigure.condition.OnClassCondition</span><span class="comment"># Auto Configure</span><span class="meta">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span>org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\<span class="attr">org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration</span><span class="comment"># Failure analyzers</span><span class="meta">org.springframework.boot.diagnostics.FailureAnalyzer</span>=<span class="string">\</span>org.springframework.boot.autoconfigure.diagnostics.analyzer.NoSuchBeanDefinitionFailureAnalyzer,\org.springframework.boot.autoconfigure.jdbc.DataSourceBeanCreationFailureAnalyzer,\org.springframework.boot.autoconfigure.jdbc.HikariDriverConfigurationFailureAnalyzer,\<span class="attr">org.springframework.boot.autoconfigure.session.NonUniqueSessionRepositoryFailureAnalyzer</span><span class="comment"># Template availability providers</span><span class="meta">org.springframework.boot.autoconfigure.template.TemplateAvailabilityProvider</span>=<span class="string">\</span><span class="attr">org.springframework.boot.autoconfigure.freemarker.FreeMarkerTemplateAvailabilityProvider,\\</span>org.springframework.boot.autoconfigure.thymeleaf.ThymeleafTemplateAvailabilityProvider,\<span class="attr">org.springframework.boot.autoconfigure.web.servlet.JspTemplateAvailabilityProvider</span></code></pre></code></pre></div></div><div class="paragraph"><p>在 <code>Spring Boot autoconfigure</code> 中，提供了 <code>AutoConfigurationImportSelector</code> 类用来读取 <code>spring.factories</code> 中的 <code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code> 的值，然后 <code>Spring</code> 会加载这里读到的所有的 <code>Configuration</code>。这些被读取到的 <code>Configuration</code> 一定要是 <code>Auto-configuration class</code>，在 <code>Spring</code> 中，被 <code>@Configuration</code> 注解的类就符合这个条件。</p></div></div></div><div class="sect1"><h2 id="_实现自己的_auto_configuration">实现自己的 auto configuration</h2><div class="sectionbody"><div class="paragraph"><p>根据前面的理解，我们很容易想到如何来实现自己的 auto configuration。</p></div><div class="olist arabic"><ol class="arabic"><li><p>编写自定义的配置类，并加上 <code>@Configuration</code> 注解</p></li><li><p>在 <code>resources</code> 目录下创建 <code>META-INF/spring.factories</code></p></li></ol></div><div class="paragraph"><p>在 <code>Spring</code> 官网，也详细的讲述了如何实现自己的自动配置：https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-developing-auto-configuration.html</p></div><div class="paragraph"><p>我们来看一个实际的例子。<code>github</code> 上面有一个项目叫做 <a href="https://github.com/vorburger/MariaDB4j" target="_blank" rel="noopener">MariaDB4j</a>。它可以为我们的 Java 项目提供一个 <code>embedded mariaDB</code>。然而在与 <code>Spring Boot</code> 集成的时候发现，如果要将 <code>mariaDB4j</code> 作为一个 <code>bean</code> 注入到我们的 <code>Spring Context</code> 里，我们需要确保在 <code>mariaDB</code> 启动之后，<code>Spring</code> 才会去加载 <code>dataSource</code>。我们不得不重写一个 <code>dataSource</code> 来注入 <code>Spring</code>。</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-java" data-lang="java"><pre><code class="highlight java"><span class="meta">@Bean</span>@DependsOn("mariaDB4j") #(1)<span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">(DataSourceProperties dataSourceProperties)</span> </span>&#123;    <span class="keyword">return</span> DataSourceBuilder.create()            .driverClassName(dataSourceProperties.getDriverClassName())            .url(dataSourceProperties.getUrl())            .username(dataSourceProperties.getUsername())            .password(dataSourceProperties.getPassword())            .build();&#125;</code></pre></code></pre></div></div><div class="colist arabic"><ol><li><p><code>dataSource</code> 需要等待 <code>mariaDB4j</code> 加载完成才能被加载</p></li></ol></div><div class="paragraph"><p>显然，我们不想在每次使用的时候都要写一份这样的代码，如果能够单纯的把 <code>mariaDB4j</code> 引入到我们的 <code>classpath</code> 中就能使用，那才是我们期望的用法。所以我选择了为它添加 <code>auto-configuration</code> 的方式。</p></div><div class="sect2"><h3 id="_创建_mariadb4jspringconfiguration">创建 MariaDB4jSpringConfiguration</h3><div class="paragraph"><p>将 <code>MariaDB4j</code> 源码拉下来之后，新建了一个名为 <code>mariaDB4j-springboot</code> 的 <code>sub module</code>。然后加上我们需要的依赖。</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-xml" data-lang="xml"><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>$&#123;project.groupId&#125;<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mariaDB4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-autoconfigure-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></code></pre></code></pre></div></div><div class="paragraph"><p>然后，添加我们的 <code>Auto-configuration class</code></p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-java" data-lang="java"><pre><code class="highlight java"><span class="meta">@Configuration</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MariaDB4jSpringConfiguration</span> </span>&#123;    <span class="meta">@Bean</span>    <span class="function"><span class="keyword">public</span> MariaDB4jSpringService <span class="title">mariaDB4j</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> <span class="keyword">new</span> MariaDB4jSpringService();    &#125;&#125;</code></pre></code></pre></div></div><div class="paragraph"><p>接下来，我们需要测试这个配置类能够被成功的加载。这里的测试我还没有理解到，仅仅是按照官网的例子来写了一个测试：</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-java" data-lang="java"><pre><code class="highlight java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MariaDB4JSpringConfigurationTest</span> </span>&#123;    <span class="keyword">private</span> <span class="keyword">final</span> ApplicationContextRunner contextRunner = <span class="keyword">new</span> ApplicationContextRunner()            .withConfiguration(AutoConfigurations.of(MariaDB4jSpringConfiguration<span class="class">.<span class="keyword">class</span>))</span>;    <span class="meta">@Test</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldAutoConfigureEmbeddedMariaDB</span><span class="params">()</span> </span>&#123;        <span class="keyword">this</span>.contextRunner.withUserConfiguration(MariaDB4jSpringConfiguration<span class="class">.<span class="keyword">class</span>)</span><span class="class">                .<span class="title">run</span>(<span class="title">context</span> -&gt; </span>&#123;                    assertThat(context).hasSingleBean(MariaDB4jSpringService<span class="class">.<span class="keyword">class</span>)</span>;                    assertThat(context.getBean(MariaDB4jSpringService<span class="class">.<span class="keyword">class</span>))</span><span class="class">                            .<span class="title">isSameAs</span>(<span class="title">context</span>.<span class="title">getBean</span>(<span class="title">MariaDB4jSpringConfiguration</span>.<span class="title">class</span>).<span class="title">mariaDB4j</span>())</span>;                &#125;);    &#125;&#125;</code></pre></code></pre></div></div><div class="paragraph"><p>这里的不理解在于，创建的这个 <code>ApplicationContextRunner</code> 类不能自动的去扫描 <code>bean</code> 而要让我们手动的去加载它。这样一来，就不能通过这个测试来验证这个类会被自动配置。</p></div></div><div class="sect2"><h3 id="_创建_datasource_bean">创建 dataSource bean</h3><div class="paragraph"><p>在 <code>mariaDB4j</code> 启动完成后，我们就能创建 <code>dataSource</code> 了。因为 <code>Spring</code> 在 <code>dataSource</code> 创建后会尝试连接，所以一定要保证 <code>mariaDB4j</code> 先创建。</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-java" data-lang="java"><pre><code class="highlight java"><span class="meta">@Bean</span>@DependsOn("mariaDB4j") #(1)<span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">(DataSourceProperties dataSourceProperties)</span> </span>&#123;    <span class="keyword">return</span> DataSourceBuilder.create()            .driverClassName(dataSourceProperties.getDriverClassName())            .url(dataSourceProperties.getUrl())            .username(dataSourceProperties.getUsername())            .password(dataSourceProperties.getPassword())            .build();&#125;</code></pre></code></pre></div></div><div class="colist arabic"><ol><li><p>通过 <code>bean</code> 的名称来判断需要依赖哪个 <code>bean</code></p></li></ol></div></div><div class="sect2"><h3 id="_添加_spring_factories">添加 spring.factories</h3><div class="paragraph"><p>有了这些，<code>Spring</code> 还不能自动配置我们的配置类，我们还需要在 <code>src/main/resources/META-INF</code> 下添加 <code>spring.factories</code> 文件，让 <code>Spring</code> 扫描这个文件后知道哪些类可以自动配置。</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-properties" data-lang="properties"><pre><code class="highlight properties"><span class="meta">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span>  ch.vorburger.mariadb4j.springboot.autoconfigure.MariaDB4jSpringConfiguration,\  <span class="attr">ch.vorburger.mariadb4j.springboot.autoconfigure.DataSourceAutoConfiguration</span></code></pre></code></pre></div></div><div class="paragraph"><p>这里添加的类名一定是包含 <code>package</code> 的全名，否则 <code>Spring</code> 找不到指定的类。</p></div><hr><div class="paragraph"><p>现在，我们已经完成了自动配置的工作，打包好后就能使用了：</p></div><div class="listingblock"><div class="title">打包</div><div class="content"><pre class="highlight"><code class="language-bash" data-lang="bash"><pre><code class="highlight bash">mvn clean install</code></pre></code></pre></div></div><div class="paragraph"><p>然后我们能够在本地 <code>maven</code> 仓库看到 <code>ch/vorburger/mariaDB4j</code> 目录下多了一个 <code>mariaDB4j-springboot</code>， 接下来就能使用了。</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-gradle" data-lang="gradle"><pre><code class="highlight gradle"><span class="keyword">dependencies</span> &#123;  testCompile(<span class="string">"ch.vorburger.mariaDB4j:mariaDB4j-springboot:2.3.1-SNAPSHOT"</span>)&#125;</code></pre></code></pre></div></div><div class="paragraph"><p>这次的实践提了一个 <code>PR</code> 到 <a href="https://github.com/vorburger/MariaDB4j/pull/153/(mariaDB4j)，也算是通过实践来学习了。" target="_blank" rel="noopener" class="bare">https://github.com/vorburger/MariaDB4j/pull/153/(mariaDB4j)，也算是通过实践来学习了。</a></p></div></div></div></div><div class="sect1"><h2 id="_总结">总结</h2><div class="sectionbody"><div class="paragraph"><p>要实现自己的 <code>auto-configuration</code> 还算简单，只需要两步：</p></div><div class="olist arabic"><ol class="arabic"><li><p>添加自己的 <code>Configuration</code> 类</p></li><li><p>将自己添加的配置类写到 <code>META-INF/spring.factories</code> 里</p></li></ol></div><div class="paragraph"><p>但是，这背后的实现却有些复杂，值得深入研究。这里会涉及到 <code>Spring</code> 的大量知识，包括各种包的依赖、<code>spring.factories</code> 的读取、<code>@Conditional</code> 注解等等，每一个都可以研究一下写一篇博客出来🐶🐶。</p></div></div></div>]]></content:encoded>
      
      <comments>https://blog.gaoyuexiang.cn/2018/08/21/create-your-own-spring-auto-configuration/#disqus_thread</comments>
    </item>
    
    <item>
      <title>码农一年小结</title>
      <link>https://blog.gaoyuexiang.cn/2018/08/02/biref-summary-of-one-year-of-work/</link>
      <guid>https://blog.gaoyuexiang.cn/2018/08/02/biref-summary-of-one-year-of-work/</guid>
      <pubDate>Thu, 02 Aug 2018 23:29:30 GMT</pubDate>
      <description>
      
        &lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;还差几天就工作满一年了，记录一下一些不足以写成博客的经验吧。&lt;/p&gt;
&lt;/div&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<div class="paragraph"><p>还差几天就工作满一年了，记录一下一些不足以写成博客的经验吧。</p></div><div class="sect1"><h2 id="_关于数据库访问层">关于数据库访问层</h2><div class="sectionbody"><div class="paragraph"><p>做后端开发必定是要访问数据库的，经历的几个项目分别使用了 <code>JDBCTemplate</code> 和 <code>QueryDSL</code> ，一年的使用下来，让我对 <code>JPA</code> 越来越厌恶。</p></div><div class="sect2"><h3 id="_querydsl">QueryDSL</h3><div class="paragraph"><p><code>QueryDSL</code> 是基于 <code>JPA</code> 的，它为我们提供了一种类型安全的类似于 <code>SQL</code> 的 <code>dsl</code>。从语法上来看，确实能带来一定的价值，但相对于负面作用，我认为是得不偿失。</p></div><div class="olist arabic"><ol class="arabic"><li><p>需要预编译</p><div class="paragraph"><p>要使用 <code>QueryDSL</code>，需要先利用它的工具对 <code>@Entity</code> 注解的类进行编译，生成一个 <code>Q</code> 开头的类，用来实现便利的查询工作。虽然不是一个麻烦事，但确实在工作中造成了一些问题。比如在进行单元测试调试时，如果有对 <code>@Entity</code> 的修改，还得手动的执行一下编译任务。</p></div></li><li><p>生成的 <code>SQL</code> 有可能不符合预期</p><div class="paragraph"><p>这是很有可能发生的事情，特别是对于新上手 <code>QueryDSL</code> 的人来说，更是摸不清头脑。这样就需要在每次修改了 <code>DAO</code> 类之后运行一下测试或者启动一下项目才能知道生成的 <code>SQL</code> 到底长什么样子。不过一般来讲，当你熟悉他的语法之后，这样的事情并不会造成太大的困扰。但即使是这样，我们仍然要在每次修改了 <code>DAO</code> 类之后查看一下生成的 <code>SQL</code> 是否符合我们的预期。因为我们就遇到过一些神奇的事情，得到的 <code>SQL</code> 并不符合预期，想来想去只能是 <code>QueryDSL</code> 的 <code>bug</code>。</p></div><div class="paragraph"><p>自动生成 <code>SQL</code> 还会带来一个问题就是，开发者失去了对 <code>SQL</code> 的控制。我曾经也是“在代码里不要出现一句 <code>SQL</code>”的坚定支持者，但是当我经历了不得不对 <code>SQL</code> 进行定制时，才发现这种想法多么可笑。当然，<code>QueryDSL</code> 有办法通过 <code>Expressions.stringTemplate()</code> 方法来定制你想定制的那部分 <code>SQL</code>，但这和其他的 <code>QueryDSL</code> 组合起来时，总显得那么格(bu)格(gou)不(you)入(ya)。</p></div></li><li><p><code>JPA</code> 事务对测试的影响</p><div class="paragraph"><p>我们一般会在 <code>Controller</code> 的下一层，也就是 <code>Service</code> 这一层加上 <code>@Transactional</code> 注解，这样当我们的某个环节出错的时候，就能整个事务回滚，保证操作的原子性。对于这中间的这些 <code>Service</code> ，我们一般会采用没有 <code>Spring</code> 上下文的单元测试，这样可以让这部分的测试负担没有那么重。但是因为 <code>JPA</code> 的加入，情况变得复杂，就算我们的代码通过了这样的单元测试，也不能保证能够正确的执行，测试也就变得没有意义。一种解决办法是不再采用这种单元测试，而使用有 <code>Spring</code> 上下文的测试，这样能够将 <code>JPA</code> 的行为纳入测试中。</p></div><div class="paragraph"><p>但我个人来讲，可能是由于对 <code>JPA</code> 不足够熟悉，不太愿意继续使用 <code>JPA</code>，而更愿意使用 <code>JDBCTemplate</code>。</p></div></li></ol></div></div><div class="sect2"><h3 id="_jdbctemplate">JDBCTemplate</h3><div class="paragraph"><p>其实一开始使用 <code>JDBCTemplate</code> 的时候我是抗拒的，那时我还是 <code>JPA</code> 的支持者，总觉得在代码里面插入 <code>SQL</code> 很不优雅。但是在业务复杂的项目中使用过 <code>JPA</code> 后发现，<code>JDBCTemplate</code> 真香。相比与 <code>JPA</code>，<code>JDBCTemplate</code> 有这些优势：</p></div><div class="olist arabic"><ol class="arabic"><li><p>更轻量</p><div class="paragraph"><p>这一点应该毋庸置疑，毕竟少了一大堆复杂的东西。</p></div></li><li><p>开发者能够完全控制 <code>SQL</code></p><div class="paragraph"><p>特别是当你需要特别的 <code>SQL</code> 的时候，会爱上这一点的。至于代码和数据库解耦这种事情，我的理解是我的数据库可以随意更换，但都是一种数据库，很难有从 <code>MySQL</code> 切换到 <code>PostgreSQL</code> 这种事发生。所以，代码里写 <code>SQL</code> 带来的耦合不一定会让你痛苦。</p></div></li><li><p>无需担心测试通过但不工作的情况</p><div class="paragraph"><p>没有了 <code>JPA</code> ，我们的 <code>Service</code> 由我们全权控制，也就不会出现因为 <code>JPA</code> 事务导致通过测试的代码不能正确执行的情况。</p></div></li></ol></div></div></div></div><div class="sect1"><h2 id="_测试用的数据库">测试用的数据库</h2><div class="sectionbody"><div class="paragraph"><p>在我们的代码部署到 <code>dev</code> 环境之前，一定是会经历一个 <code>CI</code> 的过程的。在 <code>CI</code> 中，我们会运行我们写的所有测试，其中就包括针对 <code>DAO</code> 的测试，这些测试一定是要访问数据库的。那么在 <code>pipeline</code> 中执行测试时访问什么数据库就是一个问题。</p></div><div class="paragraph"><p>过去，我们会考虑采用保存在内存中的 <code>H2</code> 数据库，它随我们的测试启动而启动，随测试结束而结束。看上去这简直是个完美的方案。然而，我们实践发现了一些问题，<code>H2</code> 不支持 <code>MySQL</code> 的全部语法，即使设置了 <code>model=mysql</code>。这使得我们不得不采用它支持的语法来绕过这些问题，甚至于需要迁移 <code>JSON</code> 格式的数据时会发现 <code>migration</code> 没法进行下去了，因为 <code>H2</code> 压根没有 <code>JSON</code> 的任何支持。最后，我们幸运的利用 <code>flyway</code> 支持的 <code>Java Migration</code> 绕过这个限制。</p></div><div class="paragraph"><p>所以我们又重新思考有什么别的方法可以解决当前的问题。</p></div><div class="paragraph"><p>其中一个方案是，在执行测试时，利用 <code>Gradle</code> 的插件启动一个 <code>Docker</code> 容器，测试完成后删掉这个容器。但是这样就要求我们的 <code>pipeline</code> 能够支持 <code>Docker</code>。并且，我们在调试 <code>DAO</code> 测试时也没有办法使用到这个容器中的数据库。不过这两个问题也有办法解决，这个方案也是值得尝试的。</p></div><div class="paragraph"><p>另一个方向是同事前几天发现的 <a href="https://objectpartners.com/2017/06/19/using-mariadb4j-for-a-spring-boot-embedded-database/" target="_blank" rel="noopener">MariaDB4j</a> ，单从这篇文章来看，对于使用 <code>MySQL</code> 的项目，确实是替代 <code>H2</code> 的不错方案。</p></div></div></div><div class="sect1"><h2 id="_hateoas">HATEOAS</h2><div class="sectionbody"><div class="paragraph"><p><code>HATEOAS</code> 是 Hypermedia As The Engine Of Application State 的缩写，处于 Richardson 博士提出的 <a href="https://martinfowler.com/articles/richardsonMaturityModel.html" target="_blank" rel="noopener">REST Maturity Model</a> 中的 Level 3，可以用来引导客户端探索服务端功能。</p></div><div class="paragraph"><p>说实话，我对这个东西的理解不是很深刻，目前实践来看，更适合 Mobile 这样的单一入口的项目，而不适用于网页应用。这是因为整个应用需要一个入口，从这个入口进入才能获得更多的服务。或者，是我们的实践不好，应该支持任意入口进入都能获得完整的服务地图。</p></div></div></div><div class="sect1"><h2 id="_ddd">DDD</h2><div class="sectionbody"><div class="paragraph"><p>领域驱动设计绝对是能够帮助你降低项目无谓复杂度的方法论，当然，前提是你的项目足够复杂。至于如何判断呢？我的理解是当你修改一个业务逻辑却需要到多个地方修改同样的逻辑、或者干脆不知道在哪里能够找到你想找的代码时，就可以考虑 <code>DDD</code> 了。</p></div><div class="paragraph"><p>之所以着么推荐 <code>DDD</code> ，是因为在体验了没有采用 <code>DDD</code> 的项目需求变得日益复杂之后，才发现 <code>DDD</code> 的优势。他能够帮助开发者对代码有更加清晰的了解，也能够将业务表达在代码中。这样既可以将相同的业务代码集中，也能够帮助开发者更容易的找到代码。</p></div><hr><div class="paragraph"><p>以上就是一年工作的一点经验总结，看起来没什么进步，还是要多写博客才行啊。</p></div></div></div>]]></content:encoded>
      
      <comments>https://blog.gaoyuexiang.cn/2018/08/02/biref-summary-of-one-year-of-work/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
